/* tslint:disable */
/* eslint-disable */
/**
 * Tandoor
 * Tandoor API Docs
 *
 * The version of the OpenAPI document: 0.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AccessToken,
  AiLog,
  AiProvider,
  AutoMealPlan,
  Automation,
  BookmarkletImport,
  ConnectorConfig,
  CookLog,
  CustomFilter,
  ExportLog,
  ExportRequest,
  FdcQuery,
  Food,
  FoodBatchUpdate,
  FoodInheritField,
  FoodShoppingUpdate,
  Group,
  Household,
  ImportLog,
  ImportOpenData,
  ImportOpenDataMetaData,
  ImportOpenDataResponse,
  Ingredient,
  IngredientParserRequest,
  IngredientParserResponse,
  InventoryEntry,
  InventoryLocation,
  InventoryLog,
  InviteLink,
  Keyword,
  Localization,
  MealPlan,
  MealType,
  PaginatedAiLogList,
  PaginatedAiProviderList,
  PaginatedAutomationList,
  PaginatedBookmarkletImportListList,
  PaginatedConnectorConfigList,
  PaginatedCookLogList,
  PaginatedCustomFilterList,
  PaginatedExportLogList,
  PaginatedFoodList,
  PaginatedGenericModelReferenceList,
  PaginatedHouseholdList,
  PaginatedImportLogList,
  PaginatedIngredientList,
  PaginatedInventoryEntryList,
  PaginatedInventoryLocationList,
  PaginatedInventoryLogList,
  PaginatedInviteLinkList,
  PaginatedKeywordList,
  PaginatedMealPlanList,
  PaginatedMealTypeList,
  PaginatedPropertyList,
  PaginatedPropertyTypeList,
  PaginatedRecipeBookEntryList,
  PaginatedRecipeBookList,
  PaginatedRecipeImportList,
  PaginatedRecipeOverviewList,
  PaginatedShoppingListEntryList,
  PaginatedShoppingListList,
  PaginatedShoppingListRecipeList,
  PaginatedSpaceList,
  PaginatedStepList,
  PaginatedStorageList,
  PaginatedSupermarketCategoryList,
  PaginatedSupermarketCategoryRelationList,
  PaginatedSupermarketList,
  PaginatedSyncList,
  PaginatedSyncLogList,
  PaginatedUnitConversionList,
  PaginatedUnitList,
  PaginatedUserFileList,
  PaginatedUserSpaceList,
  PaginatedViewLogList,
  PatchedAccessToken,
  PatchedAiProvider,
  PatchedAutomation,
  PatchedBookmarkletImport,
  PatchedConnectorConfig,
  PatchedCookLog,
  PatchedCustomFilter,
  PatchedExportLog,
  PatchedFood,
  PatchedHousehold,
  PatchedImportLog,
  PatchedIngredient,
  PatchedInventoryEntry,
  PatchedInventoryLocation,
  PatchedInviteLink,
  PatchedKeyword,
  PatchedMealPlan,
  PatchedMealType,
  PatchedProperty,
  PatchedPropertyType,
  PatchedRecipe,
  PatchedRecipeBook,
  PatchedRecipeBookEntry,
  PatchedRecipeImport,
  PatchedSearchPreference,
  PatchedShoppingList,
  PatchedShoppingListEntry,
  PatchedShoppingListRecipe,
  PatchedSpace,
  PatchedStep,
  PatchedStorage,
  PatchedSupermarket,
  PatchedSupermarketCategory,
  PatchedSupermarketCategoryRelation,
  PatchedSync,
  PatchedUnit,
  PatchedUnitConversion,
  PatchedUser,
  PatchedUserPreference,
  PatchedUserSpace,
  PatchedViewLog,
  Property,
  PropertyType,
  Recipe,
  RecipeBatchUpdate,
  RecipeBook,
  RecipeBookEntry,
  RecipeFlat,
  RecipeFromSource,
  RecipeFromSourceResponse,
  RecipeImage,
  RecipeImport,
  RecipeShoppingUpdate,
  RecipeSimple,
  SearchFields,
  SearchPreference,
  ServerSettings,
  ShareLink,
  ShoppingList,
  ShoppingListEntry,
  ShoppingListEntryBulk,
  ShoppingListEntryBulkCreate,
  ShoppingListRecipe,
  Space,
  Step,
  Storage,
  Supermarket,
  SupermarketCategory,
  SupermarketCategoryRelation,
  Sync,
  SyncLog,
  Unit,
  UnitConversion,
  User,
  UserFile,
  UserPreference,
  UserSpace,
  ViewLog,
} from '../models/index';
import {
    AccessTokenFromJSON,
    AccessTokenToJSON,
    AiLogFromJSON,
    AiLogToJSON,
    AiProviderFromJSON,
    AiProviderToJSON,
    AutoMealPlanFromJSON,
    AutoMealPlanToJSON,
    AutomationFromJSON,
    AutomationToJSON,
    BookmarkletImportFromJSON,
    BookmarkletImportToJSON,
    ConnectorConfigFromJSON,
    ConnectorConfigToJSON,
    CookLogFromJSON,
    CookLogToJSON,
    CustomFilterFromJSON,
    CustomFilterToJSON,
    ExportLogFromJSON,
    ExportLogToJSON,
    ExportRequestFromJSON,
    ExportRequestToJSON,
    FdcQueryFromJSON,
    FdcQueryToJSON,
    FoodFromJSON,
    FoodToJSON,
    FoodBatchUpdateFromJSON,
    FoodBatchUpdateToJSON,
    FoodInheritFieldFromJSON,
    FoodInheritFieldToJSON,
    FoodShoppingUpdateFromJSON,
    FoodShoppingUpdateToJSON,
    GroupFromJSON,
    GroupToJSON,
    HouseholdFromJSON,
    HouseholdToJSON,
    ImportLogFromJSON,
    ImportLogToJSON,
    ImportOpenDataFromJSON,
    ImportOpenDataToJSON,
    ImportOpenDataMetaDataFromJSON,
    ImportOpenDataMetaDataToJSON,
    ImportOpenDataResponseFromJSON,
    ImportOpenDataResponseToJSON,
    IngredientFromJSON,
    IngredientToJSON,
    IngredientParserRequestFromJSON,
    IngredientParserRequestToJSON,
    IngredientParserResponseFromJSON,
    IngredientParserResponseToJSON,
    InventoryEntryFromJSON,
    InventoryEntryToJSON,
    InventoryLocationFromJSON,
    InventoryLocationToJSON,
    InventoryLogFromJSON,
    InventoryLogToJSON,
    InviteLinkFromJSON,
    InviteLinkToJSON,
    KeywordFromJSON,
    KeywordToJSON,
    LocalizationFromJSON,
    LocalizationToJSON,
    MealPlanFromJSON,
    MealPlanToJSON,
    MealTypeFromJSON,
    MealTypeToJSON,
    PaginatedAiLogListFromJSON,
    PaginatedAiLogListToJSON,
    PaginatedAiProviderListFromJSON,
    PaginatedAiProviderListToJSON,
    PaginatedAutomationListFromJSON,
    PaginatedAutomationListToJSON,
    PaginatedBookmarkletImportListListFromJSON,
    PaginatedBookmarkletImportListListToJSON,
    PaginatedConnectorConfigListFromJSON,
    PaginatedConnectorConfigListToJSON,
    PaginatedCookLogListFromJSON,
    PaginatedCookLogListToJSON,
    PaginatedCustomFilterListFromJSON,
    PaginatedCustomFilterListToJSON,
    PaginatedExportLogListFromJSON,
    PaginatedExportLogListToJSON,
    PaginatedFoodListFromJSON,
    PaginatedFoodListToJSON,
    PaginatedGenericModelReferenceListFromJSON,
    PaginatedGenericModelReferenceListToJSON,
    PaginatedHouseholdListFromJSON,
    PaginatedHouseholdListToJSON,
    PaginatedImportLogListFromJSON,
    PaginatedImportLogListToJSON,
    PaginatedIngredientListFromJSON,
    PaginatedIngredientListToJSON,
    PaginatedInventoryEntryListFromJSON,
    PaginatedInventoryEntryListToJSON,
    PaginatedInventoryLocationListFromJSON,
    PaginatedInventoryLocationListToJSON,
    PaginatedInventoryLogListFromJSON,
    PaginatedInventoryLogListToJSON,
    PaginatedInviteLinkListFromJSON,
    PaginatedInviteLinkListToJSON,
    PaginatedKeywordListFromJSON,
    PaginatedKeywordListToJSON,
    PaginatedMealPlanListFromJSON,
    PaginatedMealPlanListToJSON,
    PaginatedMealTypeListFromJSON,
    PaginatedMealTypeListToJSON,
    PaginatedPropertyListFromJSON,
    PaginatedPropertyListToJSON,
    PaginatedPropertyTypeListFromJSON,
    PaginatedPropertyTypeListToJSON,
    PaginatedRecipeBookEntryListFromJSON,
    PaginatedRecipeBookEntryListToJSON,
    PaginatedRecipeBookListFromJSON,
    PaginatedRecipeBookListToJSON,
    PaginatedRecipeImportListFromJSON,
    PaginatedRecipeImportListToJSON,
    PaginatedRecipeOverviewListFromJSON,
    PaginatedRecipeOverviewListToJSON,
    PaginatedShoppingListEntryListFromJSON,
    PaginatedShoppingListEntryListToJSON,
    PaginatedShoppingListListFromJSON,
    PaginatedShoppingListListToJSON,
    PaginatedShoppingListRecipeListFromJSON,
    PaginatedShoppingListRecipeListToJSON,
    PaginatedSpaceListFromJSON,
    PaginatedSpaceListToJSON,
    PaginatedStepListFromJSON,
    PaginatedStepListToJSON,
    PaginatedStorageListFromJSON,
    PaginatedStorageListToJSON,
    PaginatedSupermarketCategoryListFromJSON,
    PaginatedSupermarketCategoryListToJSON,
    PaginatedSupermarketCategoryRelationListFromJSON,
    PaginatedSupermarketCategoryRelationListToJSON,
    PaginatedSupermarketListFromJSON,
    PaginatedSupermarketListToJSON,
    PaginatedSyncListFromJSON,
    PaginatedSyncListToJSON,
    PaginatedSyncLogListFromJSON,
    PaginatedSyncLogListToJSON,
    PaginatedUnitConversionListFromJSON,
    PaginatedUnitConversionListToJSON,
    PaginatedUnitListFromJSON,
    PaginatedUnitListToJSON,
    PaginatedUserFileListFromJSON,
    PaginatedUserFileListToJSON,
    PaginatedUserSpaceListFromJSON,
    PaginatedUserSpaceListToJSON,
    PaginatedViewLogListFromJSON,
    PaginatedViewLogListToJSON,
    PatchedAccessTokenFromJSON,
    PatchedAccessTokenToJSON,
    PatchedAiProviderFromJSON,
    PatchedAiProviderToJSON,
    PatchedAutomationFromJSON,
    PatchedAutomationToJSON,
    PatchedBookmarkletImportFromJSON,
    PatchedBookmarkletImportToJSON,
    PatchedConnectorConfigFromJSON,
    PatchedConnectorConfigToJSON,
    PatchedCookLogFromJSON,
    PatchedCookLogToJSON,
    PatchedCustomFilterFromJSON,
    PatchedCustomFilterToJSON,
    PatchedExportLogFromJSON,
    PatchedExportLogToJSON,
    PatchedFoodFromJSON,
    PatchedFoodToJSON,
    PatchedHouseholdFromJSON,
    PatchedHouseholdToJSON,
    PatchedImportLogFromJSON,
    PatchedImportLogToJSON,
    PatchedIngredientFromJSON,
    PatchedIngredientToJSON,
    PatchedInventoryEntryFromJSON,
    PatchedInventoryEntryToJSON,
    PatchedInventoryLocationFromJSON,
    PatchedInventoryLocationToJSON,
    PatchedInviteLinkFromJSON,
    PatchedInviteLinkToJSON,
    PatchedKeywordFromJSON,
    PatchedKeywordToJSON,
    PatchedMealPlanFromJSON,
    PatchedMealPlanToJSON,
    PatchedMealTypeFromJSON,
    PatchedMealTypeToJSON,
    PatchedPropertyFromJSON,
    PatchedPropertyToJSON,
    PatchedPropertyTypeFromJSON,
    PatchedPropertyTypeToJSON,
    PatchedRecipeFromJSON,
    PatchedRecipeToJSON,
    PatchedRecipeBookFromJSON,
    PatchedRecipeBookToJSON,
    PatchedRecipeBookEntryFromJSON,
    PatchedRecipeBookEntryToJSON,
    PatchedRecipeImportFromJSON,
    PatchedRecipeImportToJSON,
    PatchedSearchPreferenceFromJSON,
    PatchedSearchPreferenceToJSON,
    PatchedShoppingListFromJSON,
    PatchedShoppingListToJSON,
    PatchedShoppingListEntryFromJSON,
    PatchedShoppingListEntryToJSON,
    PatchedShoppingListRecipeFromJSON,
    PatchedShoppingListRecipeToJSON,
    PatchedSpaceFromJSON,
    PatchedSpaceToJSON,
    PatchedStepFromJSON,
    PatchedStepToJSON,
    PatchedStorageFromJSON,
    PatchedStorageToJSON,
    PatchedSupermarketFromJSON,
    PatchedSupermarketToJSON,
    PatchedSupermarketCategoryFromJSON,
    PatchedSupermarketCategoryToJSON,
    PatchedSupermarketCategoryRelationFromJSON,
    PatchedSupermarketCategoryRelationToJSON,
    PatchedSyncFromJSON,
    PatchedSyncToJSON,
    PatchedUnitFromJSON,
    PatchedUnitToJSON,
    PatchedUnitConversionFromJSON,
    PatchedUnitConversionToJSON,
    PatchedUserFromJSON,
    PatchedUserToJSON,
    PatchedUserPreferenceFromJSON,
    PatchedUserPreferenceToJSON,
    PatchedUserSpaceFromJSON,
    PatchedUserSpaceToJSON,
    PatchedViewLogFromJSON,
    PatchedViewLogToJSON,
    PropertyFromJSON,
    PropertyToJSON,
    PropertyTypeFromJSON,
    PropertyTypeToJSON,
    RecipeFromJSON,
    RecipeToJSON,
    RecipeBatchUpdateFromJSON,
    RecipeBatchUpdateToJSON,
    RecipeBookFromJSON,
    RecipeBookToJSON,
    RecipeBookEntryFromJSON,
    RecipeBookEntryToJSON,
    RecipeFlatFromJSON,
    RecipeFlatToJSON,
    RecipeFromSourceFromJSON,
    RecipeFromSourceToJSON,
    RecipeFromSourceResponseFromJSON,
    RecipeFromSourceResponseToJSON,
    RecipeImageFromJSON,
    RecipeImageToJSON,
    RecipeImportFromJSON,
    RecipeImportToJSON,
    RecipeShoppingUpdateFromJSON,
    RecipeShoppingUpdateToJSON,
    RecipeSimpleFromJSON,
    RecipeSimpleToJSON,
    SearchFieldsFromJSON,
    SearchFieldsToJSON,
    SearchPreferenceFromJSON,
    SearchPreferenceToJSON,
    ServerSettingsFromJSON,
    ServerSettingsToJSON,
    ShareLinkFromJSON,
    ShareLinkToJSON,
    ShoppingListFromJSON,
    ShoppingListToJSON,
    ShoppingListEntryFromJSON,
    ShoppingListEntryToJSON,
    ShoppingListEntryBulkFromJSON,
    ShoppingListEntryBulkToJSON,
    ShoppingListEntryBulkCreateFromJSON,
    ShoppingListEntryBulkCreateToJSON,
    ShoppingListRecipeFromJSON,
    ShoppingListRecipeToJSON,
    SpaceFromJSON,
    SpaceToJSON,
    StepFromJSON,
    StepToJSON,
    StorageFromJSON,
    StorageToJSON,
    SupermarketFromJSON,
    SupermarketToJSON,
    SupermarketCategoryFromJSON,
    SupermarketCategoryToJSON,
    SupermarketCategoryRelationFromJSON,
    SupermarketCategoryRelationToJSON,
    SyncFromJSON,
    SyncToJSON,
    SyncLogFromJSON,
    SyncLogToJSON,
    UnitFromJSON,
    UnitToJSON,
    UnitConversionFromJSON,
    UnitConversionToJSON,
    UserFromJSON,
    UserToJSON,
    UserFileFromJSON,
    UserFileToJSON,
    UserPreferenceFromJSON,
    UserPreferenceToJSON,
    UserSpaceFromJSON,
    UserSpaceToJSON,
    ViewLogFromJSON,
    ViewLogToJSON,
} from '../models/index';

export interface ApiAccessTokenCreateRequest {
    accessToken: Omit<AccessToken, 'token'|'created'|'updated'>;
}

export interface ApiAccessTokenDestroyRequest {
    id: number;
}

export interface ApiAccessTokenPartialUpdateRequest {
    id: number;
    patchedAccessToken?: Omit<PatchedAccessToken, 'token'|'created'|'updated'>;
}

export interface ApiAccessTokenRetrieveRequest {
    id: number;
}

export interface ApiAccessTokenUpdateRequest {
    id: number;
    accessToken: Omit<AccessToken, 'token'|'created'|'updated'>;
}

export interface ApiAiImportCreateRequest {
    aiProviderId: number;
    file: string | null;
    text: string | null;
    recipeId: string | null;
}

export interface ApiAiLogListRequest {
    page?: number;
    pageSize?: number;
}

export interface ApiAiLogRetrieveRequest {
    id: number;
}

export interface ApiAiProviderCascadingListRequest {
    id: number;
    cache?: boolean;
    page?: number;
    pageSize?: number;
}

export interface ApiAiProviderCreateRequest {
    aiProvider: Omit<AiProvider, 'createdAt'|'updatedAt'>;
}

export interface ApiAiProviderDestroyRequest {
    id: number;
}

export interface ApiAiProviderListRequest {
    page?: number;
    pageSize?: number;
}

export interface ApiAiProviderNullingListRequest {
    id: number;
    cache?: boolean;
    page?: number;
    pageSize?: number;
}

export interface ApiAiProviderPartialUpdateRequest {
    id: number;
    patchedAiProvider?: Omit<PatchedAiProvider, 'createdAt'|'updatedAt'>;
}

export interface ApiAiProviderProtectingListRequest {
    id: number;
    cache?: boolean;
    page?: number;
    pageSize?: number;
}

export interface ApiAiProviderRetrieveRequest {
    id: number;
}

export interface ApiAiProviderUpdateRequest {
    id: number;
    aiProvider: Omit<AiProvider, 'createdAt'|'updatedAt'>;
}

export interface ApiAiStepSortCreateRequest {
    recipe: Omit<Recipe, 'image'|'createdBy'|'createdAt'|'updatedAt'|'foodProperties'|'rating'|'lastCooked'>;
    provider?: number;
}

export interface ApiAutoPlanCreateRequest {
    autoMealPlan: AutoMealPlan;
}

export interface ApiAutomationCreateRequest {
    automation: Omit<Automation, 'createdBy'>;
}

export interface ApiAutomationDestroyRequest {
    id: number;
}

export interface ApiAutomationListRequest {
    page?: number;
    pageSize?: number;
    type?: Array<ApiAutomationListTypeEnum>;
}

export interface ApiAutomationPartialUpdateRequest {
    id: number;
    patchedAutomation?: Omit<PatchedAutomation, 'createdBy'>;
}

export interface ApiAutomationRetrieveRequest {
    id: number;
}

export interface ApiAutomationUpdateRequest {
    id: number;
    automation: Omit<Automation, 'createdBy'>;
}

export interface ApiBookmarkletImportCreateRequest {
    bookmarkletImport: Omit<BookmarkletImport, 'createdBy'|'createdAt'>;
}

export interface ApiBookmarkletImportDestroyRequest {
    id: number;
}

export interface ApiBookmarkletImportListRequest {
    page?: number;
    pageSize?: number;
}

export interface ApiBookmarkletImportPartialUpdateRequest {
    id: number;
    patchedBookmarkletImport?: Omit<PatchedBookmarkletImport, 'createdBy'|'createdAt'>;
}

export interface ApiBookmarkletImportRetrieveRequest {
    id: number;
}

export interface ApiBookmarkletImportUpdateRequest {
    id: number;
    bookmarkletImport: Omit<BookmarkletImport, 'createdBy'|'createdAt'>;
}

export interface ApiConnectorConfigCascadingListRequest {
    id: number;
    cache?: boolean;
    page?: number;
    pageSize?: number;
}

export interface ApiConnectorConfigCreateRequest {
    connectorConfig: Omit<ConnectorConfig, 'createdBy'>;
}

export interface ApiConnectorConfigDestroyRequest {
    id: number;
}

export interface ApiConnectorConfigListRequest {
    page?: number;
    pageSize?: number;
}

export interface ApiConnectorConfigNullingListRequest {
    id: number;
    cache?: boolean;
    page?: number;
    pageSize?: number;
}

export interface ApiConnectorConfigPartialUpdateRequest {
    id: number;
    patchedConnectorConfig?: Omit<PatchedConnectorConfig, 'createdBy'>;
}

export interface ApiConnectorConfigProtectingListRequest {
    id: number;
    cache?: boolean;
    page?: number;
    pageSize?: number;
}

export interface ApiConnectorConfigRetrieveRequest {
    id: number;
}

export interface ApiConnectorConfigUpdateRequest {
    id: number;
    connectorConfig: Omit<ConnectorConfig, 'createdBy'>;
}

export interface ApiCookLogCreateRequest {
    cookLog: Omit<CookLog, 'createdBy'|'updatedAt'>;
}

export interface ApiCookLogDestroyRequest {
    id: number;
}

export interface ApiCookLogListRequest {
    page?: number;
    pageSize?: number;
    recipe?: number;
}

export interface ApiCookLogPartialUpdateRequest {
    id: number;
    patchedCookLog?: Omit<PatchedCookLog, 'createdBy'|'updatedAt'>;
}

export interface ApiCookLogRetrieveRequest {
    id: number;
}

export interface ApiCookLogUpdateRequest {
    id: number;
    cookLog: Omit<CookLog, 'createdBy'|'updatedAt'>;
}

export interface ApiCustomFilterCreateRequest {
    customFilter: Omit<CustomFilter, 'createdBy'>;
}

export interface ApiCustomFilterDestroyRequest {
    id: number;
}

export interface ApiCustomFilterListRequest {
    limit?: string;
    page?: number;
    pageSize?: number;
    query?: string;
    random?: string;
    type?: Array<ApiCustomFilterListTypeEnum>;
    updatedAt?: string;
}

export interface ApiCustomFilterPartialUpdateRequest {
    id: number;
    patchedCustomFilter?: Omit<PatchedCustomFilter, 'createdBy'>;
}

export interface ApiCustomFilterRetrieveRequest {
    id: number;
}

export interface ApiCustomFilterUpdateRequest {
    id: number;
    customFilter: Omit<CustomFilter, 'createdBy'>;
}

export interface ApiDownloadFileRetrieveRequest {
    fileId: number;
}

export interface ApiExportCreateRequest {
    exportRequest: ExportRequest;
}

export interface ApiExportLogCreateRequest {
    exportLog: Omit<ExportLog, 'createdBy'|'createdAt'>;
}

export interface ApiExportLogDestroyRequest {
    id: number;
}

export interface ApiExportLogListRequest {
    page?: number;
    pageSize?: number;
}

export interface ApiExportLogPartialUpdateRequest {
    id: number;
    patchedExportLog?: Omit<PatchedExportLog, 'createdBy'|'createdAt'>;
}

export interface ApiExportLogRetrieveRequest {
    id: number;
}

export interface ApiExportLogUpdateRequest {
    id: number;
    exportLog: Omit<ExportLog, 'createdBy'|'createdAt'>;
}

export interface ApiFdcSearchRetrieveRequest {
    dataType?: Array<string>;
    query?: string;
}

export interface ApiFoodAipropertiesCreateRequest {
    id: number;
    food: Omit<Food, 'shopping'|'parent'|'numchild'|'fullName'|'substituteOnhand'>;
    provider?: number;
}

export interface ApiFoodBatchUpdateUpdateRequest {
    foodBatchUpdate: FoodBatchUpdate;
}

export interface ApiFoodCascadingListRequest {
    id: number;
    cache?: boolean;
    page?: number;
    pageSize?: number;
}

export interface ApiFoodCreateRequest {
    food: Omit<Food, 'shopping'|'parent'|'numchild'|'fullName'|'substituteOnhand'>;
}

export interface ApiFoodDestroyRequest {
    id: number;
}

export interface ApiFoodFdcCreateRequest {
    id: number;
    food: Omit<Food, 'shopping'|'parent'|'numchild'|'fullName'|'substituteOnhand'>;
}

export interface ApiFoodInheritFieldRetrieveRequest {
    id: number;
}

export interface ApiFoodListRequest {
    limit?: string;
    page?: number;
    pageSize?: number;
    query?: string;
    random?: string;
    root?: number;
    rootTree?: number;
    tree?: number;
    updatedAt?: string;
}

export interface ApiFoodMergeUpdateRequest {
    id: number;
    target: number;
    food: Omit<Food, 'shopping'|'parent'|'numchild'|'fullName'|'substituteOnhand'>;
}

export interface ApiFoodMoveUpdateRequest {
    id: number;
    parent: number;
    food: Omit<Food, 'shopping'|'parent'|'numchild'|'fullName'|'substituteOnhand'>;
}

export interface ApiFoodNullingListRequest {
    id: number;
    cache?: boolean;
    page?: number;
    pageSize?: number;
}

export interface ApiFoodPartialUpdateRequest {
    id: number;
    patchedFood?: Omit<PatchedFood, 'shopping'|'parent'|'numchild'|'fullName'|'substituteOnhand'>;
}

export interface ApiFoodProtectingListRequest {
    id: number;
    cache?: boolean;
    page?: number;
    pageSize?: number;
}

export interface ApiFoodRetrieveRequest {
    id: number;
}

export interface ApiFoodShoppingUpdateRequest {
    id: number;
    foodShoppingUpdate: FoodShoppingUpdate;
}

export interface ApiFoodUpdateRequest {
    id: number;
    food: Omit<Food, 'shopping'|'parent'|'numchild'|'fullName'|'substituteOnhand'>;
}

export interface ApiGetExternalFileLinkRetrieveRequest {
    id: number;
}

export interface ApiGetRecipeFileRetrieveRequest {
    id: number;
}

export interface ApiGroupRetrieveRequest {
    id: number;
}

export interface ApiHouseholdCreateRequest {
    household: Omit<Household, 'createdAt'|'updatedAt'>;
}

export interface ApiHouseholdDestroyRequest {
    id: number;
}

export interface ApiHouseholdListRequest {
    page?: number;
    pageSize?: number;
}

export interface ApiHouseholdPartialUpdateRequest {
    id: number;
    patchedHousehold?: Omit<PatchedHousehold, 'createdAt'|'updatedAt'>;
}

export interface ApiHouseholdRetrieveRequest {
    id: number;
}

export interface ApiHouseholdUpdateRequest {
    id: number;
    household: Omit<Household, 'createdAt'|'updatedAt'>;
}

export interface ApiImportCreateRequest {
    aiProviderId: number;
    file: string | null;
    text: string | null;
    recipeId: string | null;
}

export interface ApiImportLogCreateRequest {
    importLog: Omit<ImportLog, 'keyword'|'createdBy'|'createdAt'>;
}

export interface ApiImportLogDestroyRequest {
    id: number;
}

export interface ApiImportLogListRequest {
    page?: number;
    pageSize?: number;
}

export interface ApiImportLogPartialUpdateRequest {
    id: number;
    patchedImportLog?: Omit<PatchedImportLog, 'keyword'|'createdBy'|'createdAt'>;
}

export interface ApiImportLogRetrieveRequest {
    id: number;
}

export interface ApiImportLogUpdateRequest {
    id: number;
    importLog: Omit<ImportLog, 'keyword'|'createdBy'|'createdAt'>;
}

export interface ApiImportOpenDataCreateRequest {
    importOpenData: ImportOpenData;
}

export interface ApiIngredientCreateRequest {
    ingredient: Omit<Ingredient, 'conversions'|'usedInRecipes'|'checked'>;
}

export interface ApiIngredientDestroyRequest {
    id: number;
}

export interface ApiIngredientListRequest {
    food?: number;
    page?: number;
    pageSize?: number;
    unit?: number;
}

export interface ApiIngredientParserPostCreateRequest {
    ingredientParserRequest?: IngredientParserRequest;
}

export interface ApiIngredientPartialUpdateRequest {
    id: number;
    patchedIngredient?: Omit<PatchedIngredient, 'conversions'|'usedInRecipes'|'checked'>;
}

export interface ApiIngredientRetrieveRequest {
    id: number;
}

export interface ApiIngredientUpdateRequest {
    id: number;
    ingredient: Omit<Ingredient, 'conversions'|'usedInRecipes'|'checked'>;
}

export interface ApiInventoryEntryCascadingListRequest {
    id: number;
    cache?: boolean;
    page?: number;
    pageSize?: number;
}

export interface ApiInventoryEntryCreateRequest {
    inventoryEntry: Omit<InventoryEntry, 'label'|'createdAt'|'createdBy'>;
}

export interface ApiInventoryEntryDestroyRequest {
    id: number;
}

export interface ApiInventoryEntryListRequest {
    code?: string;
    empty?: boolean;
    foodId?: number;
    inventoryLocationId?: number;
    page?: number;
    pageSize?: number;
}

export interface ApiInventoryEntryNullingListRequest {
    id: number;
    cache?: boolean;
    page?: number;
    pageSize?: number;
}

export interface ApiInventoryEntryPartialUpdateRequest {
    id: number;
    patchedInventoryEntry?: Omit<PatchedInventoryEntry, 'label'|'createdAt'|'createdBy'>;
}

export interface ApiInventoryEntryProtectingListRequest {
    id: number;
    cache?: boolean;
    page?: number;
    pageSize?: number;
}

export interface ApiInventoryEntryRetrieveRequest {
    id: number;
}

export interface ApiInventoryEntryUpdateRequest {
    id: number;
    inventoryEntry: Omit<InventoryEntry, 'label'|'createdAt'|'createdBy'>;
}

export interface ApiInventoryLocationCascadingListRequest {
    id: number;
    cache?: boolean;
    page?: number;
    pageSize?: number;
}

export interface ApiInventoryLocationCreateRequest {
    inventoryLocation: InventoryLocation;
}

export interface ApiInventoryLocationDestroyRequest {
    id: number;
}

export interface ApiInventoryLocationListRequest {
    page?: number;
    pageSize?: number;
}

export interface ApiInventoryLocationNullingListRequest {
    id: number;
    cache?: boolean;
    page?: number;
    pageSize?: number;
}

export interface ApiInventoryLocationPartialUpdateRequest {
    id: number;
    patchedInventoryLocation?: PatchedInventoryLocation;
}

export interface ApiInventoryLocationProtectingListRequest {
    id: number;
    cache?: boolean;
    page?: number;
    pageSize?: number;
}

export interface ApiInventoryLocationRetrieveRequest {
    id: number;
}

export interface ApiInventoryLocationUpdateRequest {
    id: number;
    inventoryLocation: InventoryLocation;
}

export interface ApiInventoryLogListRequest {
    entryId?: number;
    foodId?: number;
    page?: number;
    pageSize?: number;
}

export interface ApiInventoryLogRetrieveRequest {
    id: number;
}

export interface ApiInviteLinkCreateRequest {
    inviteLink: Omit<InviteLink, 'uuid'|'usedBy'|'createdBy'|'createdAt'|'emailSent'>;
}

export interface ApiInviteLinkDestroyRequest {
    id: number;
}

export interface ApiInviteLinkListRequest {
    internalNote?: string;
    limit?: string;
    page?: number;
    pageSize?: number;
    query?: string;
    random?: string;
    unused?: boolean;
    updatedAt?: string;
}

export interface ApiInviteLinkPartialUpdateRequest {
    id: number;
    patchedInviteLink?: Omit<PatchedInviteLink, 'uuid'|'usedBy'|'createdBy'|'createdAt'|'emailSent'>;
}

export interface ApiInviteLinkRetrieveRequest {
    id: number;
}

export interface ApiInviteLinkUpdateRequest {
    id: number;
    inviteLink: Omit<InviteLink, 'uuid'|'usedBy'|'createdBy'|'createdAt'|'emailSent'>;
}

export interface ApiKeywordCascadingListRequest {
    id: number;
    cache?: boolean;
    page?: number;
    pageSize?: number;
}

export interface ApiKeywordCreateRequest {
    keyword: Omit<Keyword, 'label'|'parent'|'numchild'|'createdAt'|'updatedAt'|'fullName'>;
}

export interface ApiKeywordDestroyRequest {
    id: number;
}

export interface ApiKeywordListRequest {
    limit?: string;
    page?: number;
    pageSize?: number;
    query?: string;
    random?: string;
    root?: number;
    rootTree?: number;
    tree?: number;
    updatedAt?: string;
}

export interface ApiKeywordMergeUpdateRequest {
    id: number;
    target: number;
    keyword: Omit<Keyword, 'label'|'parent'|'numchild'|'createdAt'|'updatedAt'|'fullName'>;
}

export interface ApiKeywordMoveUpdateRequest {
    id: number;
    parent: number;
    keyword: Omit<Keyword, 'label'|'parent'|'numchild'|'createdAt'|'updatedAt'|'fullName'>;
}

export interface ApiKeywordNullingListRequest {
    id: number;
    cache?: boolean;
    page?: number;
    pageSize?: number;
}

export interface ApiKeywordPartialUpdateRequest {
    id: number;
    patchedKeyword?: Omit<PatchedKeyword, 'label'|'parent'|'numchild'|'createdAt'|'updatedAt'|'fullName'>;
}

export interface ApiKeywordProtectingListRequest {
    id: number;
    cache?: boolean;
    page?: number;
    pageSize?: number;
}

export interface ApiKeywordRetrieveRequest {
    id: number;
}

export interface ApiKeywordUpdateRequest {
    id: number;
    keyword: Omit<Keyword, 'label'|'parent'|'numchild'|'createdAt'|'updatedAt'|'fullName'>;
}

export interface ApiMealPlanCreateRequest {
    mealPlan: Omit<MealPlan, 'noteMarkdown'|'createdBy'|'recipeName'|'mealTypeName'|'shopping'>;
}

export interface ApiMealPlanDestroyRequest {
    id: number;
}

export interface ApiMealPlanIcalRetrieveRequest {
    fromDate?: string;
    mealType?: Array<string>;
    toDate?: string;
}

export interface ApiMealPlanListRequest {
    fromDate?: string;
    mealType?: Array<string>;
    page?: number;
    pageSize?: number;
    toDate?: string;
}

export interface ApiMealPlanPartialUpdateRequest {
    id: number;
    patchedMealPlan?: Omit<PatchedMealPlan, 'noteMarkdown'|'createdBy'|'recipeName'|'mealTypeName'|'shopping'>;
}

export interface ApiMealPlanRetrieveRequest {
    id: number;
}

export interface ApiMealPlanUpdateRequest {
    id: number;
    mealPlan: Omit<MealPlan, 'noteMarkdown'|'createdBy'|'recipeName'|'mealTypeName'|'shopping'>;
}

export interface ApiMealTypeCascadingListRequest {
    id: number;
    cache?: boolean;
    page?: number;
    pageSize?: number;
}

export interface ApiMealTypeCreateRequest {
    mealType: Omit<MealType, 'createdBy'>;
}

export interface ApiMealTypeDestroyRequest {
    id: number;
}

export interface ApiMealTypeListRequest {
    page?: number;
    pageSize?: number;
}

export interface ApiMealTypeNullingListRequest {
    id: number;
    cache?: boolean;
    page?: number;
    pageSize?: number;
}

export interface ApiMealTypePartialUpdateRequest {
    id: number;
    patchedMealType?: Omit<PatchedMealType, 'createdBy'>;
}

export interface ApiMealTypeProtectingListRequest {
    id: number;
    cache?: boolean;
    page?: number;
    pageSize?: number;
}

export interface ApiMealTypeRetrieveRequest {
    id: number;
}

export interface ApiMealTypeUpdateRequest {
    id: number;
    mealType: Omit<MealType, 'createdBy'>;
}

export interface ApiPropertyCreateRequest {
    property: Property;
}

export interface ApiPropertyDestroyRequest {
    id: number;
}

export interface ApiPropertyListRequest {
    page?: number;
    pageSize?: number;
}

export interface ApiPropertyPartialUpdateRequest {
    id: number;
    patchedProperty?: PatchedProperty;
}

export interface ApiPropertyRetrieveRequest {
    id: number;
}

export interface ApiPropertyTypeCascadingListRequest {
    id: number;
    cache?: boolean;
    page?: number;
    pageSize?: number;
}

export interface ApiPropertyTypeCreateRequest {
    propertyType: PropertyType;
}

export interface ApiPropertyTypeDestroyRequest {
    id: number;
}

export interface ApiPropertyTypeListRequest {
    category?: Array<ApiPropertyTypeListCategoryEnum>;
    page?: number;
    pageSize?: number;
}

export interface ApiPropertyTypeNullingListRequest {
    id: number;
    cache?: boolean;
    page?: number;
    pageSize?: number;
}

export interface ApiPropertyTypePartialUpdateRequest {
    id: number;
    patchedPropertyType?: PatchedPropertyType;
}

export interface ApiPropertyTypeProtectingListRequest {
    id: number;
    cache?: boolean;
    page?: number;
    pageSize?: number;
}

export interface ApiPropertyTypeRetrieveRequest {
    id: number;
}

export interface ApiPropertyTypeUpdateRequest {
    id: number;
    propertyType: PropertyType;
}

export interface ApiPropertyUpdateRequest {
    id: number;
    property: Property;
}

export interface ApiRecipeAipropertiesCreateRequest {
    id: number;
    recipe: Omit<Recipe, 'image'|'createdBy'|'createdAt'|'updatedAt'|'foodProperties'|'rating'|'lastCooked'>;
    provider?: number;
}

export interface ApiRecipeBatchUpdateUpdateRequest {
    recipeBatchUpdate: RecipeBatchUpdate;
}

export interface ApiRecipeBookCascadingListRequest {
    id: number;
    cache?: boolean;
    page?: number;
    pageSize?: number;
}

export interface ApiRecipeBookCreateRequest {
    recipeBook: Omit<RecipeBook, 'createdBy'>;
}

export interface ApiRecipeBookDestroyRequest {
    id: number;
}

export interface ApiRecipeBookEntryCreateRequest {
    recipeBookEntry: Omit<RecipeBookEntry, 'bookContent'|'recipeContent'>;
}

export interface ApiRecipeBookEntryDestroyRequest {
    id: number;
}

export interface ApiRecipeBookEntryListRequest {
    book?: number;
    page?: number;
    pageSize?: number;
    recipe?: number;
}

export interface ApiRecipeBookEntryPartialUpdateRequest {
    id: number;
    patchedRecipeBookEntry?: Omit<PatchedRecipeBookEntry, 'bookContent'|'recipeContent'>;
}

export interface ApiRecipeBookEntryRetrieveRequest {
    id: number;
}

export interface ApiRecipeBookEntryUpdateRequest {
    id: number;
    recipeBookEntry: Omit<RecipeBookEntry, 'bookContent'|'recipeContent'>;
}

export interface ApiRecipeBookListRequest {
    limit?: string;
    orderDirection?: ApiRecipeBookListOrderDirectionEnum;
    orderField?: ApiRecipeBookListOrderFieldEnum;
    page?: number;
    pageSize?: number;
    query?: string;
    random?: string;
    updatedAt?: string;
}

export interface ApiRecipeBookNullingListRequest {
    id: number;
    cache?: boolean;
    page?: number;
    pageSize?: number;
}

export interface ApiRecipeBookPartialUpdateRequest {
    id: number;
    patchedRecipeBook?: Omit<PatchedRecipeBook, 'createdBy'>;
}

export interface ApiRecipeBookProtectingListRequest {
    id: number;
    cache?: boolean;
    page?: number;
    pageSize?: number;
}

export interface ApiRecipeBookRetrieveRequest {
    id: number;
}

export interface ApiRecipeBookUpdateRequest {
    id: number;
    recipeBook: Omit<RecipeBook, 'createdBy'>;
}

export interface ApiRecipeCascadingListRequest {
    id: number;
    cache?: boolean;
    page?: number;
    pageSize?: number;
}

export interface ApiRecipeCreateRequest {
    recipe: Omit<Recipe, 'image'|'createdBy'|'createdAt'|'updatedAt'|'foodProperties'|'rating'|'lastCooked'>;
}

export interface ApiRecipeDeleteExternalPartialUpdateRequest {
    id: number;
    patchedRecipe?: Omit<PatchedRecipe, 'image'|'createdBy'|'createdAt'|'updatedAt'|'foodProperties'|'rating'|'lastCooked'>;
}

export interface ApiRecipeDestroyRequest {
    id: number;
}

export interface ApiRecipeFromSourceCreateRequest {
    recipeFromSource?: RecipeFromSource;
}

export interface ApiRecipeImageUpdateRequest {
    id: number;
    image?: string;
    imageUrl?: string;
}

export interface ApiRecipeImportCreateRequest {
    recipeImport: Omit<RecipeImport, 'createdAt'>;
}

export interface ApiRecipeImportDestroyRequest {
    id: number;
}

export interface ApiRecipeImportImportAllCreateRequest {
    recipeImport: Omit<RecipeImport, 'createdAt'>;
}

export interface ApiRecipeImportImportRecipeCreateRequest {
    id: number;
    recipeImport: Omit<RecipeImport, 'createdAt'>;
}

export interface ApiRecipeImportListRequest {
    page?: number;
    pageSize?: number;
}

export interface ApiRecipeImportPartialUpdateRequest {
    id: number;
    patchedRecipeImport?: Omit<PatchedRecipeImport, 'createdAt'>;
}

export interface ApiRecipeImportRetrieveRequest {
    id: number;
}

export interface ApiRecipeImportUpdateRequest {
    id: number;
    recipeImport: Omit<RecipeImport, 'createdAt'>;
}

export interface ApiRecipeListRequest {
    books?: Array<number>;
    booksAnd?: Array<number>;
    booksAndNot?: Array<number>;
    booksOr?: Array<number>;
    booksOrNot?: Array<number>;
    cookedonGte?: Date;
    cookedonLte?: Date;
    createdby?: number;
    createdon?: Date;
    createdonGte?: Date;
    createdonLte?: Date;
    filter?: number;
    foods?: Array<number>;
    foodsAnd?: Array<number>;
    foodsAndNot?: Array<number>;
    foodsOr?: Array<number>;
    foodsOrNot?: Array<number>;
    includeChildren?: boolean;
    internal?: boolean;
    keywords?: Array<number>;
    keywordsAnd?: Array<number>;
    keywordsAndNot?: Array<number>;
    keywordsOr?: Array<number>;
    keywordsOrNot?: Array<number>;
    makenow?: boolean;
    _new?: boolean;
    numRecent?: number;
    page?: number;
    pageSize?: number;
    query?: string;
    random?: boolean;
    rating?: number;
    ratingGte?: number;
    ratingLte?: number;
    sortOrder?: string;
    timescooked?: number;
    timescookedGte?: number;
    timescookedLte?: number;
    units?: number;
    updatedon?: Date;
    updatedonGte?: Date;
    updatedonLte?: Date;
    viewedonGte?: Date;
    viewedonLte?: Date;
}

export interface ApiRecipeNullingListRequest {
    id: number;
    cache?: boolean;
    page?: number;
    pageSize?: number;
}

export interface ApiRecipePartialUpdateRequest {
    id: number;
    patchedRecipe?: Omit<PatchedRecipe, 'image'|'createdBy'|'createdAt'|'updatedAt'|'foodProperties'|'rating'|'lastCooked'>;
}

export interface ApiRecipeProtectingListRequest {
    id: number;
    cache?: boolean;
    page?: number;
    pageSize?: number;
}

export interface ApiRecipeRelatedListRequest {
    id: number;
}

export interface ApiRecipeRetrieveRequest {
    id: number;
    share?: string;
}

export interface ApiRecipeShoppingUpdateRequest {
    id: number;
    recipeShoppingUpdate: RecipeShoppingUpdate;
}

export interface ApiRecipeUpdateRequest {
    id: number;
    recipe: Omit<Recipe, 'image'|'createdBy'|'createdAt'|'updatedAt'|'foodProperties'|'rating'|'lastCooked'>;
}

export interface ApiSearchFieldsRetrieveRequest {
    id: number;
}

export interface ApiSearchPreferencePartialUpdateRequest {
    user: number;
    patchedSearchPreference?: Omit<PatchedSearchPreference, 'user'>;
}

export interface ApiSearchPreferenceRetrieveRequest {
    user: number;
}

export interface ApiShareLinkRetrieveRequest {
    id: number;
}

export interface ApiShoppingListCascadingListRequest {
    id: number;
    cache?: boolean;
    page?: number;
    pageSize?: number;
}

export interface ApiShoppingListCreateRequest {
    shoppingList?: ShoppingList;
}

export interface ApiShoppingListDestroyRequest {
    id: number;
}

export interface ApiShoppingListEntryBulkCreateRequest {
    shoppingListEntryBulk: Omit<ShoppingListEntryBulk, 'timestamp'>;
}

export interface ApiShoppingListEntryCreateRequest {
    shoppingListEntry: Omit<ShoppingListEntry, 'listRecipeData'|'createdBy'|'createdAt'|'updatedAt'>;
}

export interface ApiShoppingListEntryDestroyRequest {
    id: number;
}

export interface ApiShoppingListEntryListRequest {
    mealplan?: number;
    page?: number;
    pageSize?: number;
    updatedAfter?: Date;
}

export interface ApiShoppingListEntryPartialUpdateRequest {
    id: number;
    patchedShoppingListEntry?: Omit<PatchedShoppingListEntry, 'listRecipeData'|'createdBy'|'createdAt'|'updatedAt'>;
}

export interface ApiShoppingListEntryRetrieveRequest {
    id: number;
}

export interface ApiShoppingListEntryUpdateRequest {
    id: number;
    shoppingListEntry: Omit<ShoppingListEntry, 'listRecipeData'|'createdBy'|'createdAt'|'updatedAt'>;
}

export interface ApiShoppingListListRequest {
    page?: number;
    pageSize?: number;
}

export interface ApiShoppingListNullingListRequest {
    id: number;
    cache?: boolean;
    page?: number;
    pageSize?: number;
}

export interface ApiShoppingListPartialUpdateRequest {
    id: number;
    patchedShoppingList?: PatchedShoppingList;
}

export interface ApiShoppingListProtectingListRequest {
    id: number;
    cache?: boolean;
    page?: number;
    pageSize?: number;
}

export interface ApiShoppingListRecipeBulkCreateEntriesCreateRequest {
    id: number;
    shoppingListEntryBulkCreate: ShoppingListEntryBulkCreate;
}

export interface ApiShoppingListRecipeCreateRequest {
    shoppingListRecipe: Omit<ShoppingListRecipe, 'recipeData'|'mealPlanData'|'createdBy'>;
}

export interface ApiShoppingListRecipeDestroyRequest {
    id: number;
}

export interface ApiShoppingListRecipeListRequest {
    mealplan?: number;
    page?: number;
    pageSize?: number;
}

export interface ApiShoppingListRecipePartialUpdateRequest {
    id: number;
    patchedShoppingListRecipe?: Omit<PatchedShoppingListRecipe, 'recipeData'|'mealPlanData'|'createdBy'>;
}

export interface ApiShoppingListRecipeRetrieveRequest {
    id: number;
}

export interface ApiShoppingListRecipeUpdateRequest {
    id: number;
    shoppingListRecipe: Omit<ShoppingListRecipe, 'recipeData'|'mealPlanData'|'createdBy'>;
}

export interface ApiShoppingListRetrieveRequest {
    id: number;
}

export interface ApiShoppingListUpdateRequest {
    id: number;
    shoppingList?: ShoppingList;
}

export interface ApiSpaceCreateRequest {
    space?: Omit<Space, 'createdBy'|'createdAt'|'maxRecipes'|'maxFileStorageMb'|'maxUsers'|'allowSharing'|'demo'|'userCount'|'recipeCount'|'fileSizeMb'|'aiMonthlyCreditsUsed'>;
}

export interface ApiSpaceListRequest {
    page?: number;
    pageSize?: number;
}

export interface ApiSpacePartialUpdateRequest {
    id: number;
    patchedSpace?: Omit<PatchedSpace, 'createdBy'|'createdAt'|'maxRecipes'|'maxFileStorageMb'|'maxUsers'|'allowSharing'|'demo'|'userCount'|'recipeCount'|'fileSizeMb'|'aiMonthlyCreditsUsed'>;
}

export interface ApiSpaceRetrieveRequest {
    id: number;
}

export interface ApiSpaceUpdateRequest {
    id: number;
    space?: Omit<Space, 'createdBy'|'createdAt'|'maxRecipes'|'maxFileStorageMb'|'maxUsers'|'allowSharing'|'demo'|'userCount'|'recipeCount'|'fileSizeMb'|'aiMonthlyCreditsUsed'>;
}

export interface ApiStepCreateRequest {
    step: Omit<Step, 'instructionsMarkdown'|'stepRecipeData'|'numrecipe'>;
}

export interface ApiStepDestroyRequest {
    id: number;
}

export interface ApiStepListRequest {
    page?: number;
    pageSize?: number;
    query?: string;
    recipe?: Array<number>;
}

export interface ApiStepPartialUpdateRequest {
    id: number;
    patchedStep?: Omit<PatchedStep, 'instructionsMarkdown'|'stepRecipeData'|'numrecipe'>;
}

export interface ApiStepRetrieveRequest {
    id: number;
}

export interface ApiStepUpdateRequest {
    id: number;
    step: Omit<Step, 'instructionsMarkdown'|'stepRecipeData'|'numrecipe'>;
}

export interface ApiStorageCascadingListRequest {
    id: number;
    cache?: boolean;
    page?: number;
    pageSize?: number;
}

export interface ApiStorageCreateRequest {
    storage: Omit<Storage, 'createdBy'>;
}

export interface ApiStorageDestroyRequest {
    id: number;
}

export interface ApiStorageListRequest {
    page?: number;
    pageSize?: number;
}

export interface ApiStorageNullingListRequest {
    id: number;
    cache?: boolean;
    page?: number;
    pageSize?: number;
}

export interface ApiStoragePartialUpdateRequest {
    id: number;
    patchedStorage?: Omit<PatchedStorage, 'createdBy'>;
}

export interface ApiStorageProtectingListRequest {
    id: number;
    cache?: boolean;
    page?: number;
    pageSize?: number;
}

export interface ApiStorageRetrieveRequest {
    id: number;
}

export interface ApiStorageUpdateRequest {
    id: number;
    storage: Omit<Storage, 'createdBy'>;
}

export interface ApiSupermarketCascadingListRequest {
    id: number;
    cache?: boolean;
    page?: number;
    pageSize?: number;
}

export interface ApiSupermarketCategoryCascadingListRequest {
    id: number;
    cache?: boolean;
    page?: number;
    pageSize?: number;
}

export interface ApiSupermarketCategoryCreateRequest {
    supermarketCategory: SupermarketCategory;
}

export interface ApiSupermarketCategoryDestroyRequest {
    id: number;
}

export interface ApiSupermarketCategoryListRequest {
    limit?: string;
    page?: number;
    pageSize?: number;
    query?: string;
    random?: string;
    updatedAt?: string;
}

export interface ApiSupermarketCategoryMergeUpdateRequest {
    id: number;
    target: number;
    supermarketCategory: SupermarketCategory;
}

export interface ApiSupermarketCategoryNullingListRequest {
    id: number;
    cache?: boolean;
    page?: number;
    pageSize?: number;
}

export interface ApiSupermarketCategoryPartialUpdateRequest {
    id: number;
    patchedSupermarketCategory?: PatchedSupermarketCategory;
}

export interface ApiSupermarketCategoryProtectingListRequest {
    id: number;
    cache?: boolean;
    page?: number;
    pageSize?: number;
}

export interface ApiSupermarketCategoryRelationCreateRequest {
    supermarketCategoryRelation: SupermarketCategoryRelation;
}

export interface ApiSupermarketCategoryRelationDestroyRequest {
    id: number;
}

export interface ApiSupermarketCategoryRelationListRequest {
    limit?: string;
    page?: number;
    pageSize?: number;
    query?: string;
    random?: string;
    updatedAt?: string;
}

export interface ApiSupermarketCategoryRelationPartialUpdateRequest {
    id: number;
    patchedSupermarketCategoryRelation?: PatchedSupermarketCategoryRelation;
}

export interface ApiSupermarketCategoryRelationRetrieveRequest {
    id: number;
}

export interface ApiSupermarketCategoryRelationUpdateRequest {
    id: number;
    supermarketCategoryRelation: SupermarketCategoryRelation;
}

export interface ApiSupermarketCategoryRetrieveRequest {
    id: number;
}

export interface ApiSupermarketCategoryUpdateRequest {
    id: number;
    supermarketCategory: SupermarketCategory;
}

export interface ApiSupermarketCreateRequest {
    supermarket: Omit<Supermarket, 'categoryToSupermarket'>;
}

export interface ApiSupermarketDestroyRequest {
    id: number;
}

export interface ApiSupermarketListRequest {
    limit?: string;
    page?: number;
    pageSize?: number;
    query?: string;
    random?: string;
    updatedAt?: string;
}

export interface ApiSupermarketNullingListRequest {
    id: number;
    cache?: boolean;
    page?: number;
    pageSize?: number;
}

export interface ApiSupermarketPartialUpdateRequest {
    id: number;
    patchedSupermarket?: Omit<PatchedSupermarket, 'categoryToSupermarket'>;
}

export interface ApiSupermarketProtectingListRequest {
    id: number;
    cache?: boolean;
    page?: number;
    pageSize?: number;
}

export interface ApiSupermarketRetrieveRequest {
    id: number;
}

export interface ApiSupermarketUpdateRequest {
    id: number;
    supermarket: Omit<Supermarket, 'categoryToSupermarket'>;
}

export interface ApiSwitchActiveSpaceRetrieveRequest {
    spaceId: number;
}

export interface ApiSyncCascadingListRequest {
    id: number;
    cache?: boolean;
    page?: number;
    pageSize?: number;
}

export interface ApiSyncCreateRequest {
    sync: Omit<Sync, 'createdAt'|'updatedAt'>;
}

export interface ApiSyncDestroyRequest {
    id: number;
}

export interface ApiSyncListRequest {
    page?: number;
    pageSize?: number;
}

export interface ApiSyncLogListRequest {
    page?: number;
    pageSize?: number;
}

export interface ApiSyncLogRetrieveRequest {
    id: number;
}

export interface ApiSyncNullingListRequest {
    id: number;
    cache?: boolean;
    page?: number;
    pageSize?: number;
}

export interface ApiSyncPartialUpdateRequest {
    id: number;
    patchedSync?: Omit<PatchedSync, 'createdAt'|'updatedAt'>;
}

export interface ApiSyncProtectingListRequest {
    id: number;
    cache?: boolean;
    page?: number;
    pageSize?: number;
}

export interface ApiSyncQuerySyncedFolderCreateRequest {
    id: number;
    sync: Omit<Sync, 'createdAt'|'updatedAt'>;
}

export interface ApiSyncRetrieveRequest {
    id: number;
}

export interface ApiSyncUpdateRequest {
    id: number;
    sync: Omit<Sync, 'createdAt'|'updatedAt'>;
}

export interface ApiUnitCascadingListRequest {
    id: number;
    cache?: boolean;
    page?: number;
    pageSize?: number;
}

export interface ApiUnitConversionCreateRequest {
    unitConversion: Omit<UnitConversion, 'name'>;
}

export interface ApiUnitConversionDestroyRequest {
    id: number;
}

export interface ApiUnitConversionListRequest {
    foodId?: number;
    page?: number;
    pageSize?: number;
    query?: string;
}

export interface ApiUnitConversionPartialUpdateRequest {
    id: number;
    patchedUnitConversion?: Omit<PatchedUnitConversion, 'name'>;
}

export interface ApiUnitConversionRetrieveRequest {
    id: number;
}

export interface ApiUnitConversionUpdateRequest {
    id: number;
    unitConversion: Omit<UnitConversion, 'name'>;
}

export interface ApiUnitCreateRequest {
    unit: Unit;
}

export interface ApiUnitDestroyRequest {
    id: number;
}

export interface ApiUnitListRequest {
    limit?: string;
    page?: number;
    pageSize?: number;
    query?: string;
    random?: string;
    updatedAt?: string;
}

export interface ApiUnitMergeUpdateRequest {
    id: number;
    target: number;
    unit: Unit;
}

export interface ApiUnitNullingListRequest {
    id: number;
    cache?: boolean;
    page?: number;
    pageSize?: number;
}

export interface ApiUnitPartialUpdateRequest {
    id: number;
    patchedUnit?: PatchedUnit;
}

export interface ApiUnitProtectingListRequest {
    id: number;
    cache?: boolean;
    page?: number;
    pageSize?: number;
}

export interface ApiUnitRetrieveRequest {
    id: number;
}

export interface ApiUnitUpdateRequest {
    id: number;
    unit: Unit;
}

export interface ApiUserFileCascadingListRequest {
    id: number;
    cache?: boolean;
    page?: number;
    pageSize?: number;
}

export interface ApiUserFileCreateRequest {
    name: string;
    fileDownload: string;
    preview: string;
    fileSizeKb: number;
    createdBy: User;
    createdAt: Date;
    id?: number;
    file?: string;
}

export interface ApiUserFileDestroyRequest {
    id: number;
}

export interface ApiUserFileListRequest {
    limit?: string;
    page?: number;
    pageSize?: number;
    query?: string;
    random?: string;
    updatedAt?: string;
}

export interface ApiUserFileNullingListRequest {
    id: number;
    cache?: boolean;
    page?: number;
    pageSize?: number;
}

export interface ApiUserFilePartialUpdateRequest {
    id: number;
    id2?: number;
    name?: string;
    file?: string;
    fileDownload?: string;
    preview?: string;
    fileSizeKb?: number;
    createdBy?: User;
    createdAt?: Date;
}

export interface ApiUserFileProtectingListRequest {
    id: number;
    cache?: boolean;
    page?: number;
    pageSize?: number;
}

export interface ApiUserFileRetrieveRequest {
    id: number;
}

export interface ApiUserFileUpdateRequest {
    id: number;
    name: string;
    fileDownload: string;
    preview: string;
    fileSizeKb: number;
    createdBy: User;
    createdAt: Date;
    id2?: number;
    file?: string;
}

export interface ApiUserListRequest {
    filterList?: Array<string>;
}

export interface ApiUserPartialUpdateRequest {
    id: number;
    patchedUser?: Omit<PatchedUser, 'username'|'displayName'|'isStaff'|'isSuperuser'|'isActive'>;
}

export interface ApiUserPreferencePartialUpdateRequest {
    user: number;
    patchedUserPreference?: Omit<PatchedUserPreference, 'user'|'foodInheritDefault'|'foodChildrenExist'>;
}

export interface ApiUserPreferenceRetrieveRequest {
    user: number;
}

export interface ApiUserRetrieveRequest {
    id: number;
}

export interface ApiUserSpaceDestroyRequest {
    id: number;
}

export interface ApiUserSpaceListRequest {
    internalNote?: string;
    page?: number;
    pageSize?: number;
}

export interface ApiUserSpacePartialUpdateRequest {
    id: number;
    patchedUserSpace?: Omit<PatchedUserSpace, 'user'|'space'|'inviteLink'|'createdAt'|'updatedAt'>;
}

export interface ApiUserSpaceRetrieveRequest {
    id: number;
}

export interface ApiUserSpaceUpdateRequest {
    id: number;
    userSpace: Omit<UserSpace, 'user'|'space'|'inviteLink'|'createdAt'|'updatedAt'>;
}

export interface ApiViewLogCreateRequest {
    viewLog: Omit<ViewLog, 'createdBy'|'createdAt'>;
}

export interface ApiViewLogDestroyRequest {
    id: number;
}

export interface ApiViewLogListRequest {
    page?: number;
    pageSize?: number;
}

export interface ApiViewLogPartialUpdateRequest {
    id: number;
    patchedViewLog?: Omit<PatchedViewLog, 'createdBy'|'createdAt'>;
}

export interface ApiViewLogRetrieveRequest {
    id: number;
}

export interface ApiViewLogUpdateRequest {
    id: number;
    viewLog: Omit<ViewLog, 'createdBy'|'createdAt'>;
}

/**
 * 
 */
export class ApiApi extends runtime.BaseAPI {

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiAccessTokenCreateRaw(requestParameters: ApiAccessTokenCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AccessToken>> {
        if (requestParameters['accessToken'] == null) {
            throw new runtime.RequiredError(
                'accessToken',
                'Required parameter "accessToken" was null or undefined when calling apiAccessTokenCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/access-token/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AccessTokenToJSON(requestParameters['accessToken']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AccessTokenFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiAccessTokenCreate(requestParameters: ApiAccessTokenCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AccessToken> {
        const response = await this.apiAccessTokenCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiAccessTokenDestroyRaw(requestParameters: ApiAccessTokenDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiAccessTokenDestroy().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/access-token/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiAccessTokenDestroy(requestParameters: ApiAccessTokenDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiAccessTokenDestroyRaw(requestParameters, initOverrides);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiAccessTokenListRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<AccessToken>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/access-token/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(AccessTokenFromJSON));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiAccessTokenList(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<AccessToken>> {
        const response = await this.apiAccessTokenListRaw(initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiAccessTokenPartialUpdateRaw(requestParameters: ApiAccessTokenPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AccessToken>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiAccessTokenPartialUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/access-token/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedAccessTokenToJSON(requestParameters['patchedAccessToken']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AccessTokenFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiAccessTokenPartialUpdate(requestParameters: ApiAccessTokenPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AccessToken> {
        const response = await this.apiAccessTokenPartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiAccessTokenRetrieveRaw(requestParameters: ApiAccessTokenRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AccessToken>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiAccessTokenRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/access-token/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AccessTokenFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiAccessTokenRetrieve(requestParameters: ApiAccessTokenRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AccessToken> {
        const response = await this.apiAccessTokenRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiAccessTokenUpdateRaw(requestParameters: ApiAccessTokenUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AccessToken>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiAccessTokenUpdate().'
            );
        }

        if (requestParameters['accessToken'] == null) {
            throw new runtime.RequiredError(
                'accessToken',
                'Required parameter "accessToken" was null or undefined when calling apiAccessTokenUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/access-token/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: AccessTokenToJSON(requestParameters['accessToken']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AccessTokenFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiAccessTokenUpdate(requestParameters: ApiAccessTokenUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AccessToken> {
        const response = await this.apiAccessTokenUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * given an image or PDF file convert its content to a structured recipe using AI and the scraping system
     */
    async apiAiImportCreateRaw(requestParameters: ApiAiImportCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RecipeFromSourceResponse>> {
        if (requestParameters['aiProviderId'] == null) {
            throw new runtime.RequiredError(
                'aiProviderId',
                'Required parameter "aiProviderId" was null or undefined when calling apiAiImportCreate().'
            );
        }

        if (requestParameters['file'] == null) {
            throw new runtime.RequiredError(
                'file',
                'Required parameter "file" was null or undefined when calling apiAiImportCreate().'
            );
        }

        if (requestParameters['text'] == null) {
            throw new runtime.RequiredError(
                'text',
                'Required parameter "text" was null or undefined when calling apiAiImportCreate().'
            );
        }

        if (requestParameters['recipeId'] == null) {
            throw new runtime.RequiredError(
                'recipeId',
                'Required parameter "recipeId" was null or undefined when calling apiAiImportCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['aiProviderId'] != null) {
            formParams.append('ai_provider_id', requestParameters['aiProviderId'] as any);
        }

        if (requestParameters['file'] != null) {
            formParams.append('file', requestParameters['file'] as any);
        }

        if (requestParameters['text'] != null) {
            formParams.append('text', requestParameters['text'] as any);
        }

        if (requestParameters['recipeId'] != null) {
            formParams.append('recipe_id', requestParameters['recipeId'] as any);
        }

        const response = await this.request({
            path: `/api/ai-import/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RecipeFromSourceResponseFromJSON(jsonValue));
    }

    /**
     * given an image or PDF file convert its content to a structured recipe using AI and the scraping system
     */
    async apiAiImportCreate(requestParameters: ApiAiImportCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RecipeFromSourceResponse> {
        const response = await this.apiAiImportCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiAiLogListRaw(requestParameters: ApiAiLogListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedAiLogList>> {
        const queryParameters: any = {};

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/ai-log/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedAiLogListFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiAiLogList(requestParameters: ApiAiLogListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedAiLogList> {
        const response = await this.apiAiLogListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiAiLogRetrieveRaw(requestParameters: ApiAiLogRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AiLog>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiAiLogRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/ai-log/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AiLogFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiAiLogRetrieve(requestParameters: ApiAiLogRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AiLog> {
        const response = await this.apiAiLogRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get a paginated list of objects that will be cascaded (deleted) when deleting the selected object
     */
    async apiAiProviderCascadingListRaw(requestParameters: ApiAiProviderCascadingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedGenericModelReferenceList>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiAiProviderCascadingList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['cache'] != null) {
            queryParameters['cache'] = requestParameters['cache'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/ai-provider/{id}/cascading/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedGenericModelReferenceListFromJSON(jsonValue));
    }

    /**
     * get a paginated list of objects that will be cascaded (deleted) when deleting the selected object
     */
    async apiAiProviderCascadingList(requestParameters: ApiAiProviderCascadingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedGenericModelReferenceList> {
        const response = await this.apiAiProviderCascadingListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiAiProviderCreateRaw(requestParameters: ApiAiProviderCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AiProvider>> {
        if (requestParameters['aiProvider'] == null) {
            throw new runtime.RequiredError(
                'aiProvider',
                'Required parameter "aiProvider" was null or undefined when calling apiAiProviderCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/ai-provider/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AiProviderToJSON(requestParameters['aiProvider']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AiProviderFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiAiProviderCreate(requestParameters: ApiAiProviderCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AiProvider> {
        const response = await this.apiAiProviderCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiAiProviderDestroyRaw(requestParameters: ApiAiProviderDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiAiProviderDestroy().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/ai-provider/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiAiProviderDestroy(requestParameters: ApiAiProviderDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiAiProviderDestroyRaw(requestParameters, initOverrides);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiAiProviderListRaw(requestParameters: ApiAiProviderListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedAiProviderList>> {
        const queryParameters: any = {};

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/ai-provider/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedAiProviderListFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiAiProviderList(requestParameters: ApiAiProviderListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedAiProviderList> {
        const response = await this.apiAiProviderListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get a paginated list of objects where the selected object will be removed whe its deleted
     */
    async apiAiProviderNullingListRaw(requestParameters: ApiAiProviderNullingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedGenericModelReferenceList>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiAiProviderNullingList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['cache'] != null) {
            queryParameters['cache'] = requestParameters['cache'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/ai-provider/{id}/nulling/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedGenericModelReferenceListFromJSON(jsonValue));
    }

    /**
     * get a paginated list of objects where the selected object will be removed whe its deleted
     */
    async apiAiProviderNullingList(requestParameters: ApiAiProviderNullingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedGenericModelReferenceList> {
        const response = await this.apiAiProviderNullingListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiAiProviderPartialUpdateRaw(requestParameters: ApiAiProviderPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AiProvider>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiAiProviderPartialUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/ai-provider/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedAiProviderToJSON(requestParameters['patchedAiProvider']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AiProviderFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiAiProviderPartialUpdate(requestParameters: ApiAiProviderPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AiProvider> {
        const response = await this.apiAiProviderPartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get a paginated list of objects that are protecting the selected object form being deleted
     */
    async apiAiProviderProtectingListRaw(requestParameters: ApiAiProviderProtectingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedGenericModelReferenceList>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiAiProviderProtectingList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['cache'] != null) {
            queryParameters['cache'] = requestParameters['cache'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/ai-provider/{id}/protecting/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedGenericModelReferenceListFromJSON(jsonValue));
    }

    /**
     * get a paginated list of objects that are protecting the selected object form being deleted
     */
    async apiAiProviderProtectingList(requestParameters: ApiAiProviderProtectingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedGenericModelReferenceList> {
        const response = await this.apiAiProviderProtectingListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiAiProviderRetrieveRaw(requestParameters: ApiAiProviderRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AiProvider>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiAiProviderRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/ai-provider/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AiProviderFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiAiProviderRetrieve(requestParameters: ApiAiProviderRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AiProvider> {
        const response = await this.apiAiProviderRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiAiProviderUpdateRaw(requestParameters: ApiAiProviderUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AiProvider>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiAiProviderUpdate().'
            );
        }

        if (requestParameters['aiProvider'] == null) {
            throw new runtime.RequiredError(
                'aiProvider',
                'Required parameter "aiProvider" was null or undefined when calling apiAiProviderUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/ai-provider/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: AiProviderToJSON(requestParameters['aiProvider']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AiProviderFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiAiProviderUpdate(requestParameters: ApiAiProviderUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AiProvider> {
        const response = await this.apiAiProviderUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * given an image or PDF file convert its content to a structured recipe using AI and the scraping system
     */
    async apiAiStepSortCreateRaw(requestParameters: ApiAiStepSortCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Recipe>> {
        if (requestParameters['recipe'] == null) {
            throw new runtime.RequiredError(
                'recipe',
                'Required parameter "recipe" was null or undefined when calling apiAiStepSortCreate().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['provider'] != null) {
            queryParameters['provider'] = requestParameters['provider'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/ai-step-sort/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RecipeToJSON(requestParameters['recipe']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RecipeFromJSON(jsonValue));
    }

    /**
     * given an image or PDF file convert its content to a structured recipe using AI and the scraping system
     */
    async apiAiStepSortCreate(requestParameters: ApiAiStepSortCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Recipe> {
        const response = await this.apiAiStepSortCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiAutoPlanCreateRaw(requestParameters: ApiAutoPlanCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AutoMealPlan>> {
        if (requestParameters['autoMealPlan'] == null) {
            throw new runtime.RequiredError(
                'autoMealPlan',
                'Required parameter "autoMealPlan" was null or undefined when calling apiAutoPlanCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/auto-plan/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AutoMealPlanToJSON(requestParameters['autoMealPlan']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AutoMealPlanFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiAutoPlanCreate(requestParameters: ApiAutoPlanCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AutoMealPlan> {
        const response = await this.apiAutoPlanCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiAutomationCreateRaw(requestParameters: ApiAutomationCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Automation>> {
        if (requestParameters['automation'] == null) {
            throw new runtime.RequiredError(
                'automation',
                'Required parameter "automation" was null or undefined when calling apiAutomationCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/automation/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AutomationToJSON(requestParameters['automation']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AutomationFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiAutomationCreate(requestParameters: ApiAutomationCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Automation> {
        const response = await this.apiAutomationCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiAutomationDestroyRaw(requestParameters: ApiAutomationDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiAutomationDestroy().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/automation/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiAutomationDestroy(requestParameters: ApiAutomationDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiAutomationDestroyRaw(requestParameters, initOverrides);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiAutomationListRaw(requestParameters: ApiAutomationListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedAutomationList>> {
        const queryParameters: any = {};

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        if (requestParameters['type'] != null) {
            queryParameters['type'] = requestParameters['type'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/automation/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedAutomationListFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiAutomationList(requestParameters: ApiAutomationListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedAutomationList> {
        const response = await this.apiAutomationListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiAutomationPartialUpdateRaw(requestParameters: ApiAutomationPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Automation>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiAutomationPartialUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/automation/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedAutomationToJSON(requestParameters['patchedAutomation']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AutomationFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiAutomationPartialUpdate(requestParameters: ApiAutomationPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Automation> {
        const response = await this.apiAutomationPartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiAutomationRetrieveRaw(requestParameters: ApiAutomationRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Automation>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiAutomationRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/automation/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AutomationFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiAutomationRetrieve(requestParameters: ApiAutomationRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Automation> {
        const response = await this.apiAutomationRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiAutomationUpdateRaw(requestParameters: ApiAutomationUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Automation>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiAutomationUpdate().'
            );
        }

        if (requestParameters['automation'] == null) {
            throw new runtime.RequiredError(
                'automation',
                'Required parameter "automation" was null or undefined when calling apiAutomationUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/automation/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: AutomationToJSON(requestParameters['automation']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AutomationFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiAutomationUpdate(requestParameters: ApiAutomationUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Automation> {
        const response = await this.apiAutomationUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiBookmarkletImportCreateRaw(requestParameters: ApiBookmarkletImportCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BookmarkletImport>> {
        if (requestParameters['bookmarkletImport'] == null) {
            throw new runtime.RequiredError(
                'bookmarkletImport',
                'Required parameter "bookmarkletImport" was null or undefined when calling apiBookmarkletImportCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/bookmarklet-import/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BookmarkletImportToJSON(requestParameters['bookmarkletImport']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BookmarkletImportFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiBookmarkletImportCreate(requestParameters: ApiBookmarkletImportCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BookmarkletImport> {
        const response = await this.apiBookmarkletImportCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiBookmarkletImportDestroyRaw(requestParameters: ApiBookmarkletImportDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiBookmarkletImportDestroy().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/bookmarklet-import/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiBookmarkletImportDestroy(requestParameters: ApiBookmarkletImportDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiBookmarkletImportDestroyRaw(requestParameters, initOverrides);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiBookmarkletImportListRaw(requestParameters: ApiBookmarkletImportListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedBookmarkletImportListList>> {
        const queryParameters: any = {};

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/bookmarklet-import/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedBookmarkletImportListListFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiBookmarkletImportList(requestParameters: ApiBookmarkletImportListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedBookmarkletImportListList> {
        const response = await this.apiBookmarkletImportListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiBookmarkletImportPartialUpdateRaw(requestParameters: ApiBookmarkletImportPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BookmarkletImport>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiBookmarkletImportPartialUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/bookmarklet-import/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedBookmarkletImportToJSON(requestParameters['patchedBookmarkletImport']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BookmarkletImportFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiBookmarkletImportPartialUpdate(requestParameters: ApiBookmarkletImportPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BookmarkletImport> {
        const response = await this.apiBookmarkletImportPartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiBookmarkletImportRetrieveRaw(requestParameters: ApiBookmarkletImportRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BookmarkletImport>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiBookmarkletImportRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/bookmarklet-import/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BookmarkletImportFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiBookmarkletImportRetrieve(requestParameters: ApiBookmarkletImportRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BookmarkletImport> {
        const response = await this.apiBookmarkletImportRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiBookmarkletImportUpdateRaw(requestParameters: ApiBookmarkletImportUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BookmarkletImport>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiBookmarkletImportUpdate().'
            );
        }

        if (requestParameters['bookmarkletImport'] == null) {
            throw new runtime.RequiredError(
                'bookmarkletImport',
                'Required parameter "bookmarkletImport" was null or undefined when calling apiBookmarkletImportUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/bookmarklet-import/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: BookmarkletImportToJSON(requestParameters['bookmarkletImport']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BookmarkletImportFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiBookmarkletImportUpdate(requestParameters: ApiBookmarkletImportUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BookmarkletImport> {
        const response = await this.apiBookmarkletImportUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get a paginated list of objects that will be cascaded (deleted) when deleting the selected object
     */
    async apiConnectorConfigCascadingListRaw(requestParameters: ApiConnectorConfigCascadingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedGenericModelReferenceList>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiConnectorConfigCascadingList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['cache'] != null) {
            queryParameters['cache'] = requestParameters['cache'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/connector-config/{id}/cascading/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedGenericModelReferenceListFromJSON(jsonValue));
    }

    /**
     * get a paginated list of objects that will be cascaded (deleted) when deleting the selected object
     */
    async apiConnectorConfigCascadingList(requestParameters: ApiConnectorConfigCascadingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedGenericModelReferenceList> {
        const response = await this.apiConnectorConfigCascadingListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiConnectorConfigCreateRaw(requestParameters: ApiConnectorConfigCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConnectorConfig>> {
        if (requestParameters['connectorConfig'] == null) {
            throw new runtime.RequiredError(
                'connectorConfig',
                'Required parameter "connectorConfig" was null or undefined when calling apiConnectorConfigCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/connector-config/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ConnectorConfigToJSON(requestParameters['connectorConfig']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConnectorConfigFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiConnectorConfigCreate(requestParameters: ApiConnectorConfigCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConnectorConfig> {
        const response = await this.apiConnectorConfigCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiConnectorConfigDestroyRaw(requestParameters: ApiConnectorConfigDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiConnectorConfigDestroy().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/connector-config/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiConnectorConfigDestroy(requestParameters: ApiConnectorConfigDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiConnectorConfigDestroyRaw(requestParameters, initOverrides);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiConnectorConfigListRaw(requestParameters: ApiConnectorConfigListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedConnectorConfigList>> {
        const queryParameters: any = {};

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/connector-config/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedConnectorConfigListFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiConnectorConfigList(requestParameters: ApiConnectorConfigListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedConnectorConfigList> {
        const response = await this.apiConnectorConfigListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get a paginated list of objects where the selected object will be removed whe its deleted
     */
    async apiConnectorConfigNullingListRaw(requestParameters: ApiConnectorConfigNullingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedGenericModelReferenceList>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiConnectorConfigNullingList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['cache'] != null) {
            queryParameters['cache'] = requestParameters['cache'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/connector-config/{id}/nulling/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedGenericModelReferenceListFromJSON(jsonValue));
    }

    /**
     * get a paginated list of objects where the selected object will be removed whe its deleted
     */
    async apiConnectorConfigNullingList(requestParameters: ApiConnectorConfigNullingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedGenericModelReferenceList> {
        const response = await this.apiConnectorConfigNullingListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiConnectorConfigPartialUpdateRaw(requestParameters: ApiConnectorConfigPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConnectorConfig>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiConnectorConfigPartialUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/connector-config/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedConnectorConfigToJSON(requestParameters['patchedConnectorConfig']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConnectorConfigFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiConnectorConfigPartialUpdate(requestParameters: ApiConnectorConfigPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConnectorConfig> {
        const response = await this.apiConnectorConfigPartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get a paginated list of objects that are protecting the selected object form being deleted
     */
    async apiConnectorConfigProtectingListRaw(requestParameters: ApiConnectorConfigProtectingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedGenericModelReferenceList>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiConnectorConfigProtectingList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['cache'] != null) {
            queryParameters['cache'] = requestParameters['cache'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/connector-config/{id}/protecting/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedGenericModelReferenceListFromJSON(jsonValue));
    }

    /**
     * get a paginated list of objects that are protecting the selected object form being deleted
     */
    async apiConnectorConfigProtectingList(requestParameters: ApiConnectorConfigProtectingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedGenericModelReferenceList> {
        const response = await this.apiConnectorConfigProtectingListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiConnectorConfigRetrieveRaw(requestParameters: ApiConnectorConfigRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConnectorConfig>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiConnectorConfigRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/connector-config/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConnectorConfigFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiConnectorConfigRetrieve(requestParameters: ApiConnectorConfigRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConnectorConfig> {
        const response = await this.apiConnectorConfigRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiConnectorConfigUpdateRaw(requestParameters: ApiConnectorConfigUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConnectorConfig>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiConnectorConfigUpdate().'
            );
        }

        if (requestParameters['connectorConfig'] == null) {
            throw new runtime.RequiredError(
                'connectorConfig',
                'Required parameter "connectorConfig" was null or undefined when calling apiConnectorConfigUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/connector-config/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ConnectorConfigToJSON(requestParameters['connectorConfig']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConnectorConfigFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiConnectorConfigUpdate(requestParameters: ApiConnectorConfigUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConnectorConfig> {
        const response = await this.apiConnectorConfigUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiCookLogCreateRaw(requestParameters: ApiCookLogCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CookLog>> {
        if (requestParameters['cookLog'] == null) {
            throw new runtime.RequiredError(
                'cookLog',
                'Required parameter "cookLog" was null or undefined when calling apiCookLogCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/cook-log/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CookLogToJSON(requestParameters['cookLog']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CookLogFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiCookLogCreate(requestParameters: ApiCookLogCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CookLog> {
        const response = await this.apiCookLogCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiCookLogDestroyRaw(requestParameters: ApiCookLogDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiCookLogDestroy().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/cook-log/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiCookLogDestroy(requestParameters: ApiCookLogDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiCookLogDestroyRaw(requestParameters, initOverrides);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiCookLogListRaw(requestParameters: ApiCookLogListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedCookLogList>> {
        const queryParameters: any = {};

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        if (requestParameters['recipe'] != null) {
            queryParameters['recipe'] = requestParameters['recipe'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/cook-log/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedCookLogListFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiCookLogList(requestParameters: ApiCookLogListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedCookLogList> {
        const response = await this.apiCookLogListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiCookLogPartialUpdateRaw(requestParameters: ApiCookLogPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CookLog>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiCookLogPartialUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/cook-log/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedCookLogToJSON(requestParameters['patchedCookLog']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CookLogFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiCookLogPartialUpdate(requestParameters: ApiCookLogPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CookLog> {
        const response = await this.apiCookLogPartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiCookLogRetrieveRaw(requestParameters: ApiCookLogRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CookLog>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiCookLogRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/cook-log/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CookLogFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiCookLogRetrieve(requestParameters: ApiCookLogRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CookLog> {
        const response = await this.apiCookLogRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiCookLogUpdateRaw(requestParameters: ApiCookLogUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CookLog>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiCookLogUpdate().'
            );
        }

        if (requestParameters['cookLog'] == null) {
            throw new runtime.RequiredError(
                'cookLog',
                'Required parameter "cookLog" was null or undefined when calling apiCookLogUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/cook-log/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: CookLogToJSON(requestParameters['cookLog']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CookLogFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiCookLogUpdate(requestParameters: ApiCookLogUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CookLog> {
        const response = await this.apiCookLogUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiCustomFilterCreateRaw(requestParameters: ApiCustomFilterCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CustomFilter>> {
        if (requestParameters['customFilter'] == null) {
            throw new runtime.RequiredError(
                'customFilter',
                'Required parameter "customFilter" was null or undefined when calling apiCustomFilterCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/custom-filter/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CustomFilterToJSON(requestParameters['customFilter']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomFilterFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiCustomFilterCreate(requestParameters: ApiCustomFilterCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CustomFilter> {
        const response = await this.apiCustomFilterCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiCustomFilterDestroyRaw(requestParameters: ApiCustomFilterDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiCustomFilterDestroy().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/custom-filter/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiCustomFilterDestroy(requestParameters: ApiCustomFilterDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiCustomFilterDestroyRaw(requestParameters, initOverrides);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiCustomFilterListRaw(requestParameters: ApiCustomFilterListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedCustomFilterList>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        if (requestParameters['query'] != null) {
            queryParameters['query'] = requestParameters['query'];
        }

        if (requestParameters['random'] != null) {
            queryParameters['random'] = requestParameters['random'];
        }

        if (requestParameters['type'] != null) {
            queryParameters['type'] = requestParameters['type'];
        }

        if (requestParameters['updatedAt'] != null) {
            queryParameters['updated_at'] = requestParameters['updatedAt'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/custom-filter/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedCustomFilterListFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiCustomFilterList(requestParameters: ApiCustomFilterListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedCustomFilterList> {
        const response = await this.apiCustomFilterListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiCustomFilterPartialUpdateRaw(requestParameters: ApiCustomFilterPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CustomFilter>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiCustomFilterPartialUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/custom-filter/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedCustomFilterToJSON(requestParameters['patchedCustomFilter']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomFilterFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiCustomFilterPartialUpdate(requestParameters: ApiCustomFilterPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CustomFilter> {
        const response = await this.apiCustomFilterPartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiCustomFilterRetrieveRaw(requestParameters: ApiCustomFilterRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CustomFilter>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiCustomFilterRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/custom-filter/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomFilterFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiCustomFilterRetrieve(requestParameters: ApiCustomFilterRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CustomFilter> {
        const response = await this.apiCustomFilterRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiCustomFilterUpdateRaw(requestParameters: ApiCustomFilterUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CustomFilter>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiCustomFilterUpdate().'
            );
        }

        if (requestParameters['customFilter'] == null) {
            throw new runtime.RequiredError(
                'customFilter',
                'Required parameter "customFilter" was null or undefined when calling apiCustomFilterUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/custom-filter/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: CustomFilterToJSON(requestParameters['customFilter']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomFilterFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiCustomFilterUpdate(requestParameters: ApiCustomFilterUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CustomFilter> {
        const response = await this.apiCustomFilterUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * function to download a user file securely (wrapping as zip to prevent any context based XSS problems) temporary solution until a real file manager is implemented
     */
    async apiDownloadFileRetrieveRaw(requestParameters: ApiDownloadFileRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['fileId'] == null) {
            throw new runtime.RequiredError(
                'fileId',
                'Required parameter "fileId" was null or undefined when calling apiDownloadFileRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/download-file/{fileId}/`.replace(`{${"fileId"}}`, encodeURIComponent(String(requestParameters['fileId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * function to download a user file securely (wrapping as zip to prevent any context based XSS problems) temporary solution until a real file manager is implemented
     */
    async apiDownloadFileRetrieve(requestParameters: ApiDownloadFileRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiDownloadFileRetrieveRaw(requestParameters, initOverrides);
    }

    /**
     */
    async apiExportCreateRaw(requestParameters: ApiExportCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExportLog>> {
        if (requestParameters['exportRequest'] == null) {
            throw new runtime.RequiredError(
                'exportRequest',
                'Required parameter "exportRequest" was null or undefined when calling apiExportCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/export/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ExportRequestToJSON(requestParameters['exportRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExportLogFromJSON(jsonValue));
    }

    /**
     */
    async apiExportCreate(requestParameters: ApiExportCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExportLog> {
        const response = await this.apiExportCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiExportLogCreateRaw(requestParameters: ApiExportLogCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExportLog>> {
        if (requestParameters['exportLog'] == null) {
            throw new runtime.RequiredError(
                'exportLog',
                'Required parameter "exportLog" was null or undefined when calling apiExportLogCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/export-log/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ExportLogToJSON(requestParameters['exportLog']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExportLogFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiExportLogCreate(requestParameters: ApiExportLogCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExportLog> {
        const response = await this.apiExportLogCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiExportLogDestroyRaw(requestParameters: ApiExportLogDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiExportLogDestroy().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/export-log/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiExportLogDestroy(requestParameters: ApiExportLogDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiExportLogDestroyRaw(requestParameters, initOverrides);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiExportLogListRaw(requestParameters: ApiExportLogListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedExportLogList>> {
        const queryParameters: any = {};

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/export-log/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedExportLogListFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiExportLogList(requestParameters: ApiExportLogListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedExportLogList> {
        const response = await this.apiExportLogListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiExportLogPartialUpdateRaw(requestParameters: ApiExportLogPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExportLog>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiExportLogPartialUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/export-log/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedExportLogToJSON(requestParameters['patchedExportLog']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExportLogFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiExportLogPartialUpdate(requestParameters: ApiExportLogPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExportLog> {
        const response = await this.apiExportLogPartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiExportLogRetrieveRaw(requestParameters: ApiExportLogRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExportLog>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiExportLogRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/export-log/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExportLogFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiExportLogRetrieve(requestParameters: ApiExportLogRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExportLog> {
        const response = await this.apiExportLogRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiExportLogUpdateRaw(requestParameters: ApiExportLogUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExportLog>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiExportLogUpdate().'
            );
        }

        if (requestParameters['exportLog'] == null) {
            throw new runtime.RequiredError(
                'exportLog',
                'Required parameter "exportLog" was null or undefined when calling apiExportLogUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/export-log/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ExportLogToJSON(requestParameters['exportLog']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExportLogFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiExportLogUpdate(requestParameters: ApiExportLogUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExportLog> {
        const response = await this.apiExportLogUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async apiFdcSearchRetrieveRaw(requestParameters: ApiFdcSearchRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FdcQuery>> {
        const queryParameters: any = {};

        if (requestParameters['dataType'] != null) {
            queryParameters['dataType'] = requestParameters['dataType'];
        }

        if (requestParameters['query'] != null) {
            queryParameters['query'] = requestParameters['query'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/fdc-search/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FdcQueryFromJSON(jsonValue));
    }

    /**
     */
    async apiFdcSearchRetrieve(requestParameters: ApiFdcSearchRetrieveRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FdcQuery> {
        const response = await this.apiFdcSearchRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiFoodAipropertiesCreateRaw(requestParameters: ApiFoodAipropertiesCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Food>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiFoodAipropertiesCreate().'
            );
        }

        if (requestParameters['food'] == null) {
            throw new runtime.RequiredError(
                'food',
                'Required parameter "food" was null or undefined when calling apiFoodAipropertiesCreate().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['provider'] != null) {
            queryParameters['provider'] = requestParameters['provider'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/food/{id}/aiproperties/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: FoodToJSON(requestParameters['food']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FoodFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiFoodAipropertiesCreate(requestParameters: ApiFoodAipropertiesCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Food> {
        const response = await this.apiFoodAipropertiesCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiFoodBatchUpdateUpdateRaw(requestParameters: ApiFoodBatchUpdateUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FoodBatchUpdate>> {
        if (requestParameters['foodBatchUpdate'] == null) {
            throw new runtime.RequiredError(
                'foodBatchUpdate',
                'Required parameter "foodBatchUpdate" was null or undefined when calling apiFoodBatchUpdateUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/food/batch_update/`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: FoodBatchUpdateToJSON(requestParameters['foodBatchUpdate']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FoodBatchUpdateFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiFoodBatchUpdateUpdate(requestParameters: ApiFoodBatchUpdateUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FoodBatchUpdate> {
        const response = await this.apiFoodBatchUpdateUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get a paginated list of objects that will be cascaded (deleted) when deleting the selected object
     */
    async apiFoodCascadingListRaw(requestParameters: ApiFoodCascadingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedGenericModelReferenceList>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiFoodCascadingList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['cache'] != null) {
            queryParameters['cache'] = requestParameters['cache'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/food/{id}/cascading/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedGenericModelReferenceListFromJSON(jsonValue));
    }

    /**
     * get a paginated list of objects that will be cascaded (deleted) when deleting the selected object
     */
    async apiFoodCascadingList(requestParameters: ApiFoodCascadingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedGenericModelReferenceList> {
        const response = await this.apiFoodCascadingListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiFoodCreateRaw(requestParameters: ApiFoodCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Food>> {
        if (requestParameters['food'] == null) {
            throw new runtime.RequiredError(
                'food',
                'Required parameter "food" was null or undefined when calling apiFoodCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/food/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: FoodToJSON(requestParameters['food']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FoodFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiFoodCreate(requestParameters: ApiFoodCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Food> {
        const response = await this.apiFoodCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiFoodDestroyRaw(requestParameters: ApiFoodDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiFoodDestroy().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/food/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiFoodDestroy(requestParameters: ApiFoodDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiFoodDestroyRaw(requestParameters, initOverrides);
    }

    /**
     * updates the food with all possible data from the FDC Api if properties with a fdc_id already exist they will be overridden, if existing properties don\'t have a fdc_id they won\'t be changed
     */
    async apiFoodFdcCreateRaw(requestParameters: ApiFoodFdcCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Food>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiFoodFdcCreate().'
            );
        }

        if (requestParameters['food'] == null) {
            throw new runtime.RequiredError(
                'food',
                'Required parameter "food" was null or undefined when calling apiFoodFdcCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/food/{id}/fdc/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: FoodToJSON(requestParameters['food']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FoodFromJSON(jsonValue));
    }

    /**
     * updates the food with all possible data from the FDC Api if properties with a fdc_id already exist they will be overridden, if existing properties don\'t have a fdc_id they won\'t be changed
     */
    async apiFoodFdcCreate(requestParameters: ApiFoodFdcCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Food> {
        const response = await this.apiFoodFdcCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiFoodInheritFieldListRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<FoodInheritField>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/food-inherit-field/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(FoodInheritFieldFromJSON));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiFoodInheritFieldList(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<FoodInheritField>> {
        const response = await this.apiFoodInheritFieldListRaw(initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiFoodInheritFieldRetrieveRaw(requestParameters: ApiFoodInheritFieldRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FoodInheritField>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiFoodInheritFieldRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/food-inherit-field/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FoodInheritFieldFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiFoodInheritFieldRetrieve(requestParameters: ApiFoodInheritFieldRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FoodInheritField> {
        const response = await this.apiFoodInheritFieldRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiFoodListRaw(requestParameters: ApiFoodListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedFoodList>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        if (requestParameters['query'] != null) {
            queryParameters['query'] = requestParameters['query'];
        }

        if (requestParameters['random'] != null) {
            queryParameters['random'] = requestParameters['random'];
        }

        if (requestParameters['root'] != null) {
            queryParameters['root'] = requestParameters['root'];
        }

        if (requestParameters['rootTree'] != null) {
            queryParameters['root_tree'] = requestParameters['rootTree'];
        }

        if (requestParameters['tree'] != null) {
            queryParameters['tree'] = requestParameters['tree'];
        }

        if (requestParameters['updatedAt'] != null) {
            queryParameters['updated_at'] = requestParameters['updatedAt'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/food/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedFoodListFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiFoodList(requestParameters: ApiFoodListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedFoodList> {
        const response = await this.apiFoodListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiFoodMergeUpdateRaw(requestParameters: ApiFoodMergeUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Food>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiFoodMergeUpdate().'
            );
        }

        if (requestParameters['target'] == null) {
            throw new runtime.RequiredError(
                'target',
                'Required parameter "target" was null or undefined when calling apiFoodMergeUpdate().'
            );
        }

        if (requestParameters['food'] == null) {
            throw new runtime.RequiredError(
                'food',
                'Required parameter "food" was null or undefined when calling apiFoodMergeUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/food/{id}/merge/{target}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))).replace(`{${"target"}}`, encodeURIComponent(String(requestParameters['target']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: FoodToJSON(requestParameters['food']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FoodFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiFoodMergeUpdate(requestParameters: ApiFoodMergeUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Food> {
        const response = await this.apiFoodMergeUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiFoodMoveUpdateRaw(requestParameters: ApiFoodMoveUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Food>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiFoodMoveUpdate().'
            );
        }

        if (requestParameters['parent'] == null) {
            throw new runtime.RequiredError(
                'parent',
                'Required parameter "parent" was null or undefined when calling apiFoodMoveUpdate().'
            );
        }

        if (requestParameters['food'] == null) {
            throw new runtime.RequiredError(
                'food',
                'Required parameter "food" was null or undefined when calling apiFoodMoveUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/food/{id}/move/{parent}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))).replace(`{${"parent"}}`, encodeURIComponent(String(requestParameters['parent']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: FoodToJSON(requestParameters['food']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FoodFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiFoodMoveUpdate(requestParameters: ApiFoodMoveUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Food> {
        const response = await this.apiFoodMoveUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get a paginated list of objects where the selected object will be removed whe its deleted
     */
    async apiFoodNullingListRaw(requestParameters: ApiFoodNullingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedGenericModelReferenceList>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiFoodNullingList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['cache'] != null) {
            queryParameters['cache'] = requestParameters['cache'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/food/{id}/nulling/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedGenericModelReferenceListFromJSON(jsonValue));
    }

    /**
     * get a paginated list of objects where the selected object will be removed whe its deleted
     */
    async apiFoodNullingList(requestParameters: ApiFoodNullingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedGenericModelReferenceList> {
        const response = await this.apiFoodNullingListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiFoodPartialUpdateRaw(requestParameters: ApiFoodPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Food>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiFoodPartialUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/food/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedFoodToJSON(requestParameters['patchedFood']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FoodFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiFoodPartialUpdate(requestParameters: ApiFoodPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Food> {
        const response = await this.apiFoodPartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get a paginated list of objects that are protecting the selected object form being deleted
     */
    async apiFoodProtectingListRaw(requestParameters: ApiFoodProtectingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedGenericModelReferenceList>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiFoodProtectingList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['cache'] != null) {
            queryParameters['cache'] = requestParameters['cache'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/food/{id}/protecting/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedGenericModelReferenceListFromJSON(jsonValue));
    }

    /**
     * get a paginated list of objects that are protecting the selected object form being deleted
     */
    async apiFoodProtectingList(requestParameters: ApiFoodProtectingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedGenericModelReferenceList> {
        const response = await this.apiFoodProtectingListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiFoodRetrieveRaw(requestParameters: ApiFoodRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Food>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiFoodRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/food/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FoodFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiFoodRetrieve(requestParameters: ApiFoodRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Food> {
        const response = await this.apiFoodRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiFoodShoppingUpdateRaw(requestParameters: ApiFoodShoppingUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FoodShoppingUpdate>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiFoodShoppingUpdate().'
            );
        }

        if (requestParameters['foodShoppingUpdate'] == null) {
            throw new runtime.RequiredError(
                'foodShoppingUpdate',
                'Required parameter "foodShoppingUpdate" was null or undefined when calling apiFoodShoppingUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/food/{id}/shopping/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: FoodShoppingUpdateToJSON(requestParameters['foodShoppingUpdate']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FoodShoppingUpdateFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiFoodShoppingUpdate(requestParameters: ApiFoodShoppingUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FoodShoppingUpdate> {
        const response = await this.apiFoodShoppingUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiFoodUpdateRaw(requestParameters: ApiFoodUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Food>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiFoodUpdate().'
            );
        }

        if (requestParameters['food'] == null) {
            throw new runtime.RequiredError(
                'food',
                'Required parameter "food" was null or undefined when calling apiFoodUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/food/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: FoodToJSON(requestParameters['food']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FoodFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiFoodUpdate(requestParameters: ApiFoodUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Food> {
        const response = await this.apiFoodUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async apiGetExternalFileLinkRetrieveRaw(requestParameters: ApiGetExternalFileLinkRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiGetExternalFileLinkRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/get_external_file_link/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async apiGetExternalFileLinkRetrieve(requestParameters: ApiGetExternalFileLinkRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiGetExternalFileLinkRetrieveRaw(requestParameters, initOverrides);
    }

    /**
     */
    async apiGetRecipeFileRetrieveRaw(requestParameters: ApiGetRecipeFileRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiGetRecipeFileRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/get_recipe_file/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async apiGetRecipeFileRetrieve(requestParameters: ApiGetRecipeFileRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiGetRecipeFileRetrieveRaw(requestParameters, initOverrides);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiGroupListRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Group>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/group/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(GroupFromJSON));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiGroupList(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Group>> {
        const response = await this.apiGroupListRaw(initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiGroupRetrieveRaw(requestParameters: ApiGroupRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Group>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiGroupRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/group/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GroupFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiGroupRetrieve(requestParameters: ApiGroupRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Group> {
        const response = await this.apiGroupRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiHouseholdCreateRaw(requestParameters: ApiHouseholdCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Household>> {
        if (requestParameters['household'] == null) {
            throw new runtime.RequiredError(
                'household',
                'Required parameter "household" was null or undefined when calling apiHouseholdCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/household/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: HouseholdToJSON(requestParameters['household']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => HouseholdFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiHouseholdCreate(requestParameters: ApiHouseholdCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Household> {
        const response = await this.apiHouseholdCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiHouseholdDestroyRaw(requestParameters: ApiHouseholdDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiHouseholdDestroy().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/household/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiHouseholdDestroy(requestParameters: ApiHouseholdDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiHouseholdDestroyRaw(requestParameters, initOverrides);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiHouseholdListRaw(requestParameters: ApiHouseholdListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedHouseholdList>> {
        const queryParameters: any = {};

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/household/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedHouseholdListFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiHouseholdList(requestParameters: ApiHouseholdListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedHouseholdList> {
        const response = await this.apiHouseholdListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiHouseholdPartialUpdateRaw(requestParameters: ApiHouseholdPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Household>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiHouseholdPartialUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/household/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedHouseholdToJSON(requestParameters['patchedHousehold']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => HouseholdFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiHouseholdPartialUpdate(requestParameters: ApiHouseholdPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Household> {
        const response = await this.apiHouseholdPartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiHouseholdRetrieveRaw(requestParameters: ApiHouseholdRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Household>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiHouseholdRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/household/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => HouseholdFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiHouseholdRetrieve(requestParameters: ApiHouseholdRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Household> {
        const response = await this.apiHouseholdRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiHouseholdUpdateRaw(requestParameters: ApiHouseholdUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Household>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiHouseholdUpdate().'
            );
        }

        if (requestParameters['household'] == null) {
            throw new runtime.RequiredError(
                'household',
                'Required parameter "household" was null or undefined when calling apiHouseholdUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/household/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: HouseholdToJSON(requestParameters['household']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => HouseholdFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiHouseholdUpdate(requestParameters: ApiHouseholdUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Household> {
        const response = await this.apiHouseholdUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async apiImportCreateRaw(requestParameters: ApiImportCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RecipeFromSourceResponse>> {
        if (requestParameters['aiProviderId'] == null) {
            throw new runtime.RequiredError(
                'aiProviderId',
                'Required parameter "aiProviderId" was null or undefined when calling apiImportCreate().'
            );
        }

        if (requestParameters['file'] == null) {
            throw new runtime.RequiredError(
                'file',
                'Required parameter "file" was null or undefined when calling apiImportCreate().'
            );
        }

        if (requestParameters['text'] == null) {
            throw new runtime.RequiredError(
                'text',
                'Required parameter "text" was null or undefined when calling apiImportCreate().'
            );
        }

        if (requestParameters['recipeId'] == null) {
            throw new runtime.RequiredError(
                'recipeId',
                'Required parameter "recipeId" was null or undefined when calling apiImportCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['aiProviderId'] != null) {
            formParams.append('ai_provider_id', requestParameters['aiProviderId'] as any);
        }

        if (requestParameters['file'] != null) {
            formParams.append('file', requestParameters['file'] as any);
        }

        if (requestParameters['text'] != null) {
            formParams.append('text', requestParameters['text'] as any);
        }

        if (requestParameters['recipeId'] != null) {
            formParams.append('recipe_id', requestParameters['recipeId'] as any);
        }

        const response = await this.request({
            path: `/api/import/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RecipeFromSourceResponseFromJSON(jsonValue));
    }

    /**
     */
    async apiImportCreate(requestParameters: ApiImportCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RecipeFromSourceResponse> {
        const response = await this.apiImportCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiImportLogCreateRaw(requestParameters: ApiImportLogCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ImportLog>> {
        if (requestParameters['importLog'] == null) {
            throw new runtime.RequiredError(
                'importLog',
                'Required parameter "importLog" was null or undefined when calling apiImportLogCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/import-log/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ImportLogToJSON(requestParameters['importLog']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ImportLogFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiImportLogCreate(requestParameters: ApiImportLogCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ImportLog> {
        const response = await this.apiImportLogCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiImportLogDestroyRaw(requestParameters: ApiImportLogDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiImportLogDestroy().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/import-log/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiImportLogDestroy(requestParameters: ApiImportLogDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiImportLogDestroyRaw(requestParameters, initOverrides);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiImportLogListRaw(requestParameters: ApiImportLogListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedImportLogList>> {
        const queryParameters: any = {};

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/import-log/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedImportLogListFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiImportLogList(requestParameters: ApiImportLogListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedImportLogList> {
        const response = await this.apiImportLogListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiImportLogPartialUpdateRaw(requestParameters: ApiImportLogPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ImportLog>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiImportLogPartialUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/import-log/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedImportLogToJSON(requestParameters['patchedImportLog']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ImportLogFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiImportLogPartialUpdate(requestParameters: ApiImportLogPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ImportLog> {
        const response = await this.apiImportLogPartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiImportLogRetrieveRaw(requestParameters: ApiImportLogRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ImportLog>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiImportLogRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/import-log/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ImportLogFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiImportLogRetrieve(requestParameters: ApiImportLogRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ImportLog> {
        const response = await this.apiImportLogRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiImportLogUpdateRaw(requestParameters: ApiImportLogUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ImportLog>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiImportLogUpdate().'
            );
        }

        if (requestParameters['importLog'] == null) {
            throw new runtime.RequiredError(
                'importLog',
                'Required parameter "importLog" was null or undefined when calling apiImportLogUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/import-log/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ImportLogToJSON(requestParameters['importLog']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ImportLogFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiImportLogUpdate(requestParameters: ApiImportLogUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ImportLog> {
        const response = await this.apiImportLogUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async apiImportOpenDataCreateRaw(requestParameters: ApiImportOpenDataCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ImportOpenDataResponse>> {
        if (requestParameters['importOpenData'] == null) {
            throw new runtime.RequiredError(
                'importOpenData',
                'Required parameter "importOpenData" was null or undefined when calling apiImportOpenDataCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/import-open-data/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ImportOpenDataToJSON(requestParameters['importOpenData']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ImportOpenDataResponseFromJSON(jsonValue));
    }

    /**
     */
    async apiImportOpenDataCreate(requestParameters: ApiImportOpenDataCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ImportOpenDataResponse> {
        const response = await this.apiImportOpenDataCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async apiImportOpenDataRetrieveRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ImportOpenDataMetaData>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/import-open-data/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ImportOpenDataMetaDataFromJSON(jsonValue));
    }

    /**
     */
    async apiImportOpenDataRetrieve(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ImportOpenDataMetaData> {
        const response = await this.apiImportOpenDataRetrieveRaw(initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiIngredientCreateRaw(requestParameters: ApiIngredientCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Ingredient>> {
        if (requestParameters['ingredient'] == null) {
            throw new runtime.RequiredError(
                'ingredient',
                'Required parameter "ingredient" was null or undefined when calling apiIngredientCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/ingredient/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: IngredientToJSON(requestParameters['ingredient']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IngredientFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiIngredientCreate(requestParameters: ApiIngredientCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Ingredient> {
        const response = await this.apiIngredientCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiIngredientDestroyRaw(requestParameters: ApiIngredientDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiIngredientDestroy().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/ingredient/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiIngredientDestroy(requestParameters: ApiIngredientDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiIngredientDestroyRaw(requestParameters, initOverrides);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiIngredientListRaw(requestParameters: ApiIngredientListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedIngredientList>> {
        const queryParameters: any = {};

        if (requestParameters['food'] != null) {
            queryParameters['food'] = requestParameters['food'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        if (requestParameters['unit'] != null) {
            queryParameters['unit'] = requestParameters['unit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/ingredient/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedIngredientListFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiIngredientList(requestParameters: ApiIngredientListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedIngredientList> {
        const response = await this.apiIngredientListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async apiIngredientParserPostCreateRaw(requestParameters: ApiIngredientParserPostCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<IngredientParserResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/ingredient-parser/post/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: IngredientParserRequestToJSON(requestParameters['ingredientParserRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IngredientParserResponseFromJSON(jsonValue));
    }

    /**
     */
    async apiIngredientParserPostCreate(requestParameters: ApiIngredientParserPostCreateRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<IngredientParserResponse> {
        const response = await this.apiIngredientParserPostCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiIngredientPartialUpdateRaw(requestParameters: ApiIngredientPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Ingredient>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiIngredientPartialUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/ingredient/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedIngredientToJSON(requestParameters['patchedIngredient']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IngredientFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiIngredientPartialUpdate(requestParameters: ApiIngredientPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Ingredient> {
        const response = await this.apiIngredientPartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiIngredientRetrieveRaw(requestParameters: ApiIngredientRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Ingredient>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiIngredientRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/ingredient/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IngredientFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiIngredientRetrieve(requestParameters: ApiIngredientRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Ingredient> {
        const response = await this.apiIngredientRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiIngredientUpdateRaw(requestParameters: ApiIngredientUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Ingredient>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiIngredientUpdate().'
            );
        }

        if (requestParameters['ingredient'] == null) {
            throw new runtime.RequiredError(
                'ingredient',
                'Required parameter "ingredient" was null or undefined when calling apiIngredientUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/ingredient/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: IngredientToJSON(requestParameters['ingredient']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IngredientFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiIngredientUpdate(requestParameters: ApiIngredientUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Ingredient> {
        const response = await this.apiIngredientUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get a paginated list of objects that will be cascaded (deleted) when deleting the selected object
     */
    async apiInventoryEntryCascadingListRaw(requestParameters: ApiInventoryEntryCascadingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedGenericModelReferenceList>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiInventoryEntryCascadingList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['cache'] != null) {
            queryParameters['cache'] = requestParameters['cache'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/inventory-entry/{id}/cascading/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedGenericModelReferenceListFromJSON(jsonValue));
    }

    /**
     * get a paginated list of objects that will be cascaded (deleted) when deleting the selected object
     */
    async apiInventoryEntryCascadingList(requestParameters: ApiInventoryEntryCascadingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedGenericModelReferenceList> {
        const response = await this.apiInventoryEntryCascadingListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiInventoryEntryCreateRaw(requestParameters: ApiInventoryEntryCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<InventoryEntry>> {
        if (requestParameters['inventoryEntry'] == null) {
            throw new runtime.RequiredError(
                'inventoryEntry',
                'Required parameter "inventoryEntry" was null or undefined when calling apiInventoryEntryCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/inventory-entry/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: InventoryEntryToJSON(requestParameters['inventoryEntry']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InventoryEntryFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiInventoryEntryCreate(requestParameters: ApiInventoryEntryCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<InventoryEntry> {
        const response = await this.apiInventoryEntryCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiInventoryEntryDestroyRaw(requestParameters: ApiInventoryEntryDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiInventoryEntryDestroy().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/inventory-entry/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiInventoryEntryDestroy(requestParameters: ApiInventoryEntryDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiInventoryEntryDestroyRaw(requestParameters, initOverrides);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiInventoryEntryListRaw(requestParameters: ApiInventoryEntryListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedInventoryEntryList>> {
        const queryParameters: any = {};

        if (requestParameters['code'] != null) {
            queryParameters['code'] = requestParameters['code'];
        }

        if (requestParameters['empty'] != null) {
            queryParameters['empty'] = requestParameters['empty'];
        }

        if (requestParameters['foodId'] != null) {
            queryParameters['food_id'] = requestParameters['foodId'];
        }

        if (requestParameters['inventoryLocationId'] != null) {
            queryParameters['inventory_location_id'] = requestParameters['inventoryLocationId'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/inventory-entry/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedInventoryEntryListFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiInventoryEntryList(requestParameters: ApiInventoryEntryListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedInventoryEntryList> {
        const response = await this.apiInventoryEntryListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get a paginated list of objects where the selected object will be removed whe its deleted
     */
    async apiInventoryEntryNullingListRaw(requestParameters: ApiInventoryEntryNullingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedGenericModelReferenceList>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiInventoryEntryNullingList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['cache'] != null) {
            queryParameters['cache'] = requestParameters['cache'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/inventory-entry/{id}/nulling/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedGenericModelReferenceListFromJSON(jsonValue));
    }

    /**
     * get a paginated list of objects where the selected object will be removed whe its deleted
     */
    async apiInventoryEntryNullingList(requestParameters: ApiInventoryEntryNullingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedGenericModelReferenceList> {
        const response = await this.apiInventoryEntryNullingListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiInventoryEntryPartialUpdateRaw(requestParameters: ApiInventoryEntryPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<InventoryEntry>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiInventoryEntryPartialUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/inventory-entry/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedInventoryEntryToJSON(requestParameters['patchedInventoryEntry']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InventoryEntryFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiInventoryEntryPartialUpdate(requestParameters: ApiInventoryEntryPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<InventoryEntry> {
        const response = await this.apiInventoryEntryPartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get a paginated list of objects that are protecting the selected object form being deleted
     */
    async apiInventoryEntryProtectingListRaw(requestParameters: ApiInventoryEntryProtectingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedGenericModelReferenceList>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiInventoryEntryProtectingList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['cache'] != null) {
            queryParameters['cache'] = requestParameters['cache'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/inventory-entry/{id}/protecting/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedGenericModelReferenceListFromJSON(jsonValue));
    }

    /**
     * get a paginated list of objects that are protecting the selected object form being deleted
     */
    async apiInventoryEntryProtectingList(requestParameters: ApiInventoryEntryProtectingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedGenericModelReferenceList> {
        const response = await this.apiInventoryEntryProtectingListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiInventoryEntryRetrieveRaw(requestParameters: ApiInventoryEntryRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<InventoryEntry>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiInventoryEntryRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/inventory-entry/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InventoryEntryFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiInventoryEntryRetrieve(requestParameters: ApiInventoryEntryRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<InventoryEntry> {
        const response = await this.apiInventoryEntryRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiInventoryEntryUpdateRaw(requestParameters: ApiInventoryEntryUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<InventoryEntry>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiInventoryEntryUpdate().'
            );
        }

        if (requestParameters['inventoryEntry'] == null) {
            throw new runtime.RequiredError(
                'inventoryEntry',
                'Required parameter "inventoryEntry" was null or undefined when calling apiInventoryEntryUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/inventory-entry/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: InventoryEntryToJSON(requestParameters['inventoryEntry']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InventoryEntryFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiInventoryEntryUpdate(requestParameters: ApiInventoryEntryUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<InventoryEntry> {
        const response = await this.apiInventoryEntryUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get a paginated list of objects that will be cascaded (deleted) when deleting the selected object
     */
    async apiInventoryLocationCascadingListRaw(requestParameters: ApiInventoryLocationCascadingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedGenericModelReferenceList>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiInventoryLocationCascadingList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['cache'] != null) {
            queryParameters['cache'] = requestParameters['cache'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/inventory-location/{id}/cascading/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedGenericModelReferenceListFromJSON(jsonValue));
    }

    /**
     * get a paginated list of objects that will be cascaded (deleted) when deleting the selected object
     */
    async apiInventoryLocationCascadingList(requestParameters: ApiInventoryLocationCascadingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedGenericModelReferenceList> {
        const response = await this.apiInventoryLocationCascadingListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiInventoryLocationCreateRaw(requestParameters: ApiInventoryLocationCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<InventoryLocation>> {
        if (requestParameters['inventoryLocation'] == null) {
            throw new runtime.RequiredError(
                'inventoryLocation',
                'Required parameter "inventoryLocation" was null or undefined when calling apiInventoryLocationCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/inventory-location/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: InventoryLocationToJSON(requestParameters['inventoryLocation']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InventoryLocationFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiInventoryLocationCreate(requestParameters: ApiInventoryLocationCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<InventoryLocation> {
        const response = await this.apiInventoryLocationCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiInventoryLocationDestroyRaw(requestParameters: ApiInventoryLocationDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiInventoryLocationDestroy().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/inventory-location/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiInventoryLocationDestroy(requestParameters: ApiInventoryLocationDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiInventoryLocationDestroyRaw(requestParameters, initOverrides);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiInventoryLocationListRaw(requestParameters: ApiInventoryLocationListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedInventoryLocationList>> {
        const queryParameters: any = {};

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/inventory-location/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedInventoryLocationListFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiInventoryLocationList(requestParameters: ApiInventoryLocationListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedInventoryLocationList> {
        const response = await this.apiInventoryLocationListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get a paginated list of objects where the selected object will be removed whe its deleted
     */
    async apiInventoryLocationNullingListRaw(requestParameters: ApiInventoryLocationNullingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedGenericModelReferenceList>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiInventoryLocationNullingList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['cache'] != null) {
            queryParameters['cache'] = requestParameters['cache'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/inventory-location/{id}/nulling/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedGenericModelReferenceListFromJSON(jsonValue));
    }

    /**
     * get a paginated list of objects where the selected object will be removed whe its deleted
     */
    async apiInventoryLocationNullingList(requestParameters: ApiInventoryLocationNullingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedGenericModelReferenceList> {
        const response = await this.apiInventoryLocationNullingListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiInventoryLocationPartialUpdateRaw(requestParameters: ApiInventoryLocationPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<InventoryLocation>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiInventoryLocationPartialUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/inventory-location/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedInventoryLocationToJSON(requestParameters['patchedInventoryLocation']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InventoryLocationFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiInventoryLocationPartialUpdate(requestParameters: ApiInventoryLocationPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<InventoryLocation> {
        const response = await this.apiInventoryLocationPartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get a paginated list of objects that are protecting the selected object form being deleted
     */
    async apiInventoryLocationProtectingListRaw(requestParameters: ApiInventoryLocationProtectingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedGenericModelReferenceList>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiInventoryLocationProtectingList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['cache'] != null) {
            queryParameters['cache'] = requestParameters['cache'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/inventory-location/{id}/protecting/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedGenericModelReferenceListFromJSON(jsonValue));
    }

    /**
     * get a paginated list of objects that are protecting the selected object form being deleted
     */
    async apiInventoryLocationProtectingList(requestParameters: ApiInventoryLocationProtectingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedGenericModelReferenceList> {
        const response = await this.apiInventoryLocationProtectingListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiInventoryLocationRetrieveRaw(requestParameters: ApiInventoryLocationRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<InventoryLocation>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiInventoryLocationRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/inventory-location/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InventoryLocationFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiInventoryLocationRetrieve(requestParameters: ApiInventoryLocationRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<InventoryLocation> {
        const response = await this.apiInventoryLocationRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiInventoryLocationUpdateRaw(requestParameters: ApiInventoryLocationUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<InventoryLocation>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiInventoryLocationUpdate().'
            );
        }

        if (requestParameters['inventoryLocation'] == null) {
            throw new runtime.RequiredError(
                'inventoryLocation',
                'Required parameter "inventoryLocation" was null or undefined when calling apiInventoryLocationUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/inventory-location/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: InventoryLocationToJSON(requestParameters['inventoryLocation']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InventoryLocationFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiInventoryLocationUpdate(requestParameters: ApiInventoryLocationUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<InventoryLocation> {
        const response = await this.apiInventoryLocationUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiInventoryLogListRaw(requestParameters: ApiInventoryLogListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedInventoryLogList>> {
        const queryParameters: any = {};

        if (requestParameters['entryId'] != null) {
            queryParameters['entry_id'] = requestParameters['entryId'];
        }

        if (requestParameters['foodId'] != null) {
            queryParameters['food_id'] = requestParameters['foodId'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/inventory-log/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedInventoryLogListFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiInventoryLogList(requestParameters: ApiInventoryLogListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedInventoryLogList> {
        const response = await this.apiInventoryLogListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiInventoryLogRetrieveRaw(requestParameters: ApiInventoryLogRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<InventoryLog>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiInventoryLogRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/inventory-log/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InventoryLogFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiInventoryLogRetrieve(requestParameters: ApiInventoryLogRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<InventoryLog> {
        const response = await this.apiInventoryLogRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiInviteLinkCreateRaw(requestParameters: ApiInviteLinkCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<InviteLink>> {
        if (requestParameters['inviteLink'] == null) {
            throw new runtime.RequiredError(
                'inviteLink',
                'Required parameter "inviteLink" was null or undefined when calling apiInviteLinkCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/invite-link/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: InviteLinkToJSON(requestParameters['inviteLink']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InviteLinkFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiInviteLinkCreate(requestParameters: ApiInviteLinkCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<InviteLink> {
        const response = await this.apiInviteLinkCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiInviteLinkDestroyRaw(requestParameters: ApiInviteLinkDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiInviteLinkDestroy().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/invite-link/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiInviteLinkDestroy(requestParameters: ApiInviteLinkDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiInviteLinkDestroyRaw(requestParameters, initOverrides);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiInviteLinkListRaw(requestParameters: ApiInviteLinkListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedInviteLinkList>> {
        const queryParameters: any = {};

        if (requestParameters['internalNote'] != null) {
            queryParameters['internal_note'] = requestParameters['internalNote'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        if (requestParameters['query'] != null) {
            queryParameters['query'] = requestParameters['query'];
        }

        if (requestParameters['random'] != null) {
            queryParameters['random'] = requestParameters['random'];
        }

        if (requestParameters['unused'] != null) {
            queryParameters['unused'] = requestParameters['unused'];
        }

        if (requestParameters['updatedAt'] != null) {
            queryParameters['updated_at'] = requestParameters['updatedAt'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/invite-link/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedInviteLinkListFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiInviteLinkList(requestParameters: ApiInviteLinkListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedInviteLinkList> {
        const response = await this.apiInviteLinkListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiInviteLinkPartialUpdateRaw(requestParameters: ApiInviteLinkPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<InviteLink>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiInviteLinkPartialUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/invite-link/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedInviteLinkToJSON(requestParameters['patchedInviteLink']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InviteLinkFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiInviteLinkPartialUpdate(requestParameters: ApiInviteLinkPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<InviteLink> {
        const response = await this.apiInviteLinkPartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiInviteLinkRetrieveRaw(requestParameters: ApiInviteLinkRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<InviteLink>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiInviteLinkRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/invite-link/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InviteLinkFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiInviteLinkRetrieve(requestParameters: ApiInviteLinkRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<InviteLink> {
        const response = await this.apiInviteLinkRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiInviteLinkUpdateRaw(requestParameters: ApiInviteLinkUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<InviteLink>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiInviteLinkUpdate().'
            );
        }

        if (requestParameters['inviteLink'] == null) {
            throw new runtime.RequiredError(
                'inviteLink',
                'Required parameter "inviteLink" was null or undefined when calling apiInviteLinkUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/invite-link/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: InviteLinkToJSON(requestParameters['inviteLink']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InviteLinkFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiInviteLinkUpdate(requestParameters: ApiInviteLinkUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<InviteLink> {
        const response = await this.apiInviteLinkUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get a paginated list of objects that will be cascaded (deleted) when deleting the selected object
     */
    async apiKeywordCascadingListRaw(requestParameters: ApiKeywordCascadingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedGenericModelReferenceList>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiKeywordCascadingList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['cache'] != null) {
            queryParameters['cache'] = requestParameters['cache'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/keyword/{id}/cascading/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedGenericModelReferenceListFromJSON(jsonValue));
    }

    /**
     * get a paginated list of objects that will be cascaded (deleted) when deleting the selected object
     */
    async apiKeywordCascadingList(requestParameters: ApiKeywordCascadingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedGenericModelReferenceList> {
        const response = await this.apiKeywordCascadingListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiKeywordCreateRaw(requestParameters: ApiKeywordCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Keyword>> {
        if (requestParameters['keyword'] == null) {
            throw new runtime.RequiredError(
                'keyword',
                'Required parameter "keyword" was null or undefined when calling apiKeywordCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/keyword/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: KeywordToJSON(requestParameters['keyword']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => KeywordFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiKeywordCreate(requestParameters: ApiKeywordCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Keyword> {
        const response = await this.apiKeywordCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiKeywordDestroyRaw(requestParameters: ApiKeywordDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiKeywordDestroy().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/keyword/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiKeywordDestroy(requestParameters: ApiKeywordDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiKeywordDestroyRaw(requestParameters, initOverrides);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiKeywordListRaw(requestParameters: ApiKeywordListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedKeywordList>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        if (requestParameters['query'] != null) {
            queryParameters['query'] = requestParameters['query'];
        }

        if (requestParameters['random'] != null) {
            queryParameters['random'] = requestParameters['random'];
        }

        if (requestParameters['root'] != null) {
            queryParameters['root'] = requestParameters['root'];
        }

        if (requestParameters['rootTree'] != null) {
            queryParameters['root_tree'] = requestParameters['rootTree'];
        }

        if (requestParameters['tree'] != null) {
            queryParameters['tree'] = requestParameters['tree'];
        }

        if (requestParameters['updatedAt'] != null) {
            queryParameters['updated_at'] = requestParameters['updatedAt'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/keyword/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedKeywordListFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiKeywordList(requestParameters: ApiKeywordListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedKeywordList> {
        const response = await this.apiKeywordListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiKeywordMergeUpdateRaw(requestParameters: ApiKeywordMergeUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Keyword>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiKeywordMergeUpdate().'
            );
        }

        if (requestParameters['target'] == null) {
            throw new runtime.RequiredError(
                'target',
                'Required parameter "target" was null or undefined when calling apiKeywordMergeUpdate().'
            );
        }

        if (requestParameters['keyword'] == null) {
            throw new runtime.RequiredError(
                'keyword',
                'Required parameter "keyword" was null or undefined when calling apiKeywordMergeUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/keyword/{id}/merge/{target}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))).replace(`{${"target"}}`, encodeURIComponent(String(requestParameters['target']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: KeywordToJSON(requestParameters['keyword']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => KeywordFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiKeywordMergeUpdate(requestParameters: ApiKeywordMergeUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Keyword> {
        const response = await this.apiKeywordMergeUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiKeywordMoveUpdateRaw(requestParameters: ApiKeywordMoveUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Keyword>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiKeywordMoveUpdate().'
            );
        }

        if (requestParameters['parent'] == null) {
            throw new runtime.RequiredError(
                'parent',
                'Required parameter "parent" was null or undefined when calling apiKeywordMoveUpdate().'
            );
        }

        if (requestParameters['keyword'] == null) {
            throw new runtime.RequiredError(
                'keyword',
                'Required parameter "keyword" was null or undefined when calling apiKeywordMoveUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/keyword/{id}/move/{parent}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))).replace(`{${"parent"}}`, encodeURIComponent(String(requestParameters['parent']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: KeywordToJSON(requestParameters['keyword']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => KeywordFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiKeywordMoveUpdate(requestParameters: ApiKeywordMoveUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Keyword> {
        const response = await this.apiKeywordMoveUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get a paginated list of objects where the selected object will be removed whe its deleted
     */
    async apiKeywordNullingListRaw(requestParameters: ApiKeywordNullingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedGenericModelReferenceList>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiKeywordNullingList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['cache'] != null) {
            queryParameters['cache'] = requestParameters['cache'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/keyword/{id}/nulling/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedGenericModelReferenceListFromJSON(jsonValue));
    }

    /**
     * get a paginated list of objects where the selected object will be removed whe its deleted
     */
    async apiKeywordNullingList(requestParameters: ApiKeywordNullingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedGenericModelReferenceList> {
        const response = await this.apiKeywordNullingListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiKeywordPartialUpdateRaw(requestParameters: ApiKeywordPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Keyword>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiKeywordPartialUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/keyword/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedKeywordToJSON(requestParameters['patchedKeyword']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => KeywordFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiKeywordPartialUpdate(requestParameters: ApiKeywordPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Keyword> {
        const response = await this.apiKeywordPartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get a paginated list of objects that are protecting the selected object form being deleted
     */
    async apiKeywordProtectingListRaw(requestParameters: ApiKeywordProtectingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedGenericModelReferenceList>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiKeywordProtectingList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['cache'] != null) {
            queryParameters['cache'] = requestParameters['cache'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/keyword/{id}/protecting/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedGenericModelReferenceListFromJSON(jsonValue));
    }

    /**
     * get a paginated list of objects that are protecting the selected object form being deleted
     */
    async apiKeywordProtectingList(requestParameters: ApiKeywordProtectingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedGenericModelReferenceList> {
        const response = await this.apiKeywordProtectingListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiKeywordRetrieveRaw(requestParameters: ApiKeywordRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Keyword>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiKeywordRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/keyword/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => KeywordFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiKeywordRetrieve(requestParameters: ApiKeywordRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Keyword> {
        const response = await this.apiKeywordRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiKeywordUpdateRaw(requestParameters: ApiKeywordUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Keyword>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiKeywordUpdate().'
            );
        }

        if (requestParameters['keyword'] == null) {
            throw new runtime.RequiredError(
                'keyword',
                'Required parameter "keyword" was null or undefined when calling apiKeywordUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/keyword/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: KeywordToJSON(requestParameters['keyword']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => KeywordFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiKeywordUpdate(requestParameters: ApiKeywordUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Keyword> {
        const response = await this.apiKeywordUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async apiLocalizationListRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Localization>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/localization/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(LocalizationFromJSON));
    }

    /**
     */
    async apiLocalizationList(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Localization>> {
        const response = await this.apiLocalizationListRaw(initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiMealPlanCreateRaw(requestParameters: ApiMealPlanCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MealPlan>> {
        if (requestParameters['mealPlan'] == null) {
            throw new runtime.RequiredError(
                'mealPlan',
                'Required parameter "mealPlan" was null or undefined when calling apiMealPlanCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/meal-plan/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: MealPlanToJSON(requestParameters['mealPlan']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MealPlanFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiMealPlanCreate(requestParameters: ApiMealPlanCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MealPlan> {
        const response = await this.apiMealPlanCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiMealPlanDestroyRaw(requestParameters: ApiMealPlanDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiMealPlanDestroy().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/meal-plan/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiMealPlanDestroy(requestParameters: ApiMealPlanDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiMealPlanDestroyRaw(requestParameters, initOverrides);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiMealPlanIcalRetrieveRaw(requestParameters: ApiMealPlanIcalRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        const queryParameters: any = {};

        if (requestParameters['fromDate'] != null) {
            queryParameters['from_date'] = requestParameters['fromDate'];
        }

        if (requestParameters['mealType'] != null) {
            queryParameters['meal_type'] = requestParameters['mealType'];
        }

        if (requestParameters['toDate'] != null) {
            queryParameters['to_date'] = requestParameters['toDate'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/meal-plan/ical/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiMealPlanIcalRetrieve(requestParameters: ApiMealPlanIcalRetrieveRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.apiMealPlanIcalRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiMealPlanListRaw(requestParameters: ApiMealPlanListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedMealPlanList>> {
        const queryParameters: any = {};

        if (requestParameters['fromDate'] != null) {
            queryParameters['from_date'] = requestParameters['fromDate'];
        }

        if (requestParameters['mealType'] != null) {
            queryParameters['meal_type'] = requestParameters['mealType'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        if (requestParameters['toDate'] != null) {
            queryParameters['to_date'] = requestParameters['toDate'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/meal-plan/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedMealPlanListFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiMealPlanList(requestParameters: ApiMealPlanListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedMealPlanList> {
        const response = await this.apiMealPlanListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiMealPlanPartialUpdateRaw(requestParameters: ApiMealPlanPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MealPlan>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiMealPlanPartialUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/meal-plan/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedMealPlanToJSON(requestParameters['patchedMealPlan']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MealPlanFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiMealPlanPartialUpdate(requestParameters: ApiMealPlanPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MealPlan> {
        const response = await this.apiMealPlanPartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiMealPlanRetrieveRaw(requestParameters: ApiMealPlanRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MealPlan>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiMealPlanRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/meal-plan/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MealPlanFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiMealPlanRetrieve(requestParameters: ApiMealPlanRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MealPlan> {
        const response = await this.apiMealPlanRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiMealPlanUpdateRaw(requestParameters: ApiMealPlanUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MealPlan>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiMealPlanUpdate().'
            );
        }

        if (requestParameters['mealPlan'] == null) {
            throw new runtime.RequiredError(
                'mealPlan',
                'Required parameter "mealPlan" was null or undefined when calling apiMealPlanUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/meal-plan/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: MealPlanToJSON(requestParameters['mealPlan']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MealPlanFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiMealPlanUpdate(requestParameters: ApiMealPlanUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MealPlan> {
        const response = await this.apiMealPlanUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get a paginated list of objects that will be cascaded (deleted) when deleting the selected object
     */
    async apiMealTypeCascadingListRaw(requestParameters: ApiMealTypeCascadingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedGenericModelReferenceList>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiMealTypeCascadingList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['cache'] != null) {
            queryParameters['cache'] = requestParameters['cache'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/meal-type/{id}/cascading/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedGenericModelReferenceListFromJSON(jsonValue));
    }

    /**
     * get a paginated list of objects that will be cascaded (deleted) when deleting the selected object
     */
    async apiMealTypeCascadingList(requestParameters: ApiMealTypeCascadingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedGenericModelReferenceList> {
        const response = await this.apiMealTypeCascadingListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * returns list of meal types created by the requesting user ordered by the order field.
     */
    async apiMealTypeCreateRaw(requestParameters: ApiMealTypeCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MealType>> {
        if (requestParameters['mealType'] == null) {
            throw new runtime.RequiredError(
                'mealType',
                'Required parameter "mealType" was null or undefined when calling apiMealTypeCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/meal-type/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: MealTypeToJSON(requestParameters['mealType']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MealTypeFromJSON(jsonValue));
    }

    /**
     * returns list of meal types created by the requesting user ordered by the order field.
     */
    async apiMealTypeCreate(requestParameters: ApiMealTypeCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MealType> {
        const response = await this.apiMealTypeCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * returns list of meal types created by the requesting user ordered by the order field.
     */
    async apiMealTypeDestroyRaw(requestParameters: ApiMealTypeDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiMealTypeDestroy().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/meal-type/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * returns list of meal types created by the requesting user ordered by the order field.
     */
    async apiMealTypeDestroy(requestParameters: ApiMealTypeDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiMealTypeDestroyRaw(requestParameters, initOverrides);
    }

    /**
     * returns list of meal types created by the requesting user ordered by the order field.
     */
    async apiMealTypeListRaw(requestParameters: ApiMealTypeListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedMealTypeList>> {
        const queryParameters: any = {};

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/meal-type/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedMealTypeListFromJSON(jsonValue));
    }

    /**
     * returns list of meal types created by the requesting user ordered by the order field.
     */
    async apiMealTypeList(requestParameters: ApiMealTypeListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedMealTypeList> {
        const response = await this.apiMealTypeListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get a paginated list of objects where the selected object will be removed whe its deleted
     */
    async apiMealTypeNullingListRaw(requestParameters: ApiMealTypeNullingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedGenericModelReferenceList>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiMealTypeNullingList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['cache'] != null) {
            queryParameters['cache'] = requestParameters['cache'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/meal-type/{id}/nulling/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedGenericModelReferenceListFromJSON(jsonValue));
    }

    /**
     * get a paginated list of objects where the selected object will be removed whe its deleted
     */
    async apiMealTypeNullingList(requestParameters: ApiMealTypeNullingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedGenericModelReferenceList> {
        const response = await this.apiMealTypeNullingListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * returns list of meal types created by the requesting user ordered by the order field.
     */
    async apiMealTypePartialUpdateRaw(requestParameters: ApiMealTypePartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MealType>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiMealTypePartialUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/meal-type/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedMealTypeToJSON(requestParameters['patchedMealType']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MealTypeFromJSON(jsonValue));
    }

    /**
     * returns list of meal types created by the requesting user ordered by the order field.
     */
    async apiMealTypePartialUpdate(requestParameters: ApiMealTypePartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MealType> {
        const response = await this.apiMealTypePartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get a paginated list of objects that are protecting the selected object form being deleted
     */
    async apiMealTypeProtectingListRaw(requestParameters: ApiMealTypeProtectingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedGenericModelReferenceList>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiMealTypeProtectingList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['cache'] != null) {
            queryParameters['cache'] = requestParameters['cache'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/meal-type/{id}/protecting/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedGenericModelReferenceListFromJSON(jsonValue));
    }

    /**
     * get a paginated list of objects that are protecting the selected object form being deleted
     */
    async apiMealTypeProtectingList(requestParameters: ApiMealTypeProtectingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedGenericModelReferenceList> {
        const response = await this.apiMealTypeProtectingListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * returns list of meal types created by the requesting user ordered by the order field.
     */
    async apiMealTypeRetrieveRaw(requestParameters: ApiMealTypeRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MealType>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiMealTypeRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/meal-type/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MealTypeFromJSON(jsonValue));
    }

    /**
     * returns list of meal types created by the requesting user ordered by the order field.
     */
    async apiMealTypeRetrieve(requestParameters: ApiMealTypeRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MealType> {
        const response = await this.apiMealTypeRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * returns list of meal types created by the requesting user ordered by the order field.
     */
    async apiMealTypeUpdateRaw(requestParameters: ApiMealTypeUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MealType>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiMealTypeUpdate().'
            );
        }

        if (requestParameters['mealType'] == null) {
            throw new runtime.RequiredError(
                'mealType',
                'Required parameter "mealType" was null or undefined when calling apiMealTypeUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/meal-type/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: MealTypeToJSON(requestParameters['mealType']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MealTypeFromJSON(jsonValue));
    }

    /**
     * returns list of meal types created by the requesting user ordered by the order field.
     */
    async apiMealTypeUpdate(requestParameters: ApiMealTypeUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MealType> {
        const response = await this.apiMealTypeUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiPropertyCreateRaw(requestParameters: ApiPropertyCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Property>> {
        if (requestParameters['property'] == null) {
            throw new runtime.RequiredError(
                'property',
                'Required parameter "property" was null or undefined when calling apiPropertyCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/property/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PropertyToJSON(requestParameters['property']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PropertyFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiPropertyCreate(requestParameters: ApiPropertyCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Property> {
        const response = await this.apiPropertyCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiPropertyDestroyRaw(requestParameters: ApiPropertyDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiPropertyDestroy().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/property/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiPropertyDestroy(requestParameters: ApiPropertyDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiPropertyDestroyRaw(requestParameters, initOverrides);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiPropertyListRaw(requestParameters: ApiPropertyListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedPropertyList>> {
        const queryParameters: any = {};

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/property/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedPropertyListFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiPropertyList(requestParameters: ApiPropertyListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedPropertyList> {
        const response = await this.apiPropertyListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiPropertyPartialUpdateRaw(requestParameters: ApiPropertyPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Property>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiPropertyPartialUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/property/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedPropertyToJSON(requestParameters['patchedProperty']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PropertyFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiPropertyPartialUpdate(requestParameters: ApiPropertyPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Property> {
        const response = await this.apiPropertyPartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiPropertyRetrieveRaw(requestParameters: ApiPropertyRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Property>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiPropertyRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/property/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PropertyFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiPropertyRetrieve(requestParameters: ApiPropertyRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Property> {
        const response = await this.apiPropertyRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get a paginated list of objects that will be cascaded (deleted) when deleting the selected object
     */
    async apiPropertyTypeCascadingListRaw(requestParameters: ApiPropertyTypeCascadingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedGenericModelReferenceList>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiPropertyTypeCascadingList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['cache'] != null) {
            queryParameters['cache'] = requestParameters['cache'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/property-type/{id}/cascading/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedGenericModelReferenceListFromJSON(jsonValue));
    }

    /**
     * get a paginated list of objects that will be cascaded (deleted) when deleting the selected object
     */
    async apiPropertyTypeCascadingList(requestParameters: ApiPropertyTypeCascadingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedGenericModelReferenceList> {
        const response = await this.apiPropertyTypeCascadingListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiPropertyTypeCreateRaw(requestParameters: ApiPropertyTypeCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PropertyType>> {
        if (requestParameters['propertyType'] == null) {
            throw new runtime.RequiredError(
                'propertyType',
                'Required parameter "propertyType" was null or undefined when calling apiPropertyTypeCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/property-type/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PropertyTypeToJSON(requestParameters['propertyType']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PropertyTypeFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiPropertyTypeCreate(requestParameters: ApiPropertyTypeCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PropertyType> {
        const response = await this.apiPropertyTypeCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiPropertyTypeDestroyRaw(requestParameters: ApiPropertyTypeDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiPropertyTypeDestroy().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/property-type/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiPropertyTypeDestroy(requestParameters: ApiPropertyTypeDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiPropertyTypeDestroyRaw(requestParameters, initOverrides);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiPropertyTypeListRaw(requestParameters: ApiPropertyTypeListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedPropertyTypeList>> {
        const queryParameters: any = {};

        if (requestParameters['category'] != null) {
            queryParameters['category'] = requestParameters['category'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/property-type/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedPropertyTypeListFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiPropertyTypeList(requestParameters: ApiPropertyTypeListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedPropertyTypeList> {
        const response = await this.apiPropertyTypeListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get a paginated list of objects where the selected object will be removed whe its deleted
     */
    async apiPropertyTypeNullingListRaw(requestParameters: ApiPropertyTypeNullingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedGenericModelReferenceList>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiPropertyTypeNullingList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['cache'] != null) {
            queryParameters['cache'] = requestParameters['cache'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/property-type/{id}/nulling/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedGenericModelReferenceListFromJSON(jsonValue));
    }

    /**
     * get a paginated list of objects where the selected object will be removed whe its deleted
     */
    async apiPropertyTypeNullingList(requestParameters: ApiPropertyTypeNullingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedGenericModelReferenceList> {
        const response = await this.apiPropertyTypeNullingListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiPropertyTypePartialUpdateRaw(requestParameters: ApiPropertyTypePartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PropertyType>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiPropertyTypePartialUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/property-type/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedPropertyTypeToJSON(requestParameters['patchedPropertyType']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PropertyTypeFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiPropertyTypePartialUpdate(requestParameters: ApiPropertyTypePartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PropertyType> {
        const response = await this.apiPropertyTypePartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get a paginated list of objects that are protecting the selected object form being deleted
     */
    async apiPropertyTypeProtectingListRaw(requestParameters: ApiPropertyTypeProtectingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedGenericModelReferenceList>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiPropertyTypeProtectingList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['cache'] != null) {
            queryParameters['cache'] = requestParameters['cache'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/property-type/{id}/protecting/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedGenericModelReferenceListFromJSON(jsonValue));
    }

    /**
     * get a paginated list of objects that are protecting the selected object form being deleted
     */
    async apiPropertyTypeProtectingList(requestParameters: ApiPropertyTypeProtectingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedGenericModelReferenceList> {
        const response = await this.apiPropertyTypeProtectingListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiPropertyTypeRetrieveRaw(requestParameters: ApiPropertyTypeRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PropertyType>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiPropertyTypeRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/property-type/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PropertyTypeFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiPropertyTypeRetrieve(requestParameters: ApiPropertyTypeRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PropertyType> {
        const response = await this.apiPropertyTypeRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiPropertyTypeUpdateRaw(requestParameters: ApiPropertyTypeUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PropertyType>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiPropertyTypeUpdate().'
            );
        }

        if (requestParameters['propertyType'] == null) {
            throw new runtime.RequiredError(
                'propertyType',
                'Required parameter "propertyType" was null or undefined when calling apiPropertyTypeUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/property-type/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: PropertyTypeToJSON(requestParameters['propertyType']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PropertyTypeFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiPropertyTypeUpdate(requestParameters: ApiPropertyTypeUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PropertyType> {
        const response = await this.apiPropertyTypeUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiPropertyUpdateRaw(requestParameters: ApiPropertyUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Property>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiPropertyUpdate().'
            );
        }

        if (requestParameters['property'] == null) {
            throw new runtime.RequiredError(
                'property',
                'Required parameter "property" was null or undefined when calling apiPropertyUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/property/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: PropertyToJSON(requestParameters['property']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PropertyFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiPropertyUpdate(requestParameters: ApiPropertyUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Property> {
        const response = await this.apiPropertyUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipeAipropertiesCreateRaw(requestParameters: ApiRecipeAipropertiesCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Recipe>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiRecipeAipropertiesCreate().'
            );
        }

        if (requestParameters['recipe'] == null) {
            throw new runtime.RequiredError(
                'recipe',
                'Required parameter "recipe" was null or undefined when calling apiRecipeAipropertiesCreate().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['provider'] != null) {
            queryParameters['provider'] = requestParameters['provider'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/recipe/{id}/aiproperties/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RecipeToJSON(requestParameters['recipe']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RecipeFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipeAipropertiesCreate(requestParameters: ApiRecipeAipropertiesCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Recipe> {
        const response = await this.apiRecipeAipropertiesCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipeBatchUpdateUpdateRaw(requestParameters: ApiRecipeBatchUpdateUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RecipeBatchUpdate>> {
        if (requestParameters['recipeBatchUpdate'] == null) {
            throw new runtime.RequiredError(
                'recipeBatchUpdate',
                'Required parameter "recipeBatchUpdate" was null or undefined when calling apiRecipeBatchUpdateUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/recipe/batch_update/`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: RecipeBatchUpdateToJSON(requestParameters['recipeBatchUpdate']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RecipeBatchUpdateFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipeBatchUpdateUpdate(requestParameters: ApiRecipeBatchUpdateUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RecipeBatchUpdate> {
        const response = await this.apiRecipeBatchUpdateUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get a paginated list of objects that will be cascaded (deleted) when deleting the selected object
     */
    async apiRecipeBookCascadingListRaw(requestParameters: ApiRecipeBookCascadingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedGenericModelReferenceList>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiRecipeBookCascadingList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['cache'] != null) {
            queryParameters['cache'] = requestParameters['cache'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/recipe-book/{id}/cascading/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedGenericModelReferenceListFromJSON(jsonValue));
    }

    /**
     * get a paginated list of objects that will be cascaded (deleted) when deleting the selected object
     */
    async apiRecipeBookCascadingList(requestParameters: ApiRecipeBookCascadingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedGenericModelReferenceList> {
        const response = await this.apiRecipeBookCascadingListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipeBookCreateRaw(requestParameters: ApiRecipeBookCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RecipeBook>> {
        if (requestParameters['recipeBook'] == null) {
            throw new runtime.RequiredError(
                'recipeBook',
                'Required parameter "recipeBook" was null or undefined when calling apiRecipeBookCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/recipe-book/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RecipeBookToJSON(requestParameters['recipeBook']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RecipeBookFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipeBookCreate(requestParameters: ApiRecipeBookCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RecipeBook> {
        const response = await this.apiRecipeBookCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipeBookDestroyRaw(requestParameters: ApiRecipeBookDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiRecipeBookDestroy().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/recipe-book/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipeBookDestroy(requestParameters: ApiRecipeBookDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiRecipeBookDestroyRaw(requestParameters, initOverrides);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipeBookEntryCreateRaw(requestParameters: ApiRecipeBookEntryCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RecipeBookEntry>> {
        if (requestParameters['recipeBookEntry'] == null) {
            throw new runtime.RequiredError(
                'recipeBookEntry',
                'Required parameter "recipeBookEntry" was null or undefined when calling apiRecipeBookEntryCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/recipe-book-entry/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RecipeBookEntryToJSON(requestParameters['recipeBookEntry']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RecipeBookEntryFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipeBookEntryCreate(requestParameters: ApiRecipeBookEntryCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RecipeBookEntry> {
        const response = await this.apiRecipeBookEntryCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipeBookEntryDestroyRaw(requestParameters: ApiRecipeBookEntryDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiRecipeBookEntryDestroy().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/recipe-book-entry/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipeBookEntryDestroy(requestParameters: ApiRecipeBookEntryDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiRecipeBookEntryDestroyRaw(requestParameters, initOverrides);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipeBookEntryListRaw(requestParameters: ApiRecipeBookEntryListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedRecipeBookEntryList>> {
        const queryParameters: any = {};

        if (requestParameters['book'] != null) {
            queryParameters['book'] = requestParameters['book'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        if (requestParameters['recipe'] != null) {
            queryParameters['recipe'] = requestParameters['recipe'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/recipe-book-entry/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedRecipeBookEntryListFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipeBookEntryList(requestParameters: ApiRecipeBookEntryListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedRecipeBookEntryList> {
        const response = await this.apiRecipeBookEntryListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipeBookEntryPartialUpdateRaw(requestParameters: ApiRecipeBookEntryPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RecipeBookEntry>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiRecipeBookEntryPartialUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/recipe-book-entry/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedRecipeBookEntryToJSON(requestParameters['patchedRecipeBookEntry']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RecipeBookEntryFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipeBookEntryPartialUpdate(requestParameters: ApiRecipeBookEntryPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RecipeBookEntry> {
        const response = await this.apiRecipeBookEntryPartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipeBookEntryRetrieveRaw(requestParameters: ApiRecipeBookEntryRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RecipeBookEntry>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiRecipeBookEntryRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/recipe-book-entry/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RecipeBookEntryFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipeBookEntryRetrieve(requestParameters: ApiRecipeBookEntryRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RecipeBookEntry> {
        const response = await this.apiRecipeBookEntryRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipeBookEntryUpdateRaw(requestParameters: ApiRecipeBookEntryUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RecipeBookEntry>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiRecipeBookEntryUpdate().'
            );
        }

        if (requestParameters['recipeBookEntry'] == null) {
            throw new runtime.RequiredError(
                'recipeBookEntry',
                'Required parameter "recipeBookEntry" was null or undefined when calling apiRecipeBookEntryUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/recipe-book-entry/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: RecipeBookEntryToJSON(requestParameters['recipeBookEntry']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RecipeBookEntryFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipeBookEntryUpdate(requestParameters: ApiRecipeBookEntryUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RecipeBookEntry> {
        const response = await this.apiRecipeBookEntryUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipeBookListRaw(requestParameters: ApiRecipeBookListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedRecipeBookList>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['orderDirection'] != null) {
            queryParameters['order_direction'] = requestParameters['orderDirection'];
        }

        if (requestParameters['orderField'] != null) {
            queryParameters['order_field'] = requestParameters['orderField'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        if (requestParameters['query'] != null) {
            queryParameters['query'] = requestParameters['query'];
        }

        if (requestParameters['random'] != null) {
            queryParameters['random'] = requestParameters['random'];
        }

        if (requestParameters['updatedAt'] != null) {
            queryParameters['updated_at'] = requestParameters['updatedAt'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/recipe-book/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedRecipeBookListFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipeBookList(requestParameters: ApiRecipeBookListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedRecipeBookList> {
        const response = await this.apiRecipeBookListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get a paginated list of objects where the selected object will be removed whe its deleted
     */
    async apiRecipeBookNullingListRaw(requestParameters: ApiRecipeBookNullingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedGenericModelReferenceList>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiRecipeBookNullingList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['cache'] != null) {
            queryParameters['cache'] = requestParameters['cache'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/recipe-book/{id}/nulling/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedGenericModelReferenceListFromJSON(jsonValue));
    }

    /**
     * get a paginated list of objects where the selected object will be removed whe its deleted
     */
    async apiRecipeBookNullingList(requestParameters: ApiRecipeBookNullingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedGenericModelReferenceList> {
        const response = await this.apiRecipeBookNullingListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipeBookPartialUpdateRaw(requestParameters: ApiRecipeBookPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RecipeBook>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiRecipeBookPartialUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/recipe-book/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedRecipeBookToJSON(requestParameters['patchedRecipeBook']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RecipeBookFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipeBookPartialUpdate(requestParameters: ApiRecipeBookPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RecipeBook> {
        const response = await this.apiRecipeBookPartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get a paginated list of objects that are protecting the selected object form being deleted
     */
    async apiRecipeBookProtectingListRaw(requestParameters: ApiRecipeBookProtectingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedGenericModelReferenceList>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiRecipeBookProtectingList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['cache'] != null) {
            queryParameters['cache'] = requestParameters['cache'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/recipe-book/{id}/protecting/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedGenericModelReferenceListFromJSON(jsonValue));
    }

    /**
     * get a paginated list of objects that are protecting the selected object form being deleted
     */
    async apiRecipeBookProtectingList(requestParameters: ApiRecipeBookProtectingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedGenericModelReferenceList> {
        const response = await this.apiRecipeBookProtectingListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipeBookRetrieveRaw(requestParameters: ApiRecipeBookRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RecipeBook>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiRecipeBookRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/recipe-book/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RecipeBookFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipeBookRetrieve(requestParameters: ApiRecipeBookRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RecipeBook> {
        const response = await this.apiRecipeBookRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipeBookUpdateRaw(requestParameters: ApiRecipeBookUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RecipeBook>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiRecipeBookUpdate().'
            );
        }

        if (requestParameters['recipeBook'] == null) {
            throw new runtime.RequiredError(
                'recipeBook',
                'Required parameter "recipeBook" was null or undefined when calling apiRecipeBookUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/recipe-book/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: RecipeBookToJSON(requestParameters['recipeBook']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RecipeBookFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipeBookUpdate(requestParameters: ApiRecipeBookUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RecipeBook> {
        const response = await this.apiRecipeBookUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get a paginated list of objects that will be cascaded (deleted) when deleting the selected object
     */
    async apiRecipeCascadingListRaw(requestParameters: ApiRecipeCascadingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedGenericModelReferenceList>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiRecipeCascadingList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['cache'] != null) {
            queryParameters['cache'] = requestParameters['cache'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/recipe/{id}/cascading/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedGenericModelReferenceListFromJSON(jsonValue));
    }

    /**
     * get a paginated list of objects that will be cascaded (deleted) when deleting the selected object
     */
    async apiRecipeCascadingList(requestParameters: ApiRecipeCascadingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedGenericModelReferenceList> {
        const response = await this.apiRecipeCascadingListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipeCreateRaw(requestParameters: ApiRecipeCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Recipe>> {
        if (requestParameters['recipe'] == null) {
            throw new runtime.RequiredError(
                'recipe',
                'Required parameter "recipe" was null or undefined when calling apiRecipeCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/recipe/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RecipeToJSON(requestParameters['recipe']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RecipeFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipeCreate(requestParameters: ApiRecipeCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Recipe> {
        const response = await this.apiRecipeCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipeDeleteExternalPartialUpdateRaw(requestParameters: ApiRecipeDeleteExternalPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Recipe>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiRecipeDeleteExternalPartialUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/recipe/{id}/delete_external/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedRecipeToJSON(requestParameters['patchedRecipe']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RecipeFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipeDeleteExternalPartialUpdate(requestParameters: ApiRecipeDeleteExternalPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Recipe> {
        const response = await this.apiRecipeDeleteExternalPartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipeDestroyRaw(requestParameters: ApiRecipeDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiRecipeDestroy().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/recipe/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipeDestroy(requestParameters: ApiRecipeDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiRecipeDestroyRaw(requestParameters, initOverrides);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipeFlatListRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<RecipeFlat>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/recipe/flat/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(RecipeFlatFromJSON));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipeFlatList(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<RecipeFlat>> {
        const response = await this.apiRecipeFlatListRaw(initOverrides);
        return await response.value();
    }

    /**
     * function to retrieve a recipe from a given url or source string :param request: standard request with additional post parameters         - url: url to use for importing recipe         - data: if no url is given recipe is imported from provided source data         - (optional) bookmarklet: id of bookmarklet import to use, overrides URL and data attributes :return: JsonResponse containing the parsed json and images
     */
    async apiRecipeFromSourceCreateRaw(requestParameters: ApiRecipeFromSourceCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RecipeFromSourceResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/recipe-from-source/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RecipeFromSourceToJSON(requestParameters['recipeFromSource']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RecipeFromSourceResponseFromJSON(jsonValue));
    }

    /**
     * function to retrieve a recipe from a given url or source string :param request: standard request with additional post parameters         - url: url to use for importing recipe         - data: if no url is given recipe is imported from provided source data         - (optional) bookmarklet: id of bookmarklet import to use, overrides URL and data attributes :return: JsonResponse containing the parsed json and images
     */
    async apiRecipeFromSourceCreate(requestParameters: ApiRecipeFromSourceCreateRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RecipeFromSourceResponse> {
        const response = await this.apiRecipeFromSourceCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipeImageUpdateRaw(requestParameters: ApiRecipeImageUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RecipeImage>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiRecipeImageUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['image'] != null) {
            formParams.append('image', requestParameters['image'] as any);
        }

        if (requestParameters['imageUrl'] != null) {
            formParams.append('image_url', requestParameters['imageUrl'] as any);
        }

        const response = await this.request({
            path: `/api/recipe/{id}/image/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RecipeImageFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipeImageUpdate(requestParameters: ApiRecipeImageUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RecipeImage> {
        const response = await this.apiRecipeImageUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipeImportCreateRaw(requestParameters: ApiRecipeImportCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RecipeImport>> {
        if (requestParameters['recipeImport'] == null) {
            throw new runtime.RequiredError(
                'recipeImport',
                'Required parameter "recipeImport" was null or undefined when calling apiRecipeImportCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/recipe-import/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RecipeImportToJSON(requestParameters['recipeImport']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RecipeImportFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipeImportCreate(requestParameters: ApiRecipeImportCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RecipeImport> {
        const response = await this.apiRecipeImportCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipeImportDestroyRaw(requestParameters: ApiRecipeImportDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiRecipeImportDestroy().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/recipe-import/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipeImportDestroy(requestParameters: ApiRecipeImportDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiRecipeImportDestroyRaw(requestParameters, initOverrides);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipeImportImportAllCreateRaw(requestParameters: ApiRecipeImportImportAllCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RecipeImport>> {
        if (requestParameters['recipeImport'] == null) {
            throw new runtime.RequiredError(
                'recipeImport',
                'Required parameter "recipeImport" was null or undefined when calling apiRecipeImportImportAllCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/recipe-import/import_all/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RecipeImportToJSON(requestParameters['recipeImport']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RecipeImportFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipeImportImportAllCreate(requestParameters: ApiRecipeImportImportAllCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RecipeImport> {
        const response = await this.apiRecipeImportImportAllCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipeImportImportRecipeCreateRaw(requestParameters: ApiRecipeImportImportRecipeCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Recipe>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiRecipeImportImportRecipeCreate().'
            );
        }

        if (requestParameters['recipeImport'] == null) {
            throw new runtime.RequiredError(
                'recipeImport',
                'Required parameter "recipeImport" was null or undefined when calling apiRecipeImportImportRecipeCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/recipe-import/{id}/import_recipe/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RecipeImportToJSON(requestParameters['recipeImport']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RecipeFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipeImportImportRecipeCreate(requestParameters: ApiRecipeImportImportRecipeCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Recipe> {
        const response = await this.apiRecipeImportImportRecipeCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipeImportListRaw(requestParameters: ApiRecipeImportListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedRecipeImportList>> {
        const queryParameters: any = {};

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/recipe-import/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedRecipeImportListFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipeImportList(requestParameters: ApiRecipeImportListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedRecipeImportList> {
        const response = await this.apiRecipeImportListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipeImportPartialUpdateRaw(requestParameters: ApiRecipeImportPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RecipeImport>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiRecipeImportPartialUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/recipe-import/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedRecipeImportToJSON(requestParameters['patchedRecipeImport']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RecipeImportFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipeImportPartialUpdate(requestParameters: ApiRecipeImportPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RecipeImport> {
        const response = await this.apiRecipeImportPartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipeImportRetrieveRaw(requestParameters: ApiRecipeImportRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RecipeImport>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiRecipeImportRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/recipe-import/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RecipeImportFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipeImportRetrieve(requestParameters: ApiRecipeImportRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RecipeImport> {
        const response = await this.apiRecipeImportRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipeImportUpdateRaw(requestParameters: ApiRecipeImportUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RecipeImport>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiRecipeImportUpdate().'
            );
        }

        if (requestParameters['recipeImport'] == null) {
            throw new runtime.RequiredError(
                'recipeImport',
                'Required parameter "recipeImport" was null or undefined when calling apiRecipeImportUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/recipe-import/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: RecipeImportToJSON(requestParameters['recipeImport']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RecipeImportFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipeImportUpdate(requestParameters: ApiRecipeImportUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RecipeImport> {
        const response = await this.apiRecipeImportUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipeListRaw(requestParameters: ApiRecipeListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedRecipeOverviewList>> {
        const queryParameters: any = {};

        if (requestParameters['books'] != null) {
            queryParameters['books'] = requestParameters['books'];
        }

        if (requestParameters['booksAnd'] != null) {
            queryParameters['books_and'] = requestParameters['booksAnd'];
        }

        if (requestParameters['booksAndNot'] != null) {
            queryParameters['books_and_not'] = requestParameters['booksAndNot'];
        }

        if (requestParameters['booksOr'] != null) {
            queryParameters['books_or'] = requestParameters['booksOr'];
        }

        if (requestParameters['booksOrNot'] != null) {
            queryParameters['books_or_not'] = requestParameters['booksOrNot'];
        }

        if (requestParameters['cookedonGte'] != null) {
            queryParameters['cookedon_gte'] = (requestParameters['cookedonGte'] as any).toISOString().substring(0,10);
        }

        if (requestParameters['cookedonLte'] != null) {
            queryParameters['cookedon_lte'] = (requestParameters['cookedonLte'] as any).toISOString().substring(0,10);
        }

        if (requestParameters['createdby'] != null) {
            queryParameters['createdby'] = requestParameters['createdby'];
        }

        if (requestParameters['createdon'] != null) {
            queryParameters['createdon'] = (requestParameters['createdon'] as any).toISOString().substring(0,10);
        }

        if (requestParameters['createdonGte'] != null) {
            queryParameters['createdon_gte'] = (requestParameters['createdonGte'] as any).toISOString().substring(0,10);
        }

        if (requestParameters['createdonLte'] != null) {
            queryParameters['createdon_lte'] = (requestParameters['createdonLte'] as any).toISOString().substring(0,10);
        }

        if (requestParameters['filter'] != null) {
            queryParameters['filter'] = requestParameters['filter'];
        }

        if (requestParameters['foods'] != null) {
            queryParameters['foods'] = requestParameters['foods'];
        }

        if (requestParameters['foodsAnd'] != null) {
            queryParameters['foods_and'] = requestParameters['foodsAnd'];
        }

        if (requestParameters['foodsAndNot'] != null) {
            queryParameters['foods_and_not'] = requestParameters['foodsAndNot'];
        }

        if (requestParameters['foodsOr'] != null) {
            queryParameters['foods_or'] = requestParameters['foodsOr'];
        }

        if (requestParameters['foodsOrNot'] != null) {
            queryParameters['foods_or_not'] = requestParameters['foodsOrNot'];
        }

        if (requestParameters['includeChildren'] != null) {
            queryParameters['include_children'] = requestParameters['includeChildren'];
        }

        if (requestParameters['internal'] != null) {
            queryParameters['internal'] = requestParameters['internal'];
        }

        if (requestParameters['keywords'] != null) {
            queryParameters['keywords'] = requestParameters['keywords'];
        }

        if (requestParameters['keywordsAnd'] != null) {
            queryParameters['keywords_and'] = requestParameters['keywordsAnd'];
        }

        if (requestParameters['keywordsAndNot'] != null) {
            queryParameters['keywords_and_not'] = requestParameters['keywordsAndNot'];
        }

        if (requestParameters['keywordsOr'] != null) {
            queryParameters['keywords_or'] = requestParameters['keywordsOr'];
        }

        if (requestParameters['keywordsOrNot'] != null) {
            queryParameters['keywords_or_not'] = requestParameters['keywordsOrNot'];
        }

        if (requestParameters['makenow'] != null) {
            queryParameters['makenow'] = requestParameters['makenow'];
        }

        if (requestParameters['_new'] != null) {
            queryParameters['new'] = requestParameters['_new'];
        }

        if (requestParameters['numRecent'] != null) {
            queryParameters['num_recent'] = requestParameters['numRecent'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        if (requestParameters['query'] != null) {
            queryParameters['query'] = requestParameters['query'];
        }

        if (requestParameters['random'] != null) {
            queryParameters['random'] = requestParameters['random'];
        }

        if (requestParameters['rating'] != null) {
            queryParameters['rating'] = requestParameters['rating'];
        }

        if (requestParameters['ratingGte'] != null) {
            queryParameters['rating_gte'] = requestParameters['ratingGte'];
        }

        if (requestParameters['ratingLte'] != null) {
            queryParameters['rating_lte'] = requestParameters['ratingLte'];
        }

        if (requestParameters['sortOrder'] != null) {
            queryParameters['sort_order'] = requestParameters['sortOrder'];
        }

        if (requestParameters['timescooked'] != null) {
            queryParameters['timescooked'] = requestParameters['timescooked'];
        }

        if (requestParameters['timescookedGte'] != null) {
            queryParameters['timescooked_gte'] = requestParameters['timescookedGte'];
        }

        if (requestParameters['timescookedLte'] != null) {
            queryParameters['timescooked_lte'] = requestParameters['timescookedLte'];
        }

        if (requestParameters['units'] != null) {
            queryParameters['units'] = requestParameters['units'];
        }

        if (requestParameters['updatedon'] != null) {
            queryParameters['updatedon'] = (requestParameters['updatedon'] as any).toISOString().substring(0,10);
        }

        if (requestParameters['updatedonGte'] != null) {
            queryParameters['updatedon_gte'] = (requestParameters['updatedonGte'] as any).toISOString().substring(0,10);
        }

        if (requestParameters['updatedonLte'] != null) {
            queryParameters['updatedon_lte'] = (requestParameters['updatedonLte'] as any).toISOString().substring(0,10);
        }

        if (requestParameters['viewedonGte'] != null) {
            queryParameters['viewedon_gte'] = (requestParameters['viewedonGte'] as any).toISOString().substring(0,10);
        }

        if (requestParameters['viewedonLte'] != null) {
            queryParameters['viewedon_lte'] = (requestParameters['viewedonLte'] as any).toISOString().substring(0,10);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/recipe/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedRecipeOverviewListFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipeList(requestParameters: ApiRecipeListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedRecipeOverviewList> {
        const response = await this.apiRecipeListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get a paginated list of objects where the selected object will be removed whe its deleted
     */
    async apiRecipeNullingListRaw(requestParameters: ApiRecipeNullingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedGenericModelReferenceList>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiRecipeNullingList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['cache'] != null) {
            queryParameters['cache'] = requestParameters['cache'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/recipe/{id}/nulling/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedGenericModelReferenceListFromJSON(jsonValue));
    }

    /**
     * get a paginated list of objects where the selected object will be removed whe its deleted
     */
    async apiRecipeNullingList(requestParameters: ApiRecipeNullingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedGenericModelReferenceList> {
        const response = await this.apiRecipeNullingListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipePartialUpdateRaw(requestParameters: ApiRecipePartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Recipe>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiRecipePartialUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/recipe/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedRecipeToJSON(requestParameters['patchedRecipe']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RecipeFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipePartialUpdate(requestParameters: ApiRecipePartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Recipe> {
        const response = await this.apiRecipePartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get a paginated list of objects that are protecting the selected object form being deleted
     */
    async apiRecipeProtectingListRaw(requestParameters: ApiRecipeProtectingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedGenericModelReferenceList>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiRecipeProtectingList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['cache'] != null) {
            queryParameters['cache'] = requestParameters['cache'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/recipe/{id}/protecting/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedGenericModelReferenceListFromJSON(jsonValue));
    }

    /**
     * get a paginated list of objects that are protecting the selected object form being deleted
     */
    async apiRecipeProtectingList(requestParameters: ApiRecipeProtectingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedGenericModelReferenceList> {
        const response = await this.apiRecipeProtectingListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipeRelatedListRaw(requestParameters: ApiRecipeRelatedListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<RecipeSimple>>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiRecipeRelatedList().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/recipe/{id}/related/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(RecipeSimpleFromJSON));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipeRelatedList(requestParameters: ApiRecipeRelatedListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<RecipeSimple>> {
        const response = await this.apiRecipeRelatedListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipeRetrieveRaw(requestParameters: ApiRecipeRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Recipe>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiRecipeRetrieve().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['share'] != null) {
            queryParameters['share'] = requestParameters['share'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/recipe/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RecipeFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipeRetrieve(requestParameters: ApiRecipeRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Recipe> {
        const response = await this.apiRecipeRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipeShoppingUpdateRaw(requestParameters: ApiRecipeShoppingUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RecipeShoppingUpdate>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiRecipeShoppingUpdate().'
            );
        }

        if (requestParameters['recipeShoppingUpdate'] == null) {
            throw new runtime.RequiredError(
                'recipeShoppingUpdate',
                'Required parameter "recipeShoppingUpdate" was null or undefined when calling apiRecipeShoppingUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/recipe/{id}/shopping/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: RecipeShoppingUpdateToJSON(requestParameters['recipeShoppingUpdate']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RecipeShoppingUpdateFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipeShoppingUpdate(requestParameters: ApiRecipeShoppingUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RecipeShoppingUpdate> {
        const response = await this.apiRecipeShoppingUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipeUpdateRaw(requestParameters: ApiRecipeUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Recipe>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiRecipeUpdate().'
            );
        }

        if (requestParameters['recipe'] == null) {
            throw new runtime.RequiredError(
                'recipe',
                'Required parameter "recipe" was null or undefined when calling apiRecipeUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/recipe/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: RecipeToJSON(requestParameters['recipe']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RecipeFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiRecipeUpdate(requestParameters: ApiRecipeUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Recipe> {
        const response = await this.apiRecipeUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * function to reset inheritance from api, see food method for docs
     */
    async apiResetFoodInheritanceCreateRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/reset-food-inheritance/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * function to reset inheritance from api, see food method for docs
     */
    async apiResetFoodInheritanceCreate(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiResetFoodInheritanceCreateRaw(initOverrides);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSearchFieldsListRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<SearchFields>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/search-fields/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(SearchFieldsFromJSON));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSearchFieldsList(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<SearchFields>> {
        const response = await this.apiSearchFieldsListRaw(initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSearchFieldsRetrieveRaw(requestParameters: ApiSearchFieldsRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SearchFields>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiSearchFieldsRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/search-fields/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SearchFieldsFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSearchFieldsRetrieve(requestParameters: ApiSearchFieldsRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SearchFields> {
        const response = await this.apiSearchFieldsRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSearchPreferenceListRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<SearchPreference>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/search-preference/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(SearchPreferenceFromJSON));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSearchPreferenceList(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<SearchPreference>> {
        const response = await this.apiSearchPreferenceListRaw(initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSearchPreferencePartialUpdateRaw(requestParameters: ApiSearchPreferencePartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SearchPreference>> {
        if (requestParameters['user'] == null) {
            throw new runtime.RequiredError(
                'user',
                'Required parameter "user" was null or undefined when calling apiSearchPreferencePartialUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/search-preference/{user}/`.replace(`{${"user"}}`, encodeURIComponent(String(requestParameters['user']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedSearchPreferenceToJSON(requestParameters['patchedSearchPreference']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SearchPreferenceFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSearchPreferencePartialUpdate(requestParameters: ApiSearchPreferencePartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SearchPreference> {
        const response = await this.apiSearchPreferencePartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSearchPreferenceRetrieveRaw(requestParameters: ApiSearchPreferenceRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SearchPreference>> {
        if (requestParameters['user'] == null) {
            throw new runtime.RequiredError(
                'user',
                'Required parameter "user" was null or undefined when calling apiSearchPreferenceRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/search-preference/{user}/`.replace(`{${"user"}}`, encodeURIComponent(String(requestParameters['user']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SearchPreferenceFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSearchPreferenceRetrieve(requestParameters: ApiSearchPreferenceRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SearchPreference> {
        const response = await this.apiSearchPreferenceRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async apiServerSettingsCurrentRetrieveRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ServerSettings>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/server-settings/current/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ServerSettingsFromJSON(jsonValue));
    }

    /**
     */
    async apiServerSettingsCurrentRetrieve(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ServerSettings> {
        const response = await this.apiServerSettingsCurrentRetrieveRaw(initOverrides);
        return await response.value();
    }

    /**
     */
    async apiShareLinkRetrieveRaw(requestParameters: ApiShareLinkRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ShareLink>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiShareLinkRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/share-link/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ShareLinkFromJSON(jsonValue));
    }

    /**
     */
    async apiShareLinkRetrieve(requestParameters: ApiShareLinkRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ShareLink> {
        const response = await this.apiShareLinkRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get a paginated list of objects that will be cascaded (deleted) when deleting the selected object
     */
    async apiShoppingListCascadingListRaw(requestParameters: ApiShoppingListCascadingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedGenericModelReferenceList>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiShoppingListCascadingList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['cache'] != null) {
            queryParameters['cache'] = requestParameters['cache'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/shopping-list/{id}/cascading/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedGenericModelReferenceListFromJSON(jsonValue));
    }

    /**
     * get a paginated list of objects that will be cascaded (deleted) when deleting the selected object
     */
    async apiShoppingListCascadingList(requestParameters: ApiShoppingListCascadingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedGenericModelReferenceList> {
        const response = await this.apiShoppingListCascadingListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiShoppingListCreateRaw(requestParameters: ApiShoppingListCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ShoppingList>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/shopping-list/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ShoppingListToJSON(requestParameters['shoppingList']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ShoppingListFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiShoppingListCreate(requestParameters: ApiShoppingListCreateRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ShoppingList> {
        const response = await this.apiShoppingListCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiShoppingListDestroyRaw(requestParameters: ApiShoppingListDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiShoppingListDestroy().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/shopping-list/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiShoppingListDestroy(requestParameters: ApiShoppingListDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiShoppingListDestroyRaw(requestParameters, initOverrides);
    }

    /**
     * individual entries of a shopping list automatically filtered to only contain unchecked items that are not older than the shopping recent days setting to not bloat endpoint
     */
    async apiShoppingListEntryBulkCreateRaw(requestParameters: ApiShoppingListEntryBulkCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ShoppingListEntryBulk>> {
        if (requestParameters['shoppingListEntryBulk'] == null) {
            throw new runtime.RequiredError(
                'shoppingListEntryBulk',
                'Required parameter "shoppingListEntryBulk" was null or undefined when calling apiShoppingListEntryBulkCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/shopping-list-entry/bulk/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ShoppingListEntryBulkToJSON(requestParameters['shoppingListEntryBulk']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ShoppingListEntryBulkFromJSON(jsonValue));
    }

    /**
     * individual entries of a shopping list automatically filtered to only contain unchecked items that are not older than the shopping recent days setting to not bloat endpoint
     */
    async apiShoppingListEntryBulkCreate(requestParameters: ApiShoppingListEntryBulkCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ShoppingListEntryBulk> {
        const response = await this.apiShoppingListEntryBulkCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * individual entries of a shopping list automatically filtered to only contain unchecked items that are not older than the shopping recent days setting to not bloat endpoint
     */
    async apiShoppingListEntryCreateRaw(requestParameters: ApiShoppingListEntryCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ShoppingListEntry>> {
        if (requestParameters['shoppingListEntry'] == null) {
            throw new runtime.RequiredError(
                'shoppingListEntry',
                'Required parameter "shoppingListEntry" was null or undefined when calling apiShoppingListEntryCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/shopping-list-entry/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ShoppingListEntryToJSON(requestParameters['shoppingListEntry']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ShoppingListEntryFromJSON(jsonValue));
    }

    /**
     * individual entries of a shopping list automatically filtered to only contain unchecked items that are not older than the shopping recent days setting to not bloat endpoint
     */
    async apiShoppingListEntryCreate(requestParameters: ApiShoppingListEntryCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ShoppingListEntry> {
        const response = await this.apiShoppingListEntryCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * individual entries of a shopping list automatically filtered to only contain unchecked items that are not older than the shopping recent days setting to not bloat endpoint
     */
    async apiShoppingListEntryDestroyRaw(requestParameters: ApiShoppingListEntryDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiShoppingListEntryDestroy().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/shopping-list-entry/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * individual entries of a shopping list automatically filtered to only contain unchecked items that are not older than the shopping recent days setting to not bloat endpoint
     */
    async apiShoppingListEntryDestroy(requestParameters: ApiShoppingListEntryDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiShoppingListEntryDestroyRaw(requestParameters, initOverrides);
    }

    /**
     * individual entries of a shopping list automatically filtered to only contain unchecked items that are not older than the shopping recent days setting to not bloat endpoint
     */
    async apiShoppingListEntryListRaw(requestParameters: ApiShoppingListEntryListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedShoppingListEntryList>> {
        const queryParameters: any = {};

        if (requestParameters['mealplan'] != null) {
            queryParameters['mealplan'] = requestParameters['mealplan'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        if (requestParameters['updatedAfter'] != null) {
            queryParameters['updated_after'] = (requestParameters['updatedAfter'] as any).toISOString();
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/shopping-list-entry/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedShoppingListEntryListFromJSON(jsonValue));
    }

    /**
     * individual entries of a shopping list automatically filtered to only contain unchecked items that are not older than the shopping recent days setting to not bloat endpoint
     */
    async apiShoppingListEntryList(requestParameters: ApiShoppingListEntryListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedShoppingListEntryList> {
        const response = await this.apiShoppingListEntryListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * individual entries of a shopping list automatically filtered to only contain unchecked items that are not older than the shopping recent days setting to not bloat endpoint
     */
    async apiShoppingListEntryPartialUpdateRaw(requestParameters: ApiShoppingListEntryPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ShoppingListEntry>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiShoppingListEntryPartialUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/shopping-list-entry/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedShoppingListEntryToJSON(requestParameters['patchedShoppingListEntry']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ShoppingListEntryFromJSON(jsonValue));
    }

    /**
     * individual entries of a shopping list automatically filtered to only contain unchecked items that are not older than the shopping recent days setting to not bloat endpoint
     */
    async apiShoppingListEntryPartialUpdate(requestParameters: ApiShoppingListEntryPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ShoppingListEntry> {
        const response = await this.apiShoppingListEntryPartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * individual entries of a shopping list automatically filtered to only contain unchecked items that are not older than the shopping recent days setting to not bloat endpoint
     */
    async apiShoppingListEntryRetrieveRaw(requestParameters: ApiShoppingListEntryRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ShoppingListEntry>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiShoppingListEntryRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/shopping-list-entry/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ShoppingListEntryFromJSON(jsonValue));
    }

    /**
     * individual entries of a shopping list automatically filtered to only contain unchecked items that are not older than the shopping recent days setting to not bloat endpoint
     */
    async apiShoppingListEntryRetrieve(requestParameters: ApiShoppingListEntryRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ShoppingListEntry> {
        const response = await this.apiShoppingListEntryRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * individual entries of a shopping list automatically filtered to only contain unchecked items that are not older than the shopping recent days setting to not bloat endpoint
     */
    async apiShoppingListEntryUpdateRaw(requestParameters: ApiShoppingListEntryUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ShoppingListEntry>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiShoppingListEntryUpdate().'
            );
        }

        if (requestParameters['shoppingListEntry'] == null) {
            throw new runtime.RequiredError(
                'shoppingListEntry',
                'Required parameter "shoppingListEntry" was null or undefined when calling apiShoppingListEntryUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/shopping-list-entry/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ShoppingListEntryToJSON(requestParameters['shoppingListEntry']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ShoppingListEntryFromJSON(jsonValue));
    }

    /**
     * individual entries of a shopping list automatically filtered to only contain unchecked items that are not older than the shopping recent days setting to not bloat endpoint
     */
    async apiShoppingListEntryUpdate(requestParameters: ApiShoppingListEntryUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ShoppingListEntry> {
        const response = await this.apiShoppingListEntryUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiShoppingListListRaw(requestParameters: ApiShoppingListListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedShoppingListList>> {
        const queryParameters: any = {};

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/shopping-list/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedShoppingListListFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiShoppingListList(requestParameters: ApiShoppingListListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedShoppingListList> {
        const response = await this.apiShoppingListListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get a paginated list of objects where the selected object will be removed whe its deleted
     */
    async apiShoppingListNullingListRaw(requestParameters: ApiShoppingListNullingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedGenericModelReferenceList>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiShoppingListNullingList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['cache'] != null) {
            queryParameters['cache'] = requestParameters['cache'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/shopping-list/{id}/nulling/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedGenericModelReferenceListFromJSON(jsonValue));
    }

    /**
     * get a paginated list of objects where the selected object will be removed whe its deleted
     */
    async apiShoppingListNullingList(requestParameters: ApiShoppingListNullingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedGenericModelReferenceList> {
        const response = await this.apiShoppingListNullingListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiShoppingListPartialUpdateRaw(requestParameters: ApiShoppingListPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ShoppingList>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiShoppingListPartialUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/shopping-list/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedShoppingListToJSON(requestParameters['patchedShoppingList']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ShoppingListFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiShoppingListPartialUpdate(requestParameters: ApiShoppingListPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ShoppingList> {
        const response = await this.apiShoppingListPartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get a paginated list of objects that are protecting the selected object form being deleted
     */
    async apiShoppingListProtectingListRaw(requestParameters: ApiShoppingListProtectingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedGenericModelReferenceList>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiShoppingListProtectingList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['cache'] != null) {
            queryParameters['cache'] = requestParameters['cache'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/shopping-list/{id}/protecting/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedGenericModelReferenceListFromJSON(jsonValue));
    }

    /**
     * get a paginated list of objects that are protecting the selected object form being deleted
     */
    async apiShoppingListProtectingList(requestParameters: ApiShoppingListProtectingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedGenericModelReferenceList> {
        const response = await this.apiShoppingListProtectingListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiShoppingListRecipeBulkCreateEntriesCreateRaw(requestParameters: ApiShoppingListRecipeBulkCreateEntriesCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ShoppingListEntryBulkCreate>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiShoppingListRecipeBulkCreateEntriesCreate().'
            );
        }

        if (requestParameters['shoppingListEntryBulkCreate'] == null) {
            throw new runtime.RequiredError(
                'shoppingListEntryBulkCreate',
                'Required parameter "shoppingListEntryBulkCreate" was null or undefined when calling apiShoppingListRecipeBulkCreateEntriesCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/shopping-list-recipe/{id}/bulk_create_entries/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ShoppingListEntryBulkCreateToJSON(requestParameters['shoppingListEntryBulkCreate']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ShoppingListEntryBulkCreateFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiShoppingListRecipeBulkCreateEntriesCreate(requestParameters: ApiShoppingListRecipeBulkCreateEntriesCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ShoppingListEntryBulkCreate> {
        const response = await this.apiShoppingListRecipeBulkCreateEntriesCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiShoppingListRecipeCreateRaw(requestParameters: ApiShoppingListRecipeCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ShoppingListRecipe>> {
        if (requestParameters['shoppingListRecipe'] == null) {
            throw new runtime.RequiredError(
                'shoppingListRecipe',
                'Required parameter "shoppingListRecipe" was null or undefined when calling apiShoppingListRecipeCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/shopping-list-recipe/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ShoppingListRecipeToJSON(requestParameters['shoppingListRecipe']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ShoppingListRecipeFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiShoppingListRecipeCreate(requestParameters: ApiShoppingListRecipeCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ShoppingListRecipe> {
        const response = await this.apiShoppingListRecipeCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiShoppingListRecipeDestroyRaw(requestParameters: ApiShoppingListRecipeDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiShoppingListRecipeDestroy().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/shopping-list-recipe/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiShoppingListRecipeDestroy(requestParameters: ApiShoppingListRecipeDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiShoppingListRecipeDestroyRaw(requestParameters, initOverrides);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiShoppingListRecipeListRaw(requestParameters: ApiShoppingListRecipeListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedShoppingListRecipeList>> {
        const queryParameters: any = {};

        if (requestParameters['mealplan'] != null) {
            queryParameters['mealplan'] = requestParameters['mealplan'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/shopping-list-recipe/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedShoppingListRecipeListFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiShoppingListRecipeList(requestParameters: ApiShoppingListRecipeListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedShoppingListRecipeList> {
        const response = await this.apiShoppingListRecipeListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiShoppingListRecipePartialUpdateRaw(requestParameters: ApiShoppingListRecipePartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ShoppingListRecipe>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiShoppingListRecipePartialUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/shopping-list-recipe/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedShoppingListRecipeToJSON(requestParameters['patchedShoppingListRecipe']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ShoppingListRecipeFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiShoppingListRecipePartialUpdate(requestParameters: ApiShoppingListRecipePartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ShoppingListRecipe> {
        const response = await this.apiShoppingListRecipePartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiShoppingListRecipeRetrieveRaw(requestParameters: ApiShoppingListRecipeRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ShoppingListRecipe>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiShoppingListRecipeRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/shopping-list-recipe/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ShoppingListRecipeFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiShoppingListRecipeRetrieve(requestParameters: ApiShoppingListRecipeRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ShoppingListRecipe> {
        const response = await this.apiShoppingListRecipeRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiShoppingListRecipeUpdateRaw(requestParameters: ApiShoppingListRecipeUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ShoppingListRecipe>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiShoppingListRecipeUpdate().'
            );
        }

        if (requestParameters['shoppingListRecipe'] == null) {
            throw new runtime.RequiredError(
                'shoppingListRecipe',
                'Required parameter "shoppingListRecipe" was null or undefined when calling apiShoppingListRecipeUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/shopping-list-recipe/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ShoppingListRecipeToJSON(requestParameters['shoppingListRecipe']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ShoppingListRecipeFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiShoppingListRecipeUpdate(requestParameters: ApiShoppingListRecipeUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ShoppingListRecipe> {
        const response = await this.apiShoppingListRecipeUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiShoppingListRetrieveRaw(requestParameters: ApiShoppingListRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ShoppingList>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiShoppingListRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/shopping-list/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ShoppingListFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiShoppingListRetrieve(requestParameters: ApiShoppingListRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ShoppingList> {
        const response = await this.apiShoppingListRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiShoppingListUpdateRaw(requestParameters: ApiShoppingListUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ShoppingList>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiShoppingListUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/shopping-list/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ShoppingListToJSON(requestParameters['shoppingList']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ShoppingListFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiShoppingListUpdate(requestParameters: ApiShoppingListUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ShoppingList> {
        const response = await this.apiShoppingListUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSpaceCreateRaw(requestParameters: ApiSpaceCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Space>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/space/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SpaceToJSON(requestParameters['space']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SpaceFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSpaceCreate(requestParameters: ApiSpaceCreateRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Space> {
        const response = await this.apiSpaceCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSpaceCurrentRetrieveRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Space>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/space/current/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SpaceFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSpaceCurrentRetrieve(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Space> {
        const response = await this.apiSpaceCurrentRetrieveRaw(initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSpaceListRaw(requestParameters: ApiSpaceListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedSpaceList>> {
        const queryParameters: any = {};

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/space/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedSpaceListFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSpaceList(requestParameters: ApiSpaceListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedSpaceList> {
        const response = await this.apiSpaceListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSpacePartialUpdateRaw(requestParameters: ApiSpacePartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Space>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiSpacePartialUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/space/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedSpaceToJSON(requestParameters['patchedSpace']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SpaceFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSpacePartialUpdate(requestParameters: ApiSpacePartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Space> {
        const response = await this.apiSpacePartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSpaceRetrieveRaw(requestParameters: ApiSpaceRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Space>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiSpaceRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/space/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SpaceFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSpaceRetrieve(requestParameters: ApiSpaceRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Space> {
        const response = await this.apiSpaceRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSpaceUpdateRaw(requestParameters: ApiSpaceUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Space>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiSpaceUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/space/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: SpaceToJSON(requestParameters['space']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SpaceFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSpaceUpdate(requestParameters: ApiSpaceUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Space> {
        const response = await this.apiSpaceUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiStepCreateRaw(requestParameters: ApiStepCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Step>> {
        if (requestParameters['step'] == null) {
            throw new runtime.RequiredError(
                'step',
                'Required parameter "step" was null or undefined when calling apiStepCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/step/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: StepToJSON(requestParameters['step']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StepFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiStepCreate(requestParameters: ApiStepCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Step> {
        const response = await this.apiStepCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiStepDestroyRaw(requestParameters: ApiStepDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiStepDestroy().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/step/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiStepDestroy(requestParameters: ApiStepDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiStepDestroyRaw(requestParameters, initOverrides);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiStepListRaw(requestParameters: ApiStepListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedStepList>> {
        const queryParameters: any = {};

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        if (requestParameters['query'] != null) {
            queryParameters['query'] = requestParameters['query'];
        }

        if (requestParameters['recipe'] != null) {
            queryParameters['recipe'] = requestParameters['recipe'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/step/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedStepListFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiStepList(requestParameters: ApiStepListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedStepList> {
        const response = await this.apiStepListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiStepPartialUpdateRaw(requestParameters: ApiStepPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Step>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiStepPartialUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/step/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedStepToJSON(requestParameters['patchedStep']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StepFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiStepPartialUpdate(requestParameters: ApiStepPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Step> {
        const response = await this.apiStepPartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiStepRetrieveRaw(requestParameters: ApiStepRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Step>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiStepRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/step/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StepFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiStepRetrieve(requestParameters: ApiStepRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Step> {
        const response = await this.apiStepRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiStepUpdateRaw(requestParameters: ApiStepUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Step>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiStepUpdate().'
            );
        }

        if (requestParameters['step'] == null) {
            throw new runtime.RequiredError(
                'step',
                'Required parameter "step" was null or undefined when calling apiStepUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/step/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: StepToJSON(requestParameters['step']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StepFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiStepUpdate(requestParameters: ApiStepUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Step> {
        const response = await this.apiStepUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get a paginated list of objects that will be cascaded (deleted) when deleting the selected object
     */
    async apiStorageCascadingListRaw(requestParameters: ApiStorageCascadingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedGenericModelReferenceList>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiStorageCascadingList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['cache'] != null) {
            queryParameters['cache'] = requestParameters['cache'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/storage/{id}/cascading/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedGenericModelReferenceListFromJSON(jsonValue));
    }

    /**
     * get a paginated list of objects that will be cascaded (deleted) when deleting the selected object
     */
    async apiStorageCascadingList(requestParameters: ApiStorageCascadingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedGenericModelReferenceList> {
        const response = await this.apiStorageCascadingListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiStorageCreateRaw(requestParameters: ApiStorageCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Storage>> {
        if (requestParameters['storage'] == null) {
            throw new runtime.RequiredError(
                'storage',
                'Required parameter "storage" was null or undefined when calling apiStorageCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/storage/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: StorageToJSON(requestParameters['storage']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiStorageCreate(requestParameters: ApiStorageCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Storage> {
        const response = await this.apiStorageCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiStorageDestroyRaw(requestParameters: ApiStorageDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiStorageDestroy().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/storage/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiStorageDestroy(requestParameters: ApiStorageDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiStorageDestroyRaw(requestParameters, initOverrides);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiStorageListRaw(requestParameters: ApiStorageListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedStorageList>> {
        const queryParameters: any = {};

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/storage/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedStorageListFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiStorageList(requestParameters: ApiStorageListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedStorageList> {
        const response = await this.apiStorageListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get a paginated list of objects where the selected object will be removed whe its deleted
     */
    async apiStorageNullingListRaw(requestParameters: ApiStorageNullingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedGenericModelReferenceList>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiStorageNullingList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['cache'] != null) {
            queryParameters['cache'] = requestParameters['cache'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/storage/{id}/nulling/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedGenericModelReferenceListFromJSON(jsonValue));
    }

    /**
     * get a paginated list of objects where the selected object will be removed whe its deleted
     */
    async apiStorageNullingList(requestParameters: ApiStorageNullingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedGenericModelReferenceList> {
        const response = await this.apiStorageNullingListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiStoragePartialUpdateRaw(requestParameters: ApiStoragePartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Storage>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiStoragePartialUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/storage/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedStorageToJSON(requestParameters['patchedStorage']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiStoragePartialUpdate(requestParameters: ApiStoragePartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Storage> {
        const response = await this.apiStoragePartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get a paginated list of objects that are protecting the selected object form being deleted
     */
    async apiStorageProtectingListRaw(requestParameters: ApiStorageProtectingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedGenericModelReferenceList>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiStorageProtectingList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['cache'] != null) {
            queryParameters['cache'] = requestParameters['cache'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/storage/{id}/protecting/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedGenericModelReferenceListFromJSON(jsonValue));
    }

    /**
     * get a paginated list of objects that are protecting the selected object form being deleted
     */
    async apiStorageProtectingList(requestParameters: ApiStorageProtectingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedGenericModelReferenceList> {
        const response = await this.apiStorageProtectingListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiStorageRetrieveRaw(requestParameters: ApiStorageRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Storage>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiStorageRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/storage/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiStorageRetrieve(requestParameters: ApiStorageRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Storage> {
        const response = await this.apiStorageRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiStorageUpdateRaw(requestParameters: ApiStorageUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Storage>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiStorageUpdate().'
            );
        }

        if (requestParameters['storage'] == null) {
            throw new runtime.RequiredError(
                'storage',
                'Required parameter "storage" was null or undefined when calling apiStorageUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/storage/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: StorageToJSON(requestParameters['storage']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiStorageUpdate(requestParameters: ApiStorageUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Storage> {
        const response = await this.apiStorageUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get a paginated list of objects that will be cascaded (deleted) when deleting the selected object
     */
    async apiSupermarketCascadingListRaw(requestParameters: ApiSupermarketCascadingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedGenericModelReferenceList>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiSupermarketCascadingList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['cache'] != null) {
            queryParameters['cache'] = requestParameters['cache'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/supermarket/{id}/cascading/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedGenericModelReferenceListFromJSON(jsonValue));
    }

    /**
     * get a paginated list of objects that will be cascaded (deleted) when deleting the selected object
     */
    async apiSupermarketCascadingList(requestParameters: ApiSupermarketCascadingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedGenericModelReferenceList> {
        const response = await this.apiSupermarketCascadingListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get a paginated list of objects that will be cascaded (deleted) when deleting the selected object
     */
    async apiSupermarketCategoryCascadingListRaw(requestParameters: ApiSupermarketCategoryCascadingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedGenericModelReferenceList>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiSupermarketCategoryCascadingList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['cache'] != null) {
            queryParameters['cache'] = requestParameters['cache'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/supermarket-category/{id}/cascading/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedGenericModelReferenceListFromJSON(jsonValue));
    }

    /**
     * get a paginated list of objects that will be cascaded (deleted) when deleting the selected object
     */
    async apiSupermarketCategoryCascadingList(requestParameters: ApiSupermarketCategoryCascadingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedGenericModelReferenceList> {
        const response = await this.apiSupermarketCategoryCascadingListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSupermarketCategoryCreateRaw(requestParameters: ApiSupermarketCategoryCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SupermarketCategory>> {
        if (requestParameters['supermarketCategory'] == null) {
            throw new runtime.RequiredError(
                'supermarketCategory',
                'Required parameter "supermarketCategory" was null or undefined when calling apiSupermarketCategoryCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/supermarket-category/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SupermarketCategoryToJSON(requestParameters['supermarketCategory']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SupermarketCategoryFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSupermarketCategoryCreate(requestParameters: ApiSupermarketCategoryCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SupermarketCategory> {
        const response = await this.apiSupermarketCategoryCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSupermarketCategoryDestroyRaw(requestParameters: ApiSupermarketCategoryDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiSupermarketCategoryDestroy().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/supermarket-category/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSupermarketCategoryDestroy(requestParameters: ApiSupermarketCategoryDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiSupermarketCategoryDestroyRaw(requestParameters, initOverrides);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSupermarketCategoryListRaw(requestParameters: ApiSupermarketCategoryListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedSupermarketCategoryList>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        if (requestParameters['query'] != null) {
            queryParameters['query'] = requestParameters['query'];
        }

        if (requestParameters['random'] != null) {
            queryParameters['random'] = requestParameters['random'];
        }

        if (requestParameters['updatedAt'] != null) {
            queryParameters['updated_at'] = requestParameters['updatedAt'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/supermarket-category/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedSupermarketCategoryListFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSupermarketCategoryList(requestParameters: ApiSupermarketCategoryListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedSupermarketCategoryList> {
        const response = await this.apiSupermarketCategoryListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSupermarketCategoryMergeUpdateRaw(requestParameters: ApiSupermarketCategoryMergeUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SupermarketCategory>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiSupermarketCategoryMergeUpdate().'
            );
        }

        if (requestParameters['target'] == null) {
            throw new runtime.RequiredError(
                'target',
                'Required parameter "target" was null or undefined when calling apiSupermarketCategoryMergeUpdate().'
            );
        }

        if (requestParameters['supermarketCategory'] == null) {
            throw new runtime.RequiredError(
                'supermarketCategory',
                'Required parameter "supermarketCategory" was null or undefined when calling apiSupermarketCategoryMergeUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/supermarket-category/{id}/merge/{target}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))).replace(`{${"target"}}`, encodeURIComponent(String(requestParameters['target']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: SupermarketCategoryToJSON(requestParameters['supermarketCategory']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SupermarketCategoryFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSupermarketCategoryMergeUpdate(requestParameters: ApiSupermarketCategoryMergeUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SupermarketCategory> {
        const response = await this.apiSupermarketCategoryMergeUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get a paginated list of objects where the selected object will be removed whe its deleted
     */
    async apiSupermarketCategoryNullingListRaw(requestParameters: ApiSupermarketCategoryNullingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedGenericModelReferenceList>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiSupermarketCategoryNullingList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['cache'] != null) {
            queryParameters['cache'] = requestParameters['cache'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/supermarket-category/{id}/nulling/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedGenericModelReferenceListFromJSON(jsonValue));
    }

    /**
     * get a paginated list of objects where the selected object will be removed whe its deleted
     */
    async apiSupermarketCategoryNullingList(requestParameters: ApiSupermarketCategoryNullingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedGenericModelReferenceList> {
        const response = await this.apiSupermarketCategoryNullingListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSupermarketCategoryPartialUpdateRaw(requestParameters: ApiSupermarketCategoryPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SupermarketCategory>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiSupermarketCategoryPartialUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/supermarket-category/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedSupermarketCategoryToJSON(requestParameters['patchedSupermarketCategory']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SupermarketCategoryFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSupermarketCategoryPartialUpdate(requestParameters: ApiSupermarketCategoryPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SupermarketCategory> {
        const response = await this.apiSupermarketCategoryPartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get a paginated list of objects that are protecting the selected object form being deleted
     */
    async apiSupermarketCategoryProtectingListRaw(requestParameters: ApiSupermarketCategoryProtectingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedGenericModelReferenceList>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiSupermarketCategoryProtectingList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['cache'] != null) {
            queryParameters['cache'] = requestParameters['cache'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/supermarket-category/{id}/protecting/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedGenericModelReferenceListFromJSON(jsonValue));
    }

    /**
     * get a paginated list of objects that are protecting the selected object form being deleted
     */
    async apiSupermarketCategoryProtectingList(requestParameters: ApiSupermarketCategoryProtectingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedGenericModelReferenceList> {
        const response = await this.apiSupermarketCategoryProtectingListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSupermarketCategoryRelationCreateRaw(requestParameters: ApiSupermarketCategoryRelationCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SupermarketCategoryRelation>> {
        if (requestParameters['supermarketCategoryRelation'] == null) {
            throw new runtime.RequiredError(
                'supermarketCategoryRelation',
                'Required parameter "supermarketCategoryRelation" was null or undefined when calling apiSupermarketCategoryRelationCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/supermarket-category-relation/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SupermarketCategoryRelationToJSON(requestParameters['supermarketCategoryRelation']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SupermarketCategoryRelationFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSupermarketCategoryRelationCreate(requestParameters: ApiSupermarketCategoryRelationCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SupermarketCategoryRelation> {
        const response = await this.apiSupermarketCategoryRelationCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSupermarketCategoryRelationDestroyRaw(requestParameters: ApiSupermarketCategoryRelationDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiSupermarketCategoryRelationDestroy().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/supermarket-category-relation/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSupermarketCategoryRelationDestroy(requestParameters: ApiSupermarketCategoryRelationDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiSupermarketCategoryRelationDestroyRaw(requestParameters, initOverrides);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSupermarketCategoryRelationListRaw(requestParameters: ApiSupermarketCategoryRelationListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedSupermarketCategoryRelationList>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        if (requestParameters['query'] != null) {
            queryParameters['query'] = requestParameters['query'];
        }

        if (requestParameters['random'] != null) {
            queryParameters['random'] = requestParameters['random'];
        }

        if (requestParameters['updatedAt'] != null) {
            queryParameters['updated_at'] = requestParameters['updatedAt'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/supermarket-category-relation/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedSupermarketCategoryRelationListFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSupermarketCategoryRelationList(requestParameters: ApiSupermarketCategoryRelationListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedSupermarketCategoryRelationList> {
        const response = await this.apiSupermarketCategoryRelationListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSupermarketCategoryRelationPartialUpdateRaw(requestParameters: ApiSupermarketCategoryRelationPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SupermarketCategoryRelation>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiSupermarketCategoryRelationPartialUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/supermarket-category-relation/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedSupermarketCategoryRelationToJSON(requestParameters['patchedSupermarketCategoryRelation']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SupermarketCategoryRelationFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSupermarketCategoryRelationPartialUpdate(requestParameters: ApiSupermarketCategoryRelationPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SupermarketCategoryRelation> {
        const response = await this.apiSupermarketCategoryRelationPartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSupermarketCategoryRelationRetrieveRaw(requestParameters: ApiSupermarketCategoryRelationRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SupermarketCategoryRelation>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiSupermarketCategoryRelationRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/supermarket-category-relation/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SupermarketCategoryRelationFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSupermarketCategoryRelationRetrieve(requestParameters: ApiSupermarketCategoryRelationRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SupermarketCategoryRelation> {
        const response = await this.apiSupermarketCategoryRelationRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSupermarketCategoryRelationUpdateRaw(requestParameters: ApiSupermarketCategoryRelationUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SupermarketCategoryRelation>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiSupermarketCategoryRelationUpdate().'
            );
        }

        if (requestParameters['supermarketCategoryRelation'] == null) {
            throw new runtime.RequiredError(
                'supermarketCategoryRelation',
                'Required parameter "supermarketCategoryRelation" was null or undefined when calling apiSupermarketCategoryRelationUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/supermarket-category-relation/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: SupermarketCategoryRelationToJSON(requestParameters['supermarketCategoryRelation']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SupermarketCategoryRelationFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSupermarketCategoryRelationUpdate(requestParameters: ApiSupermarketCategoryRelationUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SupermarketCategoryRelation> {
        const response = await this.apiSupermarketCategoryRelationUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSupermarketCategoryRetrieveRaw(requestParameters: ApiSupermarketCategoryRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SupermarketCategory>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiSupermarketCategoryRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/supermarket-category/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SupermarketCategoryFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSupermarketCategoryRetrieve(requestParameters: ApiSupermarketCategoryRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SupermarketCategory> {
        const response = await this.apiSupermarketCategoryRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSupermarketCategoryUpdateRaw(requestParameters: ApiSupermarketCategoryUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SupermarketCategory>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiSupermarketCategoryUpdate().'
            );
        }

        if (requestParameters['supermarketCategory'] == null) {
            throw new runtime.RequiredError(
                'supermarketCategory',
                'Required parameter "supermarketCategory" was null or undefined when calling apiSupermarketCategoryUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/supermarket-category/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: SupermarketCategoryToJSON(requestParameters['supermarketCategory']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SupermarketCategoryFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSupermarketCategoryUpdate(requestParameters: ApiSupermarketCategoryUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SupermarketCategory> {
        const response = await this.apiSupermarketCategoryUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSupermarketCreateRaw(requestParameters: ApiSupermarketCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Supermarket>> {
        if (requestParameters['supermarket'] == null) {
            throw new runtime.RequiredError(
                'supermarket',
                'Required parameter "supermarket" was null or undefined when calling apiSupermarketCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/supermarket/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SupermarketToJSON(requestParameters['supermarket']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SupermarketFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSupermarketCreate(requestParameters: ApiSupermarketCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Supermarket> {
        const response = await this.apiSupermarketCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSupermarketDestroyRaw(requestParameters: ApiSupermarketDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiSupermarketDestroy().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/supermarket/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSupermarketDestroy(requestParameters: ApiSupermarketDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiSupermarketDestroyRaw(requestParameters, initOverrides);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSupermarketListRaw(requestParameters: ApiSupermarketListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedSupermarketList>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        if (requestParameters['query'] != null) {
            queryParameters['query'] = requestParameters['query'];
        }

        if (requestParameters['random'] != null) {
            queryParameters['random'] = requestParameters['random'];
        }

        if (requestParameters['updatedAt'] != null) {
            queryParameters['updated_at'] = requestParameters['updatedAt'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/supermarket/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedSupermarketListFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSupermarketList(requestParameters: ApiSupermarketListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedSupermarketList> {
        const response = await this.apiSupermarketListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get a paginated list of objects where the selected object will be removed whe its deleted
     */
    async apiSupermarketNullingListRaw(requestParameters: ApiSupermarketNullingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedGenericModelReferenceList>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiSupermarketNullingList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['cache'] != null) {
            queryParameters['cache'] = requestParameters['cache'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/supermarket/{id}/nulling/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedGenericModelReferenceListFromJSON(jsonValue));
    }

    /**
     * get a paginated list of objects where the selected object will be removed whe its deleted
     */
    async apiSupermarketNullingList(requestParameters: ApiSupermarketNullingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedGenericModelReferenceList> {
        const response = await this.apiSupermarketNullingListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSupermarketPartialUpdateRaw(requestParameters: ApiSupermarketPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Supermarket>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiSupermarketPartialUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/supermarket/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedSupermarketToJSON(requestParameters['patchedSupermarket']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SupermarketFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSupermarketPartialUpdate(requestParameters: ApiSupermarketPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Supermarket> {
        const response = await this.apiSupermarketPartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get a paginated list of objects that are protecting the selected object form being deleted
     */
    async apiSupermarketProtectingListRaw(requestParameters: ApiSupermarketProtectingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedGenericModelReferenceList>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiSupermarketProtectingList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['cache'] != null) {
            queryParameters['cache'] = requestParameters['cache'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/supermarket/{id}/protecting/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedGenericModelReferenceListFromJSON(jsonValue));
    }

    /**
     * get a paginated list of objects that are protecting the selected object form being deleted
     */
    async apiSupermarketProtectingList(requestParameters: ApiSupermarketProtectingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedGenericModelReferenceList> {
        const response = await this.apiSupermarketProtectingListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSupermarketRetrieveRaw(requestParameters: ApiSupermarketRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Supermarket>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiSupermarketRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/supermarket/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SupermarketFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSupermarketRetrieve(requestParameters: ApiSupermarketRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Supermarket> {
        const response = await this.apiSupermarketRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSupermarketUpdateRaw(requestParameters: ApiSupermarketUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Supermarket>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiSupermarketUpdate().'
            );
        }

        if (requestParameters['supermarket'] == null) {
            throw new runtime.RequiredError(
                'supermarket',
                'Required parameter "supermarket" was null or undefined when calling apiSupermarketUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/supermarket/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: SupermarketToJSON(requestParameters['supermarket']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SupermarketFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSupermarketUpdate(requestParameters: ApiSupermarketUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Supermarket> {
        const response = await this.apiSupermarketUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * api endpoint to switch space function
     */
    async apiSwitchActiveSpaceRetrieveRaw(requestParameters: ApiSwitchActiveSpaceRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['spaceId'] == null) {
            throw new runtime.RequiredError(
                'spaceId',
                'Required parameter "spaceId" was null or undefined when calling apiSwitchActiveSpaceRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/switch-active-space/{spaceId}/`.replace(`{${"spaceId"}}`, encodeURIComponent(String(requestParameters['spaceId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * api endpoint to switch space function
     */
    async apiSwitchActiveSpaceRetrieve(requestParameters: ApiSwitchActiveSpaceRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiSwitchActiveSpaceRetrieveRaw(requestParameters, initOverrides);
    }

    /**
     * get a paginated list of objects that will be cascaded (deleted) when deleting the selected object
     */
    async apiSyncCascadingListRaw(requestParameters: ApiSyncCascadingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedGenericModelReferenceList>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiSyncCascadingList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['cache'] != null) {
            queryParameters['cache'] = requestParameters['cache'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/sync/{id}/cascading/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedGenericModelReferenceListFromJSON(jsonValue));
    }

    /**
     * get a paginated list of objects that will be cascaded (deleted) when deleting the selected object
     */
    async apiSyncCascadingList(requestParameters: ApiSyncCascadingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedGenericModelReferenceList> {
        const response = await this.apiSyncCascadingListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSyncCreateRaw(requestParameters: ApiSyncCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Sync>> {
        if (requestParameters['sync'] == null) {
            throw new runtime.RequiredError(
                'sync',
                'Required parameter "sync" was null or undefined when calling apiSyncCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/sync/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SyncToJSON(requestParameters['sync']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SyncFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSyncCreate(requestParameters: ApiSyncCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Sync> {
        const response = await this.apiSyncCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSyncDestroyRaw(requestParameters: ApiSyncDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiSyncDestroy().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/sync/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSyncDestroy(requestParameters: ApiSyncDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiSyncDestroyRaw(requestParameters, initOverrides);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSyncListRaw(requestParameters: ApiSyncListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedSyncList>> {
        const queryParameters: any = {};

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/sync/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedSyncListFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSyncList(requestParameters: ApiSyncListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedSyncList> {
        const response = await this.apiSyncListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSyncLogListRaw(requestParameters: ApiSyncLogListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedSyncLogList>> {
        const queryParameters: any = {};

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/sync-log/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedSyncLogListFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSyncLogList(requestParameters: ApiSyncLogListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedSyncLogList> {
        const response = await this.apiSyncLogListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSyncLogRetrieveRaw(requestParameters: ApiSyncLogRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SyncLog>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiSyncLogRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/sync-log/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SyncLogFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSyncLogRetrieve(requestParameters: ApiSyncLogRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SyncLog> {
        const response = await this.apiSyncLogRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get a paginated list of objects where the selected object will be removed whe its deleted
     */
    async apiSyncNullingListRaw(requestParameters: ApiSyncNullingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedGenericModelReferenceList>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiSyncNullingList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['cache'] != null) {
            queryParameters['cache'] = requestParameters['cache'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/sync/{id}/nulling/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedGenericModelReferenceListFromJSON(jsonValue));
    }

    /**
     * get a paginated list of objects where the selected object will be removed whe its deleted
     */
    async apiSyncNullingList(requestParameters: ApiSyncNullingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedGenericModelReferenceList> {
        const response = await this.apiSyncNullingListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSyncPartialUpdateRaw(requestParameters: ApiSyncPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Sync>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiSyncPartialUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/sync/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedSyncToJSON(requestParameters['patchedSync']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SyncFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSyncPartialUpdate(requestParameters: ApiSyncPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Sync> {
        const response = await this.apiSyncPartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get a paginated list of objects that are protecting the selected object form being deleted
     */
    async apiSyncProtectingListRaw(requestParameters: ApiSyncProtectingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedGenericModelReferenceList>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiSyncProtectingList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['cache'] != null) {
            queryParameters['cache'] = requestParameters['cache'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/sync/{id}/protecting/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedGenericModelReferenceListFromJSON(jsonValue));
    }

    /**
     * get a paginated list of objects that are protecting the selected object form being deleted
     */
    async apiSyncProtectingList(requestParameters: ApiSyncProtectingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedGenericModelReferenceList> {
        const response = await this.apiSyncProtectingListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSyncQuerySyncedFolderCreateRaw(requestParameters: ApiSyncQuerySyncedFolderCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SyncLog>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiSyncQuerySyncedFolderCreate().'
            );
        }

        if (requestParameters['sync'] == null) {
            throw new runtime.RequiredError(
                'sync',
                'Required parameter "sync" was null or undefined when calling apiSyncQuerySyncedFolderCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/sync/{id}/query_synced_folder/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SyncToJSON(requestParameters['sync']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SyncLogFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSyncQuerySyncedFolderCreate(requestParameters: ApiSyncQuerySyncedFolderCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SyncLog> {
        const response = await this.apiSyncQuerySyncedFolderCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSyncRetrieveRaw(requestParameters: ApiSyncRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Sync>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiSyncRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/sync/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SyncFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSyncRetrieve(requestParameters: ApiSyncRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Sync> {
        const response = await this.apiSyncRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSyncUpdateRaw(requestParameters: ApiSyncUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Sync>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiSyncUpdate().'
            );
        }

        if (requestParameters['sync'] == null) {
            throw new runtime.RequiredError(
                'sync',
                'Required parameter "sync" was null or undefined when calling apiSyncUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/sync/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: SyncToJSON(requestParameters['sync']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SyncFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiSyncUpdate(requestParameters: ApiSyncUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Sync> {
        const response = await this.apiSyncUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get a paginated list of objects that will be cascaded (deleted) when deleting the selected object
     */
    async apiUnitCascadingListRaw(requestParameters: ApiUnitCascadingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedGenericModelReferenceList>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiUnitCascadingList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['cache'] != null) {
            queryParameters['cache'] = requestParameters['cache'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/unit/{id}/cascading/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedGenericModelReferenceListFromJSON(jsonValue));
    }

    /**
     * get a paginated list of objects that will be cascaded (deleted) when deleting the selected object
     */
    async apiUnitCascadingList(requestParameters: ApiUnitCascadingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedGenericModelReferenceList> {
        const response = await this.apiUnitCascadingListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiUnitConversionCreateRaw(requestParameters: ApiUnitConversionCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UnitConversion>> {
        if (requestParameters['unitConversion'] == null) {
            throw new runtime.RequiredError(
                'unitConversion',
                'Required parameter "unitConversion" was null or undefined when calling apiUnitConversionCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/unit-conversion/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UnitConversionToJSON(requestParameters['unitConversion']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UnitConversionFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiUnitConversionCreate(requestParameters: ApiUnitConversionCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UnitConversion> {
        const response = await this.apiUnitConversionCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiUnitConversionDestroyRaw(requestParameters: ApiUnitConversionDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiUnitConversionDestroy().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/unit-conversion/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiUnitConversionDestroy(requestParameters: ApiUnitConversionDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiUnitConversionDestroyRaw(requestParameters, initOverrides);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiUnitConversionListRaw(requestParameters: ApiUnitConversionListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedUnitConversionList>> {
        const queryParameters: any = {};

        if (requestParameters['foodId'] != null) {
            queryParameters['food_id'] = requestParameters['foodId'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        if (requestParameters['query'] != null) {
            queryParameters['query'] = requestParameters['query'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/unit-conversion/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedUnitConversionListFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiUnitConversionList(requestParameters: ApiUnitConversionListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedUnitConversionList> {
        const response = await this.apiUnitConversionListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiUnitConversionPartialUpdateRaw(requestParameters: ApiUnitConversionPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UnitConversion>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiUnitConversionPartialUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/unit-conversion/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedUnitConversionToJSON(requestParameters['patchedUnitConversion']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UnitConversionFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiUnitConversionPartialUpdate(requestParameters: ApiUnitConversionPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UnitConversion> {
        const response = await this.apiUnitConversionPartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiUnitConversionRetrieveRaw(requestParameters: ApiUnitConversionRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UnitConversion>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiUnitConversionRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/unit-conversion/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UnitConversionFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiUnitConversionRetrieve(requestParameters: ApiUnitConversionRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UnitConversion> {
        const response = await this.apiUnitConversionRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiUnitConversionUpdateRaw(requestParameters: ApiUnitConversionUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UnitConversion>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiUnitConversionUpdate().'
            );
        }

        if (requestParameters['unitConversion'] == null) {
            throw new runtime.RequiredError(
                'unitConversion',
                'Required parameter "unitConversion" was null or undefined when calling apiUnitConversionUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/unit-conversion/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UnitConversionToJSON(requestParameters['unitConversion']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UnitConversionFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiUnitConversionUpdate(requestParameters: ApiUnitConversionUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UnitConversion> {
        const response = await this.apiUnitConversionUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiUnitCreateRaw(requestParameters: ApiUnitCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Unit>> {
        if (requestParameters['unit'] == null) {
            throw new runtime.RequiredError(
                'unit',
                'Required parameter "unit" was null or undefined when calling apiUnitCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/unit/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UnitToJSON(requestParameters['unit']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UnitFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiUnitCreate(requestParameters: ApiUnitCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Unit> {
        const response = await this.apiUnitCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiUnitDestroyRaw(requestParameters: ApiUnitDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiUnitDestroy().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/unit/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiUnitDestroy(requestParameters: ApiUnitDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiUnitDestroyRaw(requestParameters, initOverrides);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiUnitListRaw(requestParameters: ApiUnitListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedUnitList>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        if (requestParameters['query'] != null) {
            queryParameters['query'] = requestParameters['query'];
        }

        if (requestParameters['random'] != null) {
            queryParameters['random'] = requestParameters['random'];
        }

        if (requestParameters['updatedAt'] != null) {
            queryParameters['updated_at'] = requestParameters['updatedAt'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/unit/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedUnitListFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiUnitList(requestParameters: ApiUnitListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedUnitList> {
        const response = await this.apiUnitListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiUnitMergeUpdateRaw(requestParameters: ApiUnitMergeUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Unit>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiUnitMergeUpdate().'
            );
        }

        if (requestParameters['target'] == null) {
            throw new runtime.RequiredError(
                'target',
                'Required parameter "target" was null or undefined when calling apiUnitMergeUpdate().'
            );
        }

        if (requestParameters['unit'] == null) {
            throw new runtime.RequiredError(
                'unit',
                'Required parameter "unit" was null or undefined when calling apiUnitMergeUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/unit/{id}/merge/{target}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))).replace(`{${"target"}}`, encodeURIComponent(String(requestParameters['target']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UnitToJSON(requestParameters['unit']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UnitFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiUnitMergeUpdate(requestParameters: ApiUnitMergeUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Unit> {
        const response = await this.apiUnitMergeUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get a paginated list of objects where the selected object will be removed whe its deleted
     */
    async apiUnitNullingListRaw(requestParameters: ApiUnitNullingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedGenericModelReferenceList>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiUnitNullingList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['cache'] != null) {
            queryParameters['cache'] = requestParameters['cache'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/unit/{id}/nulling/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedGenericModelReferenceListFromJSON(jsonValue));
    }

    /**
     * get a paginated list of objects where the selected object will be removed whe its deleted
     */
    async apiUnitNullingList(requestParameters: ApiUnitNullingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedGenericModelReferenceList> {
        const response = await this.apiUnitNullingListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiUnitPartialUpdateRaw(requestParameters: ApiUnitPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Unit>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiUnitPartialUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/unit/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedUnitToJSON(requestParameters['patchedUnit']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UnitFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiUnitPartialUpdate(requestParameters: ApiUnitPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Unit> {
        const response = await this.apiUnitPartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get a paginated list of objects that are protecting the selected object form being deleted
     */
    async apiUnitProtectingListRaw(requestParameters: ApiUnitProtectingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedGenericModelReferenceList>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiUnitProtectingList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['cache'] != null) {
            queryParameters['cache'] = requestParameters['cache'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/unit/{id}/protecting/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedGenericModelReferenceListFromJSON(jsonValue));
    }

    /**
     * get a paginated list of objects that are protecting the selected object form being deleted
     */
    async apiUnitProtectingList(requestParameters: ApiUnitProtectingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedGenericModelReferenceList> {
        const response = await this.apiUnitProtectingListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiUnitRetrieveRaw(requestParameters: ApiUnitRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Unit>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiUnitRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/unit/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UnitFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiUnitRetrieve(requestParameters: ApiUnitRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Unit> {
        const response = await this.apiUnitRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiUnitUpdateRaw(requestParameters: ApiUnitUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Unit>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiUnitUpdate().'
            );
        }

        if (requestParameters['unit'] == null) {
            throw new runtime.RequiredError(
                'unit',
                'Required parameter "unit" was null or undefined when calling apiUnitUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/unit/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UnitToJSON(requestParameters['unit']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UnitFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiUnitUpdate(requestParameters: ApiUnitUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Unit> {
        const response = await this.apiUnitUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get a paginated list of objects that will be cascaded (deleted) when deleting the selected object
     */
    async apiUserFileCascadingListRaw(requestParameters: ApiUserFileCascadingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedGenericModelReferenceList>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiUserFileCascadingList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['cache'] != null) {
            queryParameters['cache'] = requestParameters['cache'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/user-file/{id}/cascading/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedGenericModelReferenceListFromJSON(jsonValue));
    }

    /**
     * get a paginated list of objects that will be cascaded (deleted) when deleting the selected object
     */
    async apiUserFileCascadingList(requestParameters: ApiUserFileCascadingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedGenericModelReferenceList> {
        const response = await this.apiUserFileCascadingListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiUserFileCreateRaw(requestParameters: ApiUserFileCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserFile>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling apiUserFileCreate().'
            );
        }

        if (requestParameters['fileDownload'] == null) {
            throw new runtime.RequiredError(
                'fileDownload',
                'Required parameter "fileDownload" was null or undefined when calling apiUserFileCreate().'
            );
        }

        if (requestParameters['preview'] == null) {
            throw new runtime.RequiredError(
                'preview',
                'Required parameter "preview" was null or undefined when calling apiUserFileCreate().'
            );
        }

        if (requestParameters['fileSizeKb'] == null) {
            throw new runtime.RequiredError(
                'fileSizeKb',
                'Required parameter "fileSizeKb" was null or undefined when calling apiUserFileCreate().'
            );
        }

        if (requestParameters['createdBy'] == null) {
            throw new runtime.RequiredError(
                'createdBy',
                'Required parameter "createdBy" was null or undefined when calling apiUserFileCreate().'
            );
        }

        if (requestParameters['createdAt'] == null) {
            throw new runtime.RequiredError(
                'createdAt',
                'Required parameter "createdAt" was null or undefined when calling apiUserFileCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['id'] != null) {
            formParams.append('id', requestParameters['id'] as any);
        }

        if (requestParameters['name'] != null) {
            formParams.append('name', requestParameters['name'] as any);
        }

        if (requestParameters['file'] != null) {
            formParams.append('file', requestParameters['file'] as any);
        }

        if (requestParameters['fileDownload'] != null) {
            formParams.append('file_download', requestParameters['fileDownload'] as any);
        }

        if (requestParameters['preview'] != null) {
            formParams.append('preview', requestParameters['preview'] as any);
        }

        if (requestParameters['fileSizeKb'] != null) {
            formParams.append('file_size_kb', requestParameters['fileSizeKb'] as any);
        }

        if (requestParameters['createdBy'] != null) {
            formParams.append('created_by', new Blob([JSON.stringify(UserToJSON(requestParameters['createdBy']))], { type: "application/json", }));
                    }

        if (requestParameters['createdAt'] != null) {
            formParams.append('created_at', requestParameters['createdAt'] as any);
        }

        const response = await this.request({
            path: `/api/user-file/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserFileFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiUserFileCreate(requestParameters: ApiUserFileCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserFile> {
        const response = await this.apiUserFileCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiUserFileDestroyRaw(requestParameters: ApiUserFileDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiUserFileDestroy().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/user-file/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiUserFileDestroy(requestParameters: ApiUserFileDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiUserFileDestroyRaw(requestParameters, initOverrides);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiUserFileListRaw(requestParameters: ApiUserFileListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedUserFileList>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        if (requestParameters['query'] != null) {
            queryParameters['query'] = requestParameters['query'];
        }

        if (requestParameters['random'] != null) {
            queryParameters['random'] = requestParameters['random'];
        }

        if (requestParameters['updatedAt'] != null) {
            queryParameters['updated_at'] = requestParameters['updatedAt'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/user-file/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedUserFileListFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiUserFileList(requestParameters: ApiUserFileListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedUserFileList> {
        const response = await this.apiUserFileListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get a paginated list of objects where the selected object will be removed whe its deleted
     */
    async apiUserFileNullingListRaw(requestParameters: ApiUserFileNullingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedGenericModelReferenceList>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiUserFileNullingList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['cache'] != null) {
            queryParameters['cache'] = requestParameters['cache'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/user-file/{id}/nulling/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedGenericModelReferenceListFromJSON(jsonValue));
    }

    /**
     * get a paginated list of objects where the selected object will be removed whe its deleted
     */
    async apiUserFileNullingList(requestParameters: ApiUserFileNullingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedGenericModelReferenceList> {
        const response = await this.apiUserFileNullingListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiUserFilePartialUpdateRaw(requestParameters: ApiUserFilePartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserFile>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiUserFilePartialUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['id2'] != null) {
            formParams.append('id', requestParameters['id2'] as any);
        }

        if (requestParameters['name'] != null) {
            formParams.append('name', requestParameters['name'] as any);
        }

        if (requestParameters['file'] != null) {
            formParams.append('file', requestParameters['file'] as any);
        }

        if (requestParameters['fileDownload'] != null) {
            formParams.append('file_download', requestParameters['fileDownload'] as any);
        }

        if (requestParameters['preview'] != null) {
            formParams.append('preview', requestParameters['preview'] as any);
        }

        if (requestParameters['fileSizeKb'] != null) {
            formParams.append('file_size_kb', requestParameters['fileSizeKb'] as any);
        }

        if (requestParameters['createdBy'] != null) {
            formParams.append('created_by', new Blob([JSON.stringify(UserToJSON(requestParameters['createdBy']))], { type: "application/json", }));
                    }

        if (requestParameters['createdAt'] != null) {
            formParams.append('created_at', requestParameters['createdAt'] as any);
        }

        const response = await this.request({
            path: `/api/user-file/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserFileFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiUserFilePartialUpdate(requestParameters: ApiUserFilePartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserFile> {
        const response = await this.apiUserFilePartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * get a paginated list of objects that are protecting the selected object form being deleted
     */
    async apiUserFileProtectingListRaw(requestParameters: ApiUserFileProtectingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedGenericModelReferenceList>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiUserFileProtectingList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['cache'] != null) {
            queryParameters['cache'] = requestParameters['cache'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/user-file/{id}/protecting/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedGenericModelReferenceListFromJSON(jsonValue));
    }

    /**
     * get a paginated list of objects that are protecting the selected object form being deleted
     */
    async apiUserFileProtectingList(requestParameters: ApiUserFileProtectingListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedGenericModelReferenceList> {
        const response = await this.apiUserFileProtectingListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiUserFileRetrieveRaw(requestParameters: ApiUserFileRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserFile>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiUserFileRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/user-file/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserFileFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiUserFileRetrieve(requestParameters: ApiUserFileRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserFile> {
        const response = await this.apiUserFileRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiUserFileUpdateRaw(requestParameters: ApiUserFileUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserFile>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiUserFileUpdate().'
            );
        }

        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling apiUserFileUpdate().'
            );
        }

        if (requestParameters['fileDownload'] == null) {
            throw new runtime.RequiredError(
                'fileDownload',
                'Required parameter "fileDownload" was null or undefined when calling apiUserFileUpdate().'
            );
        }

        if (requestParameters['preview'] == null) {
            throw new runtime.RequiredError(
                'preview',
                'Required parameter "preview" was null or undefined when calling apiUserFileUpdate().'
            );
        }

        if (requestParameters['fileSizeKb'] == null) {
            throw new runtime.RequiredError(
                'fileSizeKb',
                'Required parameter "fileSizeKb" was null or undefined when calling apiUserFileUpdate().'
            );
        }

        if (requestParameters['createdBy'] == null) {
            throw new runtime.RequiredError(
                'createdBy',
                'Required parameter "createdBy" was null or undefined when calling apiUserFileUpdate().'
            );
        }

        if (requestParameters['createdAt'] == null) {
            throw new runtime.RequiredError(
                'createdAt',
                'Required parameter "createdAt" was null or undefined when calling apiUserFileUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['id2'] != null) {
            formParams.append('id', requestParameters['id2'] as any);
        }

        if (requestParameters['name'] != null) {
            formParams.append('name', requestParameters['name'] as any);
        }

        if (requestParameters['file'] != null) {
            formParams.append('file', requestParameters['file'] as any);
        }

        if (requestParameters['fileDownload'] != null) {
            formParams.append('file_download', requestParameters['fileDownload'] as any);
        }

        if (requestParameters['preview'] != null) {
            formParams.append('preview', requestParameters['preview'] as any);
        }

        if (requestParameters['fileSizeKb'] != null) {
            formParams.append('file_size_kb', requestParameters['fileSizeKb'] as any);
        }

        if (requestParameters['createdBy'] != null) {
            formParams.append('created_by', new Blob([JSON.stringify(UserToJSON(requestParameters['createdBy']))], { type: "application/json", }));
                    }

        if (requestParameters['createdAt'] != null) {
            formParams.append('created_at', requestParameters['createdAt'] as any);
        }

        const response = await this.request({
            path: `/api/user-file/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserFileFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiUserFileUpdate(requestParameters: ApiUserFileUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserFile> {
        const response = await this.apiUserFileUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiUserListRaw(requestParameters: ApiUserListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<User>>> {
        const queryParameters: any = {};

        if (requestParameters['filterList'] != null) {
            queryParameters['filter_list'] = requestParameters['filterList'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/user/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(UserFromJSON));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiUserList(requestParameters: ApiUserListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<User>> {
        const response = await this.apiUserListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiUserPartialUpdateRaw(requestParameters: ApiUserPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<User>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiUserPartialUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/user/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedUserToJSON(requestParameters['patchedUser']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiUserPartialUpdate(requestParameters: ApiUserPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<User> {
        const response = await this.apiUserPartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiUserPreferenceListRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<UserPreference>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/user-preference/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(UserPreferenceFromJSON));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiUserPreferenceList(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<UserPreference>> {
        const response = await this.apiUserPreferenceListRaw(initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiUserPreferencePartialUpdateRaw(requestParameters: ApiUserPreferencePartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserPreference>> {
        if (requestParameters['user'] == null) {
            throw new runtime.RequiredError(
                'user',
                'Required parameter "user" was null or undefined when calling apiUserPreferencePartialUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/user-preference/{user}/`.replace(`{${"user"}}`, encodeURIComponent(String(requestParameters['user']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedUserPreferenceToJSON(requestParameters['patchedUserPreference']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserPreferenceFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiUserPreferencePartialUpdate(requestParameters: ApiUserPreferencePartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserPreference> {
        const response = await this.apiUserPreferencePartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiUserPreferenceRetrieveRaw(requestParameters: ApiUserPreferenceRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserPreference>> {
        if (requestParameters['user'] == null) {
            throw new runtime.RequiredError(
                'user',
                'Required parameter "user" was null or undefined when calling apiUserPreferenceRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/user-preference/{user}/`.replace(`{${"user"}}`, encodeURIComponent(String(requestParameters['user']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserPreferenceFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiUserPreferenceRetrieve(requestParameters: ApiUserPreferenceRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserPreference> {
        const response = await this.apiUserPreferenceRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiUserRetrieveRaw(requestParameters: ApiUserRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<User>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiUserRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/user/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiUserRetrieve(requestParameters: ApiUserRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<User> {
        const response = await this.apiUserRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * return all userspaces for the user requesting the endpoint :param request: :return:
     */
    async apiUserSpaceAllPersonalListRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<UserSpace>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/user-space/all_personal/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(UserSpaceFromJSON));
    }

    /**
     * return all userspaces for the user requesting the endpoint :param request: :return:
     */
    async apiUserSpaceAllPersonalList(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<UserSpace>> {
        const response = await this.apiUserSpaceAllPersonalListRaw(initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiUserSpaceDestroyRaw(requestParameters: ApiUserSpaceDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiUserSpaceDestroy().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/user-space/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiUserSpaceDestroy(requestParameters: ApiUserSpaceDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiUserSpaceDestroyRaw(requestParameters, initOverrides);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiUserSpaceListRaw(requestParameters: ApiUserSpaceListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedUserSpaceList>> {
        const queryParameters: any = {};

        if (requestParameters['internalNote'] != null) {
            queryParameters['internal_note'] = requestParameters['internalNote'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/user-space/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedUserSpaceListFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiUserSpaceList(requestParameters: ApiUserSpaceListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedUserSpaceList> {
        const response = await this.apiUserSpaceListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiUserSpacePartialUpdateRaw(requestParameters: ApiUserSpacePartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserSpace>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiUserSpacePartialUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/user-space/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedUserSpaceToJSON(requestParameters['patchedUserSpace']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserSpaceFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiUserSpacePartialUpdate(requestParameters: ApiUserSpacePartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserSpace> {
        const response = await this.apiUserSpacePartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiUserSpaceRetrieveRaw(requestParameters: ApiUserSpaceRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserSpace>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiUserSpaceRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/user-space/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserSpaceFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiUserSpaceRetrieve(requestParameters: ApiUserSpaceRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserSpace> {
        const response = await this.apiUserSpaceRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiUserSpaceUpdateRaw(requestParameters: ApiUserSpaceUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserSpace>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiUserSpaceUpdate().'
            );
        }

        if (requestParameters['userSpace'] == null) {
            throw new runtime.RequiredError(
                'userSpace',
                'Required parameter "userSpace" was null or undefined when calling apiUserSpaceUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/user-space/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UserSpaceToJSON(requestParameters['userSpace']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserSpaceFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiUserSpaceUpdate(requestParameters: ApiUserSpaceUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserSpace> {
        const response = await this.apiUserSpaceUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiViewLogCreateRaw(requestParameters: ApiViewLogCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ViewLog>> {
        if (requestParameters['viewLog'] == null) {
            throw new runtime.RequiredError(
                'viewLog',
                'Required parameter "viewLog" was null or undefined when calling apiViewLogCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/view-log/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ViewLogToJSON(requestParameters['viewLog']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ViewLogFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiViewLogCreate(requestParameters: ApiViewLogCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ViewLog> {
        const response = await this.apiViewLogCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiViewLogDestroyRaw(requestParameters: ApiViewLogDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiViewLogDestroy().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/view-log/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiViewLogDestroy(requestParameters: ApiViewLogDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiViewLogDestroyRaw(requestParameters, initOverrides);
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiViewLogListRaw(requestParameters: ApiViewLogListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedViewLogList>> {
        const queryParameters: any = {};

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/view-log/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedViewLogListFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiViewLogList(requestParameters: ApiViewLogListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedViewLogList> {
        const response = await this.apiViewLogListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiViewLogPartialUpdateRaw(requestParameters: ApiViewLogPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ViewLog>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiViewLogPartialUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/view-log/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedViewLogToJSON(requestParameters['patchedViewLog']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ViewLogFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiViewLogPartialUpdate(requestParameters: ApiViewLogPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ViewLog> {
        const response = await this.apiViewLogPartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiViewLogRetrieveRaw(requestParameters: ApiViewLogRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ViewLog>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiViewLogRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/view-log/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ViewLogFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiViewLogRetrieve(requestParameters: ApiViewLogRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ViewLog> {
        const response = await this.apiViewLogRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiViewLogUpdateRaw(requestParameters: ApiViewLogUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ViewLog>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiViewLogUpdate().'
            );
        }

        if (requestParameters['viewLog'] == null) {
            throw new runtime.RequiredError(
                'viewLog',
                'Required parameter "viewLog" was null or undefined when calling apiViewLogUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyAuth authentication
        }

        const response = await this.request({
            path: `/api/view-log/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ViewLogToJSON(requestParameters['viewLog']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ViewLogFromJSON(jsonValue));
    }

    /**
     * logs request counts to redis cache total/per user/
     */
    async apiViewLogUpdate(requestParameters: ApiViewLogUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ViewLog> {
        const response = await this.apiViewLogUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const ApiAutomationListTypeEnum = {
    DescriptionReplace: 'DESCRIPTION_REPLACE',
    FoodAlias: 'FOOD_ALIAS',
    FoodReplace: 'FOOD_REPLACE',
    InstructionReplace: 'INSTRUCTION_REPLACE',
    KeywordAlias: 'KEYWORD_ALIAS',
    NameReplace: 'NAME_REPLACE',
    NeverUnit: 'NEVER_UNIT',
    TransposeWords: 'TRANSPOSE_WORDS',
    UnitAlias: 'UNIT_ALIAS',
    UnitReplace: 'UNIT_REPLACE'
} as const;
export type ApiAutomationListTypeEnum = typeof ApiAutomationListTypeEnum[keyof typeof ApiAutomationListTypeEnum];
/**
 * @export
 */
export const ApiCustomFilterListTypeEnum = {
    Food: 'FOOD',
    Keyword: 'KEYWORD',
    Recipe: 'RECIPE'
} as const;
export type ApiCustomFilterListTypeEnum = typeof ApiCustomFilterListTypeEnum[keyof typeof ApiCustomFilterListTypeEnum];
/**
 * @export
 */
export const ApiPropertyTypeListCategoryEnum = {
    Allergen: 'ALLERGEN',
    Goal: 'GOAL',
    Nutrition: 'NUTRITION',
    Other: 'OTHER',
    Price: 'PRICE'
} as const;
export type ApiPropertyTypeListCategoryEnum = typeof ApiPropertyTypeListCategoryEnum[keyof typeof ApiPropertyTypeListCategoryEnum];
/**
 * @export
 */
export const ApiRecipeBookListOrderDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type ApiRecipeBookListOrderDirectionEnum = typeof ApiRecipeBookListOrderDirectionEnum[keyof typeof ApiRecipeBookListOrderDirectionEnum];
/**
 * @export
 */
export const ApiRecipeBookListOrderFieldEnum = {
    Id: 'id',
    Name: 'name',
    Order: 'order'
} as const;
export type ApiRecipeBookListOrderFieldEnum = typeof ApiRecipeBookListOrderFieldEnum[keyof typeof ApiRecipeBookListOrderFieldEnum];
