/* tslint:disable */
/* eslint-disable */
/**
 * Tandoor
 * Tandoor API Docs
 *
 * The version of the OpenAPI document: 0.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AccessToken
 */
export interface AccessToken {
    /**
     * 
     * @type {number}
     * @memberof AccessToken
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof AccessToken
     */
    token: string;
    /**
     * 
     * @type {string}
     * @memberof AccessToken
     */
    expires: string;
    /**
     * 
     * @type {string}
     * @memberof AccessToken
     */
    scope?: string;
    /**
     * 
     * @type {string}
     * @memberof AccessToken
     */
    created: string;
    /**
     * 
     * @type {string}
     * @memberof AccessToken
     */
    updated: string;
}
/**
 * 
 * @export
 * @interface AuthToken
 */
export interface AuthToken {
    /**
     * 
     * @type {string}
     * @memberof AuthToken
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof AuthToken
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof AuthToken
     */
    token: string;
}
/**
 * 
 * @export
 * @interface AutoMealPlan
 */
export interface AutoMealPlan {
    /**
     * 
     * @type {string}
     * @memberof AutoMealPlan
     */
    start_date: string;
    /**
     * 
     * @type {string}
     * @memberof AutoMealPlan
     */
    end_date: string;
    /**
     * 
     * @type {number}
     * @memberof AutoMealPlan
     */
    meal_type_id: number;
    /**
     * 
     * @type {Array<any>}
     * @memberof AutoMealPlan
     */
    keyword_ids: Array<any>;
    /**
     * 
     * @type {number}
     * @memberof AutoMealPlan
     */
    servings: number;
    /**
     * 
     * @type {Array<User>}
     * @memberof AutoMealPlan
     */
    shared?: Array<User> | null;
    /**
     * 
     * @type {boolean}
     * @memberof AutoMealPlan
     */
    addshopping: boolean;
}
/**
 * 
 * @export
 * @interface Automation
 */
export interface Automation {
    /**
     * 
     * @type {number}
     * @memberof Automation
     */
    id?: number;
    /**
     * 
     * @type {TypeEnum}
     * @memberof Automation
     */
    type: TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Automation
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Automation
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Automation
     */
    param_1?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Automation
     */
    param_2?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Automation
     */
    param_3?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Automation
     */
    order?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Automation
     */
    disabled?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Automation
     */
    created_by: number;
}
/**
 * 
 * @export
 * @interface BookmarkletImport
 */
export interface BookmarkletImport {
    /**
     * 
     * @type {number}
     * @memberof BookmarkletImport
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof BookmarkletImport
     */
    url?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookmarkletImport
     */
    html: string;
    /**
     * 
     * @type {number}
     * @memberof BookmarkletImport
     */
    created_by: number;
    /**
     * 
     * @type {string}
     * @memberof BookmarkletImport
     */
    created_at: string;
}
/**
 * 
 * @export
 * @interface BookmarkletImportList
 */
export interface BookmarkletImportList {
    /**
     * 
     * @type {number}
     * @memberof BookmarkletImportList
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof BookmarkletImportList
     */
    url?: string | null;
    /**
     * 
     * @type {number}
     * @memberof BookmarkletImportList
     */
    created_by: number;
    /**
     * 
     * @type {string}
     * @memberof BookmarkletImportList
     */
    created_at: string;
}
/**
 * 
 * @export
 * @interface ConnectorConfigConfig
 */
export interface ConnectorConfigConfig {
    /**
     * 
     * @type {number}
     * @memberof ConnectorConfigConfig
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ConnectorConfigConfig
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectorConfigConfig
     */
    url?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ConnectorConfigConfig
     */
    token?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ConnectorConfigConfig
     */
    todo_entity?: string | null;
    /**
     * Is Connector Enabled
     * @type {boolean}
     * @memberof ConnectorConfigConfig
     */
    enabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConnectorConfigConfig
     */
    on_shopping_list_entry_created_enabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConnectorConfigConfig
     */
    on_shopping_list_entry_updated_enabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConnectorConfigConfig
     */
    on_shopping_list_entry_deleted_enabled?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ConnectorConfigConfig
     */
    created_by: number;
}
/**
 * 
 * @export
 * @interface CookLog
 */
export interface CookLog {
    /**
     * 
     * @type {number}
     * @memberof CookLog
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof CookLog
     */
    recipe: number;
    /**
     * 
     * @type {number}
     * @memberof CookLog
     */
    servings?: number | null;
    /**
     * 
     * @type {number}
     * @memberof CookLog
     */
    rating?: number | null;
    /**
     * 
     * @type {string}
     * @memberof CookLog
     */
    comment?: string | null;
    /**
     * 
     * @type {User}
     * @memberof CookLog
     */
    created_by: User;
    /**
     * 
     * @type {string}
     * @memberof CookLog
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof CookLog
     */
    updated_at: string;
}
/**
 * Adds nested create feature
 * @export
 * @interface CustomFilter
 */
export interface CustomFilter {
    /**
     * 
     * @type {number}
     * @memberof CustomFilter
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof CustomFilter
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CustomFilter
     */
    search: string;
    /**
     * 
     * @type {Array<User>}
     * @memberof CustomFilter
     */
    shared?: Array<User>;
    /**
     * 
     * @type {number}
     * @memberof CustomFilter
     */
    created_by: number;
}
/**
 * * `SEARCH` - Search * `PLAN` - Meal-Plan * `BOOKS` - Books * `SHOPPING` - Shopping
 * @export
 * @enum {string}
 */
export enum DefaultPageEnum {
    Search = 'SEARCH',
    Plan = 'PLAN',
    Books = 'BOOKS',
    Shopping = 'SHOPPING'
}

/**
 * * `true` - true
 * @export
 * @enum {string}
 */
export enum DeleteEnum {
    True = 'true'
}

/**
 * 
 * @export
 * @interface ExportLog
 */
export interface ExportLog {
    /**
     * 
     * @type {number}
     * @memberof ExportLog
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ExportLog
     */
    type: string;
    /**
     * 
     * @type {string}
     * @memberof ExportLog
     */
    msg?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ExportLog
     */
    running?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ExportLog
     */
    total_recipes?: number;
    /**
     * 
     * @type {number}
     * @memberof ExportLog
     */
    exported_recipes?: number;
    /**
     * 
     * @type {number}
     * @memberof ExportLog
     */
    cache_duration?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ExportLog
     */
    possibly_not_expired?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ExportLog
     */
    created_by: number;
    /**
     * 
     * @type {string}
     * @memberof ExportLog
     */
    created_at: string;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface Food
 */
export interface Food {
    /**
     * 
     * @type {number}
     * @memberof Food
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Food
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Food
     */
    plural_name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Food
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof Food
     */
    shopping: string;
    /**
     * 
     * @type {RecipeSimple}
     * @memberof Food
     */
    recipe?: RecipeSimple | null;
    /**
     * 
     * @type {string}
     * @memberof Food
     */
    url?: string | null;
    /**
     * 
     * @type {Array<Property>}
     * @memberof Food
     */
    properties?: Array<Property> | null;
    /**
     * 
     * @type {number}
     * @memberof Food
     */
    properties_food_amount?: number;
    /**
     * 
     * @type {Unit}
     * @memberof Food
     */
    properties_food_unit?: Unit | null;
    /**
     * 
     * @type {number}
     * @memberof Food
     */
    fdc_id?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof Food
     */
    food_onhand?: boolean | null;
    /**
     * 
     * @type {SupermarketCategory}
     * @memberof Food
     */
    supermarket_category?: SupermarketCategory | null;
    /**
     * 
     * @type {number}
     * @memberof Food
     */
    parent: number;
    /**
     * 
     * @type {number}
     * @memberof Food
     */
    numchild: number;
    /**
     * 
     * @type {Array<FoodInheritField>}
     * @memberof Food
     */
    inherit_fields?: Array<FoodInheritField> | null;
    /**
     * Returns a string representation of a tree node and it\'s ancestors, e.g. \'Cuisine > Asian > Chinese > Catonese\'.
     * @type {string}
     * @memberof Food
     */
    full_name: string;
    /**
     * 
     * @type {boolean}
     * @memberof Food
     */
    ignore_shopping?: boolean;
    /**
     * 
     * @type {Array<FoodSimple>}
     * @memberof Food
     */
    substitute?: Array<FoodSimple> | null;
    /**
     * 
     * @type {boolean}
     * @memberof Food
     */
    substitute_siblings?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Food
     */
    substitute_children?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Food
     */
    substitute_onhand: boolean;
    /**
     * 
     * @type {Array<FoodInheritField>}
     * @memberof Food
     */
    child_inherit_fields?: Array<FoodInheritField> | null;
    /**
     * 
     * @type {string}
     * @memberof Food
     */
    open_data_slug?: string | null;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface FoodInheritField
 */
export interface FoodInheritField {
    /**
     * 
     * @type {number}
     * @memberof FoodInheritField
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof FoodInheritField
     */
    name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FoodInheritField
     */
    field?: string | null;
}
/**
 * 
 * @export
 * @interface FoodShoppingUpdate
 */
export interface FoodShoppingUpdate {
    /**
     * 
     * @type {number}
     * @memberof FoodShoppingUpdate
     */
    id?: number;
    /**
     * Amount of food to add to the shopping list
     * @type {number}
     * @memberof FoodShoppingUpdate
     */
    amount?: number | null;
    /**
     * ID of unit to use for the shopping list
     * @type {number}
     * @memberof FoodShoppingUpdate
     */
    unit?: number | null;
    /**
     * When set to true will delete all food from active shopping lists.  * `true` - true
     * @type {DeleteEnum}
     * @memberof FoodShoppingUpdate
     */
    _delete: DeleteEnum | null;
}
/**
 * 
 * @export
 * @interface FoodSimple
 */
export interface FoodSimple {
    /**
     * 
     * @type {number}
     * @memberof FoodSimple
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof FoodSimple
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof FoodSimple
     */
    plural_name?: string | null;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface Group
 */
export interface Group {
    /**
     * 
     * @type {number}
     * @memberof Group
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    name: string;
}
/**
 * 
 * @export
 * @interface ImportLog
 */
export interface ImportLog {
    /**
     * 
     * @type {number}
     * @memberof ImportLog
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ImportLog
     */
    type: string;
    /**
     * 
     * @type {string}
     * @memberof ImportLog
     */
    msg?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ImportLog
     */
    running?: boolean;
    /**
     * 
     * @type {Keyword}
     * @memberof ImportLog
     */
    keyword: Keyword;
    /**
     * 
     * @type {number}
     * @memberof ImportLog
     */
    total_recipes?: number;
    /**
     * 
     * @type {number}
     * @memberof ImportLog
     */
    imported_recipes?: number;
    /**
     * 
     * @type {number}
     * @memberof ImportLog
     */
    created_by: number;
    /**
     * 
     * @type {string}
     * @memberof ImportLog
     */
    created_at: string;
}
/**
 * Adds nested create feature
 * @export
 * @interface Ingredient
 */
export interface Ingredient {
    /**
     * 
     * @type {number}
     * @memberof Ingredient
     */
    id?: number;
    /**
     * 
     * @type {Food}
     * @memberof Ingredient
     */
    food: Food | null;
    /**
     * 
     * @type {Unit}
     * @memberof Ingredient
     */
    unit: Unit | null;
    /**
     * 
     * @type {number}
     * @memberof Ingredient
     */
    amount: number;
    /**
     * 
     * @type {Array<any>}
     * @memberof Ingredient
     */
    conversions: Array<any>;
    /**
     * 
     * @type {string}
     * @memberof Ingredient
     */
    note?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Ingredient
     */
    order?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Ingredient
     */
    is_header?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Ingredient
     */
    no_amount?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Ingredient
     */
    original_text?: string | null;
    /**
     * 
     * @type {Array<any>}
     * @memberof Ingredient
     */
    used_in_recipes: Array<any>;
    /**
     * 
     * @type {boolean}
     * @memberof Ingredient
     */
    always_use_plural_unit?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Ingredient
     */
    always_use_plural_food?: boolean;
}
/**
 * 
 * @export
 * @interface IngredientString
 */
export interface IngredientString {
    /**
     * 
     * @type {string}
     * @memberof IngredientString
     */
    text: string;
}
/**
 * Adds nested create feature
 * @export
 * @interface InviteLink
 */
export interface InviteLink {
    /**
     * 
     * @type {number}
     * @memberof InviteLink
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof InviteLink
     */
    uuid: string;
    /**
     * 
     * @type {string}
     * @memberof InviteLink
     */
    email?: string;
    /**
     * 
     * @type {Group}
     * @memberof InviteLink
     */
    group: Group;
    /**
     * 
     * @type {string}
     * @memberof InviteLink
     */
    valid_until?: string;
    /**
     * 
     * @type {number}
     * @memberof InviteLink
     */
    used_by?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof InviteLink
     */
    reusable?: boolean;
    /**
     * 
     * @type {string}
     * @memberof InviteLink
     */
    internal_note?: string | null;
    /**
     * 
     * @type {number}
     * @memberof InviteLink
     */
    created_by: number;
    /**
     * 
     * @type {string}
     * @memberof InviteLink
     */
    created_at: string;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface Keyword
 */
export interface Keyword {
    /**
     * 
     * @type {number}
     * @memberof Keyword
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Keyword
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Keyword
     */
    label: string;
    /**
     * 
     * @type {string}
     * @memberof Keyword
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof Keyword
     */
    parent: number;
    /**
     * 
     * @type {number}
     * @memberof Keyword
     */
    numchild: number;
    /**
     * 
     * @type {string}
     * @memberof Keyword
     */
    created_at: string;
    /**
     * 
     * @type {string}
     * @memberof Keyword
     */
    updated_at: string;
    /**
     * Returns a string representation of a tree node and it\'s ancestors, e.g. \'Cuisine > Asian > Chinese > Catonese\'.
     * @type {string}
     * @memberof Keyword
     */
    full_name: string;
}
/**
 * 
 * @export
 * @interface KeywordLabel
 */
export interface KeywordLabel {
    /**
     * 
     * @type {number}
     * @memberof KeywordLabel
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof KeywordLabel
     */
    label: string;
}
/**
 * Adds nested create feature
 * @export
 * @interface MealPlan
 */
export interface MealPlan {
    /**
     * 
     * @type {number}
     * @memberof MealPlan
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof MealPlan
     */
    title?: string;
    /**
     * 
     * @type {RecipeOverview}
     * @memberof MealPlan
     */
    recipe?: RecipeOverview | null;
    /**
     * 
     * @type {number}
     * @memberof MealPlan
     */
    servings: number;
    /**
     * 
     * @type {string}
     * @memberof MealPlan
     */
    note?: string;
    /**
     * 
     * @type {string}
     * @memberof MealPlan
     */
    note_markdown: string;
    /**
     * 
     * @type {string}
     * @memberof MealPlan
     */
    from_date: string;
    /**
     * 
     * @type {string}
     * @memberof MealPlan
     */
    to_date?: string;
    /**
     * 
     * @type {MealType}
     * @memberof MealPlan
     */
    meal_type: MealType;
    /**
     * 
     * @type {number}
     * @memberof MealPlan
     */
    created_by: number;
    /**
     * 
     * @type {Array<User>}
     * @memberof MealPlan
     */
    shared?: Array<User> | null;
    /**
     * 
     * @type {string}
     * @memberof MealPlan
     */
    recipe_name: string;
    /**
     * 
     * @type {string}
     * @memberof MealPlan
     */
    meal_type_name: string;
    /**
     * 
     * @type {boolean}
     * @memberof MealPlan
     */
    shopping: boolean;
}
/**
 * Adds nested create feature
 * @export
 * @interface MealType
 */
export interface MealType {
    /**
     * 
     * @type {number}
     * @memberof MealType
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof MealType
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof MealType
     */
    order?: number;
    /**
     * 
     * @type {string}
     * @memberof MealType
     */
    time?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MealType
     */
    color?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof MealType
     */
    _default?: boolean;
    /**
     * 
     * @type {number}
     * @memberof MealType
     */
    created_by: number;
}
/**
 * * `DB` - Dropbox * `NEXTCLOUD` - Nextcloud * `LOCAL` - Local
 * @export
 * @enum {string}
 */
export enum MethodEnum {
    Db = 'DB',
    Nextcloud = 'NEXTCLOUD',
    Local = 'LOCAL'
}

/**
 * 
 * @export
 * @interface NutritionInformation
 */
export interface NutritionInformation {
    /**
     * 
     * @type {number}
     * @memberof NutritionInformation
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof NutritionInformation
     */
    carbohydrates: number;
    /**
     * 
     * @type {number}
     * @memberof NutritionInformation
     */
    fats: number;
    /**
     * 
     * @type {number}
     * @memberof NutritionInformation
     */
    proteins: number;
    /**
     * 
     * @type {number}
     * @memberof NutritionInformation
     */
    calories: number;
    /**
     * 
     * @type {string}
     * @memberof NutritionInformation
     */
    source?: string | null;
}
/**
 * 
 * @export
 * @interface PaginatedAutomationList
 */
export interface PaginatedAutomationList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedAutomationList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedAutomationList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedAutomationList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Automation>}
     * @memberof PaginatedAutomationList
     */
    results?: Array<Automation>;
}
/**
 * 
 * @export
 * @interface PaginatedBookmarkletImportListList
 */
export interface PaginatedBookmarkletImportListList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedBookmarkletImportListList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedBookmarkletImportListList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedBookmarkletImportListList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<BookmarkletImportList>}
     * @memberof PaginatedBookmarkletImportListList
     */
    results?: Array<BookmarkletImportList>;
}
/**
 * 
 * @export
 * @interface PaginatedCookLogList
 */
export interface PaginatedCookLogList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedCookLogList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedCookLogList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedCookLogList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<CookLog>}
     * @memberof PaginatedCookLogList
     */
    results?: Array<CookLog>;
}
/**
 * 
 * @export
 * @interface PaginatedCustomFilterList
 */
export interface PaginatedCustomFilterList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedCustomFilterList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedCustomFilterList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedCustomFilterList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<CustomFilter>}
     * @memberof PaginatedCustomFilterList
     */
    results?: Array<CustomFilter>;
}
/**
 * 
 * @export
 * @interface PaginatedExportLogList
 */
export interface PaginatedExportLogList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedExportLogList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedExportLogList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedExportLogList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<ExportLog>}
     * @memberof PaginatedExportLogList
     */
    results?: Array<ExportLog>;
}
/**
 * 
 * @export
 * @interface PaginatedFoodList
 */
export interface PaginatedFoodList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedFoodList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedFoodList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedFoodList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Food>}
     * @memberof PaginatedFoodList
     */
    results?: Array<Food>;
}
/**
 * 
 * @export
 * @interface PaginatedImportLogList
 */
export interface PaginatedImportLogList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedImportLogList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedImportLogList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedImportLogList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<ImportLog>}
     * @memberof PaginatedImportLogList
     */
    results?: Array<ImportLog>;
}
/**
 * 
 * @export
 * @interface PaginatedIngredientList
 */
export interface PaginatedIngredientList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedIngredientList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedIngredientList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedIngredientList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Ingredient>}
     * @memberof PaginatedIngredientList
     */
    results?: Array<Ingredient>;
}
/**
 * 
 * @export
 * @interface PaginatedInviteLinkList
 */
export interface PaginatedInviteLinkList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedInviteLinkList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedInviteLinkList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedInviteLinkList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<InviteLink>}
     * @memberof PaginatedInviteLinkList
     */
    results?: Array<InviteLink>;
}
/**
 * 
 * @export
 * @interface PaginatedKeywordList
 */
export interface PaginatedKeywordList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedKeywordList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedKeywordList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedKeywordList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Keyword>}
     * @memberof PaginatedKeywordList
     */
    results?: Array<Keyword>;
}
/**
 * 
 * @export
 * @interface PaginatedMealPlanList
 */
export interface PaginatedMealPlanList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedMealPlanList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedMealPlanList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedMealPlanList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<MealPlan>}
     * @memberof PaginatedMealPlanList
     */
    results?: Array<MealPlan>;
}
/**
 * 
 * @export
 * @interface PaginatedMealTypeList
 */
export interface PaginatedMealTypeList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedMealTypeList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedMealTypeList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedMealTypeList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<MealType>}
     * @memberof PaginatedMealTypeList
     */
    results?: Array<MealType>;
}
/**
 * 
 * @export
 * @interface PaginatedPropertyList
 */
export interface PaginatedPropertyList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedPropertyList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPropertyList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPropertyList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Property>}
     * @memberof PaginatedPropertyList
     */
    results?: Array<Property>;
}
/**
 * 
 * @export
 * @interface PaginatedPropertyTypeList
 */
export interface PaginatedPropertyTypeList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedPropertyTypeList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPropertyTypeList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPropertyTypeList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<PropertyType>}
     * @memberof PaginatedPropertyTypeList
     */
    results?: Array<PropertyType>;
}
/**
 * 
 * @export
 * @interface PaginatedRecipeBookEntryList
 */
export interface PaginatedRecipeBookEntryList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedRecipeBookEntryList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedRecipeBookEntryList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedRecipeBookEntryList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<RecipeBookEntry>}
     * @memberof PaginatedRecipeBookEntryList
     */
    results?: Array<RecipeBookEntry>;
}
/**
 * 
 * @export
 * @interface PaginatedRecipeBookList
 */
export interface PaginatedRecipeBookList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedRecipeBookList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedRecipeBookList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedRecipeBookList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<RecipeBook>}
     * @memberof PaginatedRecipeBookList
     */
    results?: Array<RecipeBook>;
}
/**
 * 
 * @export
 * @interface PaginatedRecipeOverviewList
 */
export interface PaginatedRecipeOverviewList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedRecipeOverviewList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedRecipeOverviewList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedRecipeOverviewList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<RecipeOverview>}
     * @memberof PaginatedRecipeOverviewList
     */
    results?: Array<RecipeOverview>;
}
/**
 * 
 * @export
 * @interface PaginatedShoppingListEntryList
 */
export interface PaginatedShoppingListEntryList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedShoppingListEntryList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedShoppingListEntryList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedShoppingListEntryList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<ShoppingListEntry>}
     * @memberof PaginatedShoppingListEntryList
     */
    results?: Array<ShoppingListEntry>;
}
/**
 * 
 * @export
 * @interface PaginatedShoppingListRecipeList
 */
export interface PaginatedShoppingListRecipeList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedShoppingListRecipeList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedShoppingListRecipeList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedShoppingListRecipeList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<ShoppingListRecipe>}
     * @memberof PaginatedShoppingListRecipeList
     */
    results?: Array<ShoppingListRecipe>;
}
/**
 * 
 * @export
 * @interface PaginatedStepList
 */
export interface PaginatedStepList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedStepList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedStepList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedStepList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Step>}
     * @memberof PaginatedStepList
     */
    results?: Array<Step>;
}
/**
 * 
 * @export
 * @interface PaginatedSupermarketCategoryList
 */
export interface PaginatedSupermarketCategoryList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedSupermarketCategoryList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSupermarketCategoryList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSupermarketCategoryList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<SupermarketCategory>}
     * @memberof PaginatedSupermarketCategoryList
     */
    results?: Array<SupermarketCategory>;
}
/**
 * 
 * @export
 * @interface PaginatedSupermarketCategoryRelationList
 */
export interface PaginatedSupermarketCategoryRelationList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedSupermarketCategoryRelationList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSupermarketCategoryRelationList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSupermarketCategoryRelationList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<SupermarketCategoryRelation>}
     * @memberof PaginatedSupermarketCategoryRelationList
     */
    results?: Array<SupermarketCategoryRelation>;
}
/**
 * 
 * @export
 * @interface PaginatedSupermarketList
 */
export interface PaginatedSupermarketList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedSupermarketList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSupermarketList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSupermarketList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Supermarket>}
     * @memberof PaginatedSupermarketList
     */
    results?: Array<Supermarket>;
}
/**
 * 
 * @export
 * @interface PaginatedSyncList
 */
export interface PaginatedSyncList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedSyncList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSyncList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSyncList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Sync>}
     * @memberof PaginatedSyncList
     */
    results?: Array<Sync>;
}
/**
 * 
 * @export
 * @interface PaginatedSyncLogList
 */
export interface PaginatedSyncLogList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedSyncLogList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSyncLogList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSyncLogList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<SyncLog>}
     * @memberof PaginatedSyncLogList
     */
    results?: Array<SyncLog>;
}
/**
 * 
 * @export
 * @interface PaginatedUnitConversionList
 */
export interface PaginatedUnitConversionList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedUnitConversionList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedUnitConversionList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedUnitConversionList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<UnitConversion>}
     * @memberof PaginatedUnitConversionList
     */
    results?: Array<UnitConversion>;
}
/**
 * 
 * @export
 * @interface PaginatedUnitList
 */
export interface PaginatedUnitList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedUnitList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedUnitList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedUnitList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Unit>}
     * @memberof PaginatedUnitList
     */
    results?: Array<Unit>;
}
/**
 * 
 * @export
 * @interface PaginatedUserFileList
 */
export interface PaginatedUserFileList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedUserFileList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedUserFileList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedUserFileList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<UserFile>}
     * @memberof PaginatedUserFileList
     */
    results?: Array<UserFile>;
}
/**
 * 
 * @export
 * @interface PaginatedUserSpaceList
 */
export interface PaginatedUserSpaceList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedUserSpaceList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedUserSpaceList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedUserSpaceList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<UserSpace>}
     * @memberof PaginatedUserSpaceList
     */
    results?: Array<UserSpace>;
}
/**
 * 
 * @export
 * @interface PaginatedViewLogList
 */
export interface PaginatedViewLogList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedViewLogList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedViewLogList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedViewLogList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<ViewLog>}
     * @memberof PaginatedViewLogList
     */
    results?: Array<ViewLog>;
}
/**
 * 
 * @export
 * @interface ParsedIngredient
 */
export interface ParsedIngredient {
    /**
     * 
     * @type {number}
     * @memberof ParsedIngredient
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof ParsedIngredient
     */
    unit: string;
    /**
     * 
     * @type {string}
     * @memberof ParsedIngredient
     */
    food: string;
    /**
     * 
     * @type {string}
     * @memberof ParsedIngredient
     */
    note: string;
}
/**
 * 
 * @export
 * @interface PatchedAccessToken
 */
export interface PatchedAccessToken {
    /**
     * 
     * @type {number}
     * @memberof PatchedAccessToken
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedAccessToken
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedAccessToken
     */
    expires?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedAccessToken
     */
    scope?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedAccessToken
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedAccessToken
     */
    updated?: string;
}
/**
 * 
 * @export
 * @interface PatchedAutomation
 */
export interface PatchedAutomation {
    /**
     * 
     * @type {number}
     * @memberof PatchedAutomation
     */
    id?: number;
    /**
     * 
     * @type {TypeEnum}
     * @memberof PatchedAutomation
     */
    type?: TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof PatchedAutomation
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedAutomation
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedAutomation
     */
    param_1?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedAutomation
     */
    param_2?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedAutomation
     */
    param_3?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedAutomation
     */
    order?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedAutomation
     */
    disabled?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PatchedAutomation
     */
    created_by?: number;
}
/**
 * 
 * @export
 * @interface PatchedBookmarkletImport
 */
export interface PatchedBookmarkletImport {
    /**
     * 
     * @type {number}
     * @memberof PatchedBookmarkletImport
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedBookmarkletImport
     */
    url?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedBookmarkletImport
     */
    html?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedBookmarkletImport
     */
    created_by?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedBookmarkletImport
     */
    created_at?: string;
}
/**
 * 
 * @export
 * @interface PatchedConnectorConfigConfig
 */
export interface PatchedConnectorConfigConfig {
    /**
     * 
     * @type {number}
     * @memberof PatchedConnectorConfigConfig
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedConnectorConfigConfig
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedConnectorConfigConfig
     */
    url?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedConnectorConfigConfig
     */
    token?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedConnectorConfigConfig
     */
    todo_entity?: string | null;
    /**
     * Is Connector Enabled
     * @type {boolean}
     * @memberof PatchedConnectorConfigConfig
     */
    enabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedConnectorConfigConfig
     */
    on_shopping_list_entry_created_enabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedConnectorConfigConfig
     */
    on_shopping_list_entry_updated_enabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedConnectorConfigConfig
     */
    on_shopping_list_entry_deleted_enabled?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PatchedConnectorConfigConfig
     */
    created_by?: number;
}
/**
 * 
 * @export
 * @interface PatchedCookLog
 */
export interface PatchedCookLog {
    /**
     * 
     * @type {number}
     * @memberof PatchedCookLog
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedCookLog
     */
    recipe?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedCookLog
     */
    servings?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedCookLog
     */
    rating?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedCookLog
     */
    comment?: string | null;
    /**
     * 
     * @type {User}
     * @memberof PatchedCookLog
     */
    created_by?: User;
    /**
     * 
     * @type {string}
     * @memberof PatchedCookLog
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedCookLog
     */
    updated_at?: string;
}
/**
 * Adds nested create feature
 * @export
 * @interface PatchedCustomFilter
 */
export interface PatchedCustomFilter {
    /**
     * 
     * @type {number}
     * @memberof PatchedCustomFilter
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedCustomFilter
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedCustomFilter
     */
    search?: string;
    /**
     * 
     * @type {Array<User>}
     * @memberof PatchedCustomFilter
     */
    shared?: Array<User>;
    /**
     * 
     * @type {number}
     * @memberof PatchedCustomFilter
     */
    created_by?: number;
}
/**
 * 
 * @export
 * @interface PatchedExportLog
 */
export interface PatchedExportLog {
    /**
     * 
     * @type {number}
     * @memberof PatchedExportLog
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedExportLog
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedExportLog
     */
    msg?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedExportLog
     */
    running?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PatchedExportLog
     */
    total_recipes?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedExportLog
     */
    exported_recipes?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedExportLog
     */
    cache_duration?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedExportLog
     */
    possibly_not_expired?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PatchedExportLog
     */
    created_by?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedExportLog
     */
    created_at?: string;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface PatchedFood
 */
export interface PatchedFood {
    /**
     * 
     * @type {number}
     * @memberof PatchedFood
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedFood
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedFood
     */
    plural_name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFood
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedFood
     */
    shopping?: string;
    /**
     * 
     * @type {RecipeSimple}
     * @memberof PatchedFood
     */
    recipe?: RecipeSimple | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFood
     */
    url?: string | null;
    /**
     * 
     * @type {Array<Property>}
     * @memberof PatchedFood
     */
    properties?: Array<Property> | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedFood
     */
    properties_food_amount?: number;
    /**
     * 
     * @type {Unit}
     * @memberof PatchedFood
     */
    properties_food_unit?: Unit | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedFood
     */
    fdc_id?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedFood
     */
    food_onhand?: boolean | null;
    /**
     * 
     * @type {SupermarketCategory}
     * @memberof PatchedFood
     */
    supermarket_category?: SupermarketCategory | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedFood
     */
    parent?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedFood
     */
    numchild?: number;
    /**
     * 
     * @type {Array<FoodInheritField>}
     * @memberof PatchedFood
     */
    inherit_fields?: Array<FoodInheritField> | null;
    /**
     * Returns a string representation of a tree node and it\'s ancestors, e.g. \'Cuisine > Asian > Chinese > Catonese\'.
     * @type {string}
     * @memberof PatchedFood
     */
    full_name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedFood
     */
    ignore_shopping?: boolean;
    /**
     * 
     * @type {Array<FoodSimple>}
     * @memberof PatchedFood
     */
    substitute?: Array<FoodSimple> | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedFood
     */
    substitute_siblings?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedFood
     */
    substitute_children?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedFood
     */
    substitute_onhand?: boolean;
    /**
     * 
     * @type {Array<FoodInheritField>}
     * @memberof PatchedFood
     */
    child_inherit_fields?: Array<FoodInheritField> | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFood
     */
    open_data_slug?: string | null;
}
/**
 * 
 * @export
 * @interface PatchedImportLog
 */
export interface PatchedImportLog {
    /**
     * 
     * @type {number}
     * @memberof PatchedImportLog
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedImportLog
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedImportLog
     */
    msg?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedImportLog
     */
    running?: boolean;
    /**
     * 
     * @type {Keyword}
     * @memberof PatchedImportLog
     */
    keyword?: Keyword;
    /**
     * 
     * @type {number}
     * @memberof PatchedImportLog
     */
    total_recipes?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedImportLog
     */
    imported_recipes?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedImportLog
     */
    created_by?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedImportLog
     */
    created_at?: string;
}
/**
 * Adds nested create feature
 * @export
 * @interface PatchedIngredient
 */
export interface PatchedIngredient {
    /**
     * 
     * @type {number}
     * @memberof PatchedIngredient
     */
    id?: number;
    /**
     * 
     * @type {Food}
     * @memberof PatchedIngredient
     */
    food?: Food | null;
    /**
     * 
     * @type {Unit}
     * @memberof PatchedIngredient
     */
    unit?: Unit | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedIngredient
     */
    amount?: number;
    /**
     * 
     * @type {Array<any>}
     * @memberof PatchedIngredient
     */
    conversions?: Array<any>;
    /**
     * 
     * @type {string}
     * @memberof PatchedIngredient
     */
    note?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedIngredient
     */
    order?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedIngredient
     */
    is_header?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedIngredient
     */
    no_amount?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PatchedIngredient
     */
    original_text?: string | null;
    /**
     * 
     * @type {Array<any>}
     * @memberof PatchedIngredient
     */
    used_in_recipes?: Array<any>;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedIngredient
     */
    always_use_plural_unit?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedIngredient
     */
    always_use_plural_food?: boolean;
}
/**
 * Adds nested create feature
 * @export
 * @interface PatchedInviteLink
 */
export interface PatchedInviteLink {
    /**
     * 
     * @type {number}
     * @memberof PatchedInviteLink
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedInviteLink
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedInviteLink
     */
    email?: string;
    /**
     * 
     * @type {Group}
     * @memberof PatchedInviteLink
     */
    group?: Group;
    /**
     * 
     * @type {string}
     * @memberof PatchedInviteLink
     */
    valid_until?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedInviteLink
     */
    used_by?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedInviteLink
     */
    reusable?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PatchedInviteLink
     */
    internal_note?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedInviteLink
     */
    created_by?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedInviteLink
     */
    created_at?: string;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface PatchedKeyword
 */
export interface PatchedKeyword {
    /**
     * 
     * @type {number}
     * @memberof PatchedKeyword
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedKeyword
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedKeyword
     */
    label?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedKeyword
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedKeyword
     */
    parent?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedKeyword
     */
    numchild?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedKeyword
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedKeyword
     */
    updated_at?: string;
    /**
     * Returns a string representation of a tree node and it\'s ancestors, e.g. \'Cuisine > Asian > Chinese > Catonese\'.
     * @type {string}
     * @memberof PatchedKeyword
     */
    full_name?: string;
}
/**
 * Adds nested create feature
 * @export
 * @interface PatchedMealPlan
 */
export interface PatchedMealPlan {
    /**
     * 
     * @type {number}
     * @memberof PatchedMealPlan
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedMealPlan
     */
    title?: string;
    /**
     * 
     * @type {RecipeOverview}
     * @memberof PatchedMealPlan
     */
    recipe?: RecipeOverview | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedMealPlan
     */
    servings?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedMealPlan
     */
    note?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedMealPlan
     */
    note_markdown?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedMealPlan
     */
    from_date?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedMealPlan
     */
    to_date?: string;
    /**
     * 
     * @type {MealType}
     * @memberof PatchedMealPlan
     */
    meal_type?: MealType;
    /**
     * 
     * @type {number}
     * @memberof PatchedMealPlan
     */
    created_by?: number;
    /**
     * 
     * @type {Array<User>}
     * @memberof PatchedMealPlan
     */
    shared?: Array<User> | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedMealPlan
     */
    recipe_name?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedMealPlan
     */
    meal_type_name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedMealPlan
     */
    shopping?: boolean;
}
/**
 * Adds nested create feature
 * @export
 * @interface PatchedMealType
 */
export interface PatchedMealType {
    /**
     * 
     * @type {number}
     * @memberof PatchedMealType
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedMealType
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedMealType
     */
    order?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedMealType
     */
    time?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedMealType
     */
    color?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedMealType
     */
    _default?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PatchedMealType
     */
    created_by?: number;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface PatchedProperty
 */
export interface PatchedProperty {
    /**
     * 
     * @type {number}
     * @memberof PatchedProperty
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedProperty
     */
    property_amount?: number | null;
    /**
     * 
     * @type {PropertyType}
     * @memberof PatchedProperty
     */
    property_type?: PropertyType;
}
/**
 * Adds nested create feature
 * @export
 * @interface PatchedPropertyType
 */
export interface PatchedPropertyType {
    /**
     * 
     * @type {number}
     * @memberof PatchedPropertyType
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedPropertyType
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedPropertyType
     */
    unit?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedPropertyType
     */
    description?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedPropertyType
     */
    order?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedPropertyType
     */
    open_data_slug?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedPropertyType
     */
    fdc_id?: number | null;
}
/**
 * Adds nested create feature
 * @export
 * @interface PatchedRecipe
 */
export interface PatchedRecipe {
    /**
     * 
     * @type {number}
     * @memberof PatchedRecipe
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedRecipe
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedRecipe
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedRecipe
     */
    image?: string | null;
    /**
     * 
     * @type {Array<Keyword>}
     * @memberof PatchedRecipe
     */
    keywords?: Array<Keyword>;
    /**
     * 
     * @type {Array<Step>}
     * @memberof PatchedRecipe
     */
    steps?: Array<Step>;
    /**
     * 
     * @type {number}
     * @memberof PatchedRecipe
     */
    working_time?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedRecipe
     */
    waiting_time?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedRecipe
     */
    created_by?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedRecipe
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedRecipe
     */
    updated_at?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedRecipe
     */
    source_url?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedRecipe
     */
    internal?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedRecipe
     */
    show_ingredient_overview?: boolean;
    /**
     * 
     * @type {NutritionInformation}
     * @memberof PatchedRecipe
     */
    nutrition?: NutritionInformation | null;
    /**
     * 
     * @type {Array<Property>}
     * @memberof PatchedRecipe
     */
    properties?: Array<Property>;
    /**
     * 
     * @type {any}
     * @memberof PatchedRecipe
     */
    food_properties?: any | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedRecipe
     */
    servings?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedRecipe
     */
    file_path?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedRecipe
     */
    servings_text?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedRecipe
     */
    rating?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedRecipe
     */
    last_cooked?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedRecipe
     */
    _private?: boolean;
    /**
     * 
     * @type {Array<User>}
     * @memberof PatchedRecipe
     */
    shared?: Array<User>;
}
/**
 * Adds nested create feature
 * @export
 * @interface PatchedRecipeBook
 */
export interface PatchedRecipeBook {
    /**
     * 
     * @type {number}
     * @memberof PatchedRecipeBook
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedRecipeBook
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedRecipeBook
     */
    description?: string;
    /**
     * 
     * @type {Array<User>}
     * @memberof PatchedRecipeBook
     */
    shared?: Array<User>;
    /**
     * 
     * @type {number}
     * @memberof PatchedRecipeBook
     */
    created_by?: number;
    /**
     * 
     * @type {CustomFilter}
     * @memberof PatchedRecipeBook
     */
    filter?: CustomFilter | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedRecipeBook
     */
    order?: number;
}
/**
 * 
 * @export
 * @interface PatchedRecipeBookEntry
 */
export interface PatchedRecipeBookEntry {
    /**
     * 
     * @type {number}
     * @memberof PatchedRecipeBookEntry
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedRecipeBookEntry
     */
    book?: number;
    /**
     * 
     * @type {RecipeBook}
     * @memberof PatchedRecipeBookEntry
     */
    book_content?: RecipeBook;
    /**
     * 
     * @type {number}
     * @memberof PatchedRecipeBookEntry
     */
    recipe?: number;
    /**
     * 
     * @type {RecipeOverview}
     * @memberof PatchedRecipeBookEntry
     */
    recipe_content?: RecipeOverview;
}
/**
 * Adds nested create feature
 * @export
 * @interface PatchedShoppingListEntry
 */
export interface PatchedShoppingListEntry {
    /**
     * 
     * @type {number}
     * @memberof PatchedShoppingListEntry
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedShoppingListEntry
     */
    list_recipe?: number | null;
    /**
     * 
     * @type {Food}
     * @memberof PatchedShoppingListEntry
     */
    food?: Food | null;
    /**
     * 
     * @type {Unit}
     * @memberof PatchedShoppingListEntry
     */
    unit?: Unit | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedShoppingListEntry
     */
    amount?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedShoppingListEntry
     */
    order?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedShoppingListEntry
     */
    checked?: boolean;
    /**
     * 
     * @type {ShoppingListRecipe}
     * @memberof PatchedShoppingListEntry
     */
    recipe_mealplan?: ShoppingListRecipe;
    /**
     * 
     * @type {User}
     * @memberof PatchedShoppingListEntry
     */
    created_by?: User;
    /**
     * 
     * @type {string}
     * @memberof PatchedShoppingListEntry
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedShoppingListEntry
     */
    updated_at?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedShoppingListEntry
     */
    completed_at?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedShoppingListEntry
     */
    delay_until?: string | null;
}
/**
 * 
 * @export
 * @interface PatchedShoppingListRecipe
 */
export interface PatchedShoppingListRecipe {
    /**
     * 
     * @type {number}
     * @memberof PatchedShoppingListRecipe
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedShoppingListRecipe
     */
    recipe_name?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedShoppingListRecipe
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedShoppingListRecipe
     */
    recipe?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedShoppingListRecipe
     */
    mealplan?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedShoppingListRecipe
     */
    servings?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedShoppingListRecipe
     */
    mealplan_note?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedShoppingListRecipe
     */
    mealplan_from_date?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedShoppingListRecipe
     */
    mealplan_type?: string;
}
/**
 * Adds nested create feature
 * @export
 * @interface PatchedSpace
 */
export interface PatchedSpace {
    /**
     * 
     * @type {number}
     * @memberof PatchedSpace
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedSpace
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedSpace
     */
    created_by?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedSpace
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedSpace
     */
    message?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedSpace
     */
    max_recipes?: number;
    /**
     * Maximum file storage for space in MB. 0 for unlimited, -1 to disable file upload.
     * @type {number}
     * @memberof PatchedSpace
     */
    max_file_storage_mb?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedSpace
     */
    max_users?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedSpace
     */
    allow_sharing?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedSpace
     */
    demo?: boolean;
    /**
     * 
     * @type {Array<FoodInheritField>}
     * @memberof PatchedSpace
     */
    food_inherit?: Array<FoodInheritField>;
    /**
     * 
     * @type {number}
     * @memberof PatchedSpace
     */
    user_count?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedSpace
     */
    recipe_count?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedSpace
     */
    file_size_mb?: number;
    /**
     * 
     * @type {UserFileView}
     * @memberof PatchedSpace
     */
    image?: UserFileView | null;
    /**
     * 
     * @type {UserFileView}
     * @memberof PatchedSpace
     */
    nav_logo?: UserFileView | null;
    /**
     * 
     * @type {SpaceThemeEnum}
     * @memberof PatchedSpace
     */
    space_theme?: SpaceThemeEnum;
    /**
     * 
     * @type {UserFileView}
     * @memberof PatchedSpace
     */
    custom_space_theme?: UserFileView | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedSpace
     */
    nav_bg_color?: string;
    /**
     * 
     * @type {SpaceNavTextColorEnum}
     * @memberof PatchedSpace
     */
    nav_text_color?: SpaceNavTextColorEnum;
    /**
     * 
     * @type {UserFileView}
     * @memberof PatchedSpace
     */
    logo_color_32?: UserFileView | null;
    /**
     * 
     * @type {UserFileView}
     * @memberof PatchedSpace
     */
    logo_color_128?: UserFileView | null;
    /**
     * 
     * @type {UserFileView}
     * @memberof PatchedSpace
     */
    logo_color_144?: UserFileView | null;
    /**
     * 
     * @type {UserFileView}
     * @memberof PatchedSpace
     */
    logo_color_180?: UserFileView | null;
    /**
     * 
     * @type {UserFileView}
     * @memberof PatchedSpace
     */
    logo_color_192?: UserFileView | null;
    /**
     * 
     * @type {UserFileView}
     * @memberof PatchedSpace
     */
    logo_color_512?: UserFileView | null;
    /**
     * 
     * @type {UserFileView}
     * @memberof PatchedSpace
     */
    logo_color_svg?: UserFileView | null;
}
/**
 * Adds nested create feature
 * @export
 * @interface PatchedStep
 */
export interface PatchedStep {
    /**
     * 
     * @type {number}
     * @memberof PatchedStep
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedStep
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedStep
     */
    instruction?: string;
    /**
     * 
     * @type {Array<Ingredient>}
     * @memberof PatchedStep
     */
    ingredients?: Array<Ingredient>;
    /**
     * 
     * @type {string}
     * @memberof PatchedStep
     */
    instructions_markdown?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedStep
     */
    time?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedStep
     */
    order?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedStep
     */
    show_as_header?: boolean;
    /**
     * 
     * @type {UserFileView}
     * @memberof PatchedStep
     */
    file?: UserFileView | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedStep
     */
    step_recipe?: number | null;
    /**
     * 
     * @type {any}
     * @memberof PatchedStep
     */
    step_recipe_data?: any | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedStep
     */
    numrecipe?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedStep
     */
    show_ingredients_table?: boolean;
}
/**
 * 
 * @export
 * @interface PatchedStorage
 */
export interface PatchedStorage {
    /**
     * 
     * @type {number}
     * @memberof PatchedStorage
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedStorage
     */
    name?: string;
    /**
     * 
     * @type {MethodEnum}
     * @memberof PatchedStorage
     */
    method?: MethodEnum;
    /**
     * 
     * @type {string}
     * @memberof PatchedStorage
     */
    username?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedStorage
     */
    password?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedStorage
     */
    token?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedStorage
     */
    created_by?: number;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface PatchedSupermarket
 */
export interface PatchedSupermarket {
    /**
     * 
     * @type {number}
     * @memberof PatchedSupermarket
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedSupermarket
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedSupermarket
     */
    description?: string | null;
    /**
     * 
     * @type {Array<SupermarketCategoryRelation>}
     * @memberof PatchedSupermarket
     */
    category_to_supermarket?: Array<SupermarketCategoryRelation>;
    /**
     * 
     * @type {string}
     * @memberof PatchedSupermarket
     */
    open_data_slug?: string | null;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface PatchedSupermarketCategory
 */
export interface PatchedSupermarketCategory {
    /**
     * 
     * @type {number}
     * @memberof PatchedSupermarketCategory
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedSupermarketCategory
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedSupermarketCategory
     */
    description?: string | null;
}
/**
 * Adds nested create feature
 * @export
 * @interface PatchedSupermarketCategoryRelation
 */
export interface PatchedSupermarketCategoryRelation {
    /**
     * 
     * @type {number}
     * @memberof PatchedSupermarketCategoryRelation
     */
    id?: number;
    /**
     * 
     * @type {SupermarketCategory}
     * @memberof PatchedSupermarketCategoryRelation
     */
    category?: SupermarketCategory;
    /**
     * 
     * @type {number}
     * @memberof PatchedSupermarketCategoryRelation
     */
    supermarket?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedSupermarketCategoryRelation
     */
    order?: number;
}
/**
 * 
 * @export
 * @interface PatchedSync
 */
export interface PatchedSync {
    /**
     * 
     * @type {number}
     * @memberof PatchedSync
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedSync
     */
    storage?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedSync
     */
    path?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedSync
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PatchedSync
     */
    last_checked?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedSync
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedSync
     */
    updated_at?: string;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface PatchedUnit
 */
export interface PatchedUnit {
    /**
     * 
     * @type {number}
     * @memberof PatchedUnit
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedUnit
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUnit
     */
    plural_name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedUnit
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedUnit
     */
    base_unit?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedUnit
     */
    open_data_slug?: string | null;
}
/**
 * Adds nested create feature
 * @export
 * @interface PatchedUnitConversion
 */
export interface PatchedUnitConversion {
    /**
     * 
     * @type {number}
     * @memberof PatchedUnitConversion
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedUnitConversion
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedUnitConversion
     */
    base_amount?: number;
    /**
     * 
     * @type {Unit}
     * @memberof PatchedUnitConversion
     */
    base_unit?: Unit;
    /**
     * 
     * @type {number}
     * @memberof PatchedUnitConversion
     */
    converted_amount?: number;
    /**
     * 
     * @type {Unit}
     * @memberof PatchedUnitConversion
     */
    converted_unit?: Unit;
    /**
     * 
     * @type {Food}
     * @memberof PatchedUnitConversion
     */
    food?: Food | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedUnitConversion
     */
    open_data_slug?: string | null;
}
/**
 * Adds nested create feature
 * @export
 * @interface PatchedUser
 */
export interface PatchedUser {
    /**
     * 
     * @type {number}
     * @memberof PatchedUser
     */
    id?: number;
    /**
     * Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.
     * @type {string}
     * @memberof PatchedUser
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUser
     */
    first_name?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUser
     */
    last_name?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUser
     */
    display_name?: string;
}
/**
 * Adds nested create feature
 * @export
 * @interface PatchedUserPreference
 */
export interface PatchedUserPreference {
    /**
     * 
     * @type {number}
     * @memberof PatchedUserPreference
     */
    user?: number;
    /**
     * 
     * @type {UserFileView}
     * @memberof PatchedUserPreference
     */
    image?: UserFileView | null;
    /**
     * 
     * @type {ThemeEnum}
     * @memberof PatchedUserPreference
     */
    theme?: ThemeEnum;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserPreference
     */
    nav_bg_color?: string;
    /**
     * 
     * @type {UserPreferenceNavTextColorEnum}
     * @memberof PatchedUserPreference
     */
    nav_text_color?: UserPreferenceNavTextColorEnum;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedUserPreference
     */
    nav_show_logo?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserPreference
     */
    default_unit?: string;
    /**
     * 
     * @type {DefaultPageEnum}
     * @memberof PatchedUserPreference
     */
    default_page?: DefaultPageEnum;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedUserPreference
     */
    use_fractions?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedUserPreference
     */
    use_kj?: boolean;
    /**
     * 
     * @type {Array<User>}
     * @memberof PatchedUserPreference
     */
    plan_share?: Array<User> | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedUserPreference
     */
    nav_sticky?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PatchedUserPreference
     */
    ingredient_decimals?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedUserPreference
     */
    comments?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PatchedUserPreference
     */
    shopping_auto_sync?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedUserPreference
     */
    mealplan_autoadd_shopping?: boolean;
    /**
     * 
     * @type {FoodInheritField}
     * @memberof PatchedUserPreference
     */
    food_inherit_default?: FoodInheritField;
    /**
     * 
     * @type {number}
     * @memberof PatchedUserPreference
     */
    default_delay?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedUserPreference
     */
    mealplan_autoinclude_related?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedUserPreference
     */
    mealplan_autoexclude_onhand?: boolean;
    /**
     * 
     * @type {Array<User>}
     * @memberof PatchedUserPreference
     */
    shopping_share?: Array<User> | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedUserPreference
     */
    shopping_recent_days?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserPreference
     */
    csv_delim?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserPreference
     */
    csv_prefix?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedUserPreference
     */
    filter_to_supermarket?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedUserPreference
     */
    shopping_add_onhand?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedUserPreference
     */
    left_handed?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedUserPreference
     */
    show_step_ingredients?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedUserPreference
     */
    food_children_exist?: boolean;
}
/**
 * Adds nested create feature
 * @export
 * @interface PatchedUserSpace
 */
export interface PatchedUserSpace {
    /**
     * 
     * @type {number}
     * @memberof PatchedUserSpace
     */
    id?: number;
    /**
     * 
     * @type {User}
     * @memberof PatchedUserSpace
     */
    user?: User;
    /**
     * 
     * @type {number}
     * @memberof PatchedUserSpace
     */
    space?: number;
    /**
     * 
     * @type {Array<Group>}
     * @memberof PatchedUserSpace
     */
    groups?: Array<Group>;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedUserSpace
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserSpace
     */
    internal_note?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedUserSpace
     */
    invite_link?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserSpace
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserSpace
     */
    updated_at?: string;
}
/**
 * 
 * @export
 * @interface PatchedViewLog
 */
export interface PatchedViewLog {
    /**
     * 
     * @type {number}
     * @memberof PatchedViewLog
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedViewLog
     */
    recipe?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedViewLog
     */
    created_by?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedViewLog
     */
    created_at?: string;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface Property
 */
export interface Property {
    /**
     * 
     * @type {number}
     * @memberof Property
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof Property
     */
    property_amount: number | null;
    /**
     * 
     * @type {PropertyType}
     * @memberof Property
     */
    property_type: PropertyType;
}
/**
 * Adds nested create feature
 * @export
 * @interface PropertyType
 */
export interface PropertyType {
    /**
     * 
     * @type {number}
     * @memberof PropertyType
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PropertyType
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyType
     */
    unit?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PropertyType
     */
    description?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PropertyType
     */
    order?: number;
    /**
     * 
     * @type {string}
     * @memberof PropertyType
     */
    open_data_slug?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PropertyType
     */
    fdc_id?: number | null;
}
/**
 * Adds nested create feature
 * @export
 * @interface Recipe
 */
export interface Recipe {
    /**
     * 
     * @type {number}
     * @memberof Recipe
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Recipe
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Recipe
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Recipe
     */
    image: string | null;
    /**
     * 
     * @type {Array<Keyword>}
     * @memberof Recipe
     */
    keywords?: Array<Keyword>;
    /**
     * 
     * @type {Array<Step>}
     * @memberof Recipe
     */
    steps: Array<Step>;
    /**
     * 
     * @type {number}
     * @memberof Recipe
     */
    working_time?: number;
    /**
     * 
     * @type {number}
     * @memberof Recipe
     */
    waiting_time?: number;
    /**
     * 
     * @type {number}
     * @memberof Recipe
     */
    created_by: number;
    /**
     * 
     * @type {string}
     * @memberof Recipe
     */
    created_at: string;
    /**
     * 
     * @type {string}
     * @memberof Recipe
     */
    updated_at: string;
    /**
     * 
     * @type {string}
     * @memberof Recipe
     */
    source_url?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Recipe
     */
    internal?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Recipe
     */
    show_ingredient_overview?: boolean;
    /**
     * 
     * @type {NutritionInformation}
     * @memberof Recipe
     */
    nutrition?: NutritionInformation | null;
    /**
     * 
     * @type {Array<Property>}
     * @memberof Recipe
     */
    properties?: Array<Property>;
    /**
     * 
     * @type {any}
     * @memberof Recipe
     */
    food_properties: any | null;
    /**
     * 
     * @type {number}
     * @memberof Recipe
     */
    servings?: number;
    /**
     * 
     * @type {string}
     * @memberof Recipe
     */
    file_path?: string;
    /**
     * 
     * @type {string}
     * @memberof Recipe
     */
    servings_text?: string;
    /**
     * 
     * @type {number}
     * @memberof Recipe
     */
    rating: number | null;
    /**
     * 
     * @type {string}
     * @memberof Recipe
     */
    last_cooked: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Recipe
     */
    _private?: boolean;
    /**
     * 
     * @type {Array<User>}
     * @memberof Recipe
     */
    shared?: Array<User>;
}
/**
 * Adds nested create feature
 * @export
 * @interface RecipeBook
 */
export interface RecipeBook {
    /**
     * 
     * @type {number}
     * @memberof RecipeBook
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof RecipeBook
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeBook
     */
    description?: string;
    /**
     * 
     * @type {Array<User>}
     * @memberof RecipeBook
     */
    shared: Array<User>;
    /**
     * 
     * @type {number}
     * @memberof RecipeBook
     */
    created_by: number;
    /**
     * 
     * @type {CustomFilter}
     * @memberof RecipeBook
     */
    filter?: CustomFilter | null;
    /**
     * 
     * @type {number}
     * @memberof RecipeBook
     */
    order?: number;
}
/**
 * 
 * @export
 * @interface RecipeBookEntry
 */
export interface RecipeBookEntry {
    /**
     * 
     * @type {number}
     * @memberof RecipeBookEntry
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof RecipeBookEntry
     */
    book: number;
    /**
     * 
     * @type {RecipeBook}
     * @memberof RecipeBookEntry
     */
    book_content: RecipeBook;
    /**
     * 
     * @type {number}
     * @memberof RecipeBookEntry
     */
    recipe: number;
    /**
     * 
     * @type {RecipeOverview}
     * @memberof RecipeBookEntry
     */
    recipe_content: RecipeOverview;
}
/**
 * Adds nested create feature
 * @export
 * @interface RecipeFlat
 */
export interface RecipeFlat {
    /**
     * 
     * @type {number}
     * @memberof RecipeFlat
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof RecipeFlat
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeFlat
     */
    image?: string | null;
}
/**
 * Adds nested create feature
 * @export
 * @interface RecipeImage
 */
export interface RecipeImage {
    /**
     * 
     * @type {string}
     * @memberof RecipeImage
     */
    image?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RecipeImage
     */
    image_url?: string | null;
}
/**
 * Adds nested create feature
 * @export
 * @interface RecipeOverview
 */
export interface RecipeOverview {
    /**
     * 
     * @type {number}
     * @memberof RecipeOverview
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof RecipeOverview
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeOverview
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RecipeOverview
     */
    image: string | null;
    /**
     * 
     * @type {Array<KeywordLabel>}
     * @memberof RecipeOverview
     */
    keywords: Array<KeywordLabel>;
    /**
     * 
     * @type {number}
     * @memberof RecipeOverview
     */
    working_time: number;
    /**
     * 
     * @type {number}
     * @memberof RecipeOverview
     */
    waiting_time: number;
    /**
     * 
     * @type {number}
     * @memberof RecipeOverview
     */
    created_by: number;
    /**
     * 
     * @type {string}
     * @memberof RecipeOverview
     */
    created_at: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeOverview
     */
    updated_at: string;
    /**
     * 
     * @type {boolean}
     * @memberof RecipeOverview
     */
    internal: boolean;
    /**
     * 
     * @type {number}
     * @memberof RecipeOverview
     */
    servings: number;
    /**
     * 
     * @type {string}
     * @memberof RecipeOverview
     */
    servings_text: string;
    /**
     * 
     * @type {number}
     * @memberof RecipeOverview
     */
    rating: number | null;
    /**
     * 
     * @type {string}
     * @memberof RecipeOverview
     */
    last_cooked: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof RecipeOverview
     */
    _new: boolean;
    /**
     * 
     * @type {string}
     * @memberof RecipeOverview
     */
    recent: string;
}
/**
 * 
 * @export
 * @interface RecipeShoppingUpdate
 */
export interface RecipeShoppingUpdate {
    /**
     * 
     * @type {number}
     * @memberof RecipeShoppingUpdate
     */
    id?: number;
    /**
     * Existing shopping list to update
     * @type {number}
     * @memberof RecipeShoppingUpdate
     */
    list_recipe?: number | null;
    /**
     * List of ingredient IDs from the recipe to add, if not provided all ingredients will be added.
     * @type {number}
     * @memberof RecipeShoppingUpdate
     */
    ingredients?: number | null;
    /**
     * Providing a list_recipe ID and servings of 0 will delete that shopping list.
     * @type {number}
     * @memberof RecipeShoppingUpdate
     */
    servings?: number | null;
}
/**
 * Adds nested create feature
 * @export
 * @interface RecipeSimple
 */
export interface RecipeSimple {
    /**
     * 
     * @type {number}
     * @memberof RecipeSimple
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof RecipeSimple
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeSimple
     */
    url: string;
}
/**
 * 
 * @export
 * @interface ShareLink
 */
export interface ShareLink {
    /**
     * 
     * @type {number}
     * @memberof ShareLink
     */
    pk: number;
    /**
     * 
     * @type {string}
     * @memberof ShareLink
     */
    share: string;
    /**
     * 
     * @type {string}
     * @memberof ShareLink
     */
    link: string;
}
/**
 * Adds nested create feature
 * @export
 * @interface ShoppingListEntry
 */
export interface ShoppingListEntry {
    /**
     * 
     * @type {number}
     * @memberof ShoppingListEntry
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ShoppingListEntry
     */
    list_recipe?: number | null;
    /**
     * 
     * @type {Food}
     * @memberof ShoppingListEntry
     */
    food: Food | null;
    /**
     * 
     * @type {Unit}
     * @memberof ShoppingListEntry
     */
    unit?: Unit | null;
    /**
     * 
     * @type {number}
     * @memberof ShoppingListEntry
     */
    amount: number;
    /**
     * 
     * @type {number}
     * @memberof ShoppingListEntry
     */
    order?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ShoppingListEntry
     */
    checked?: boolean;
    /**
     * 
     * @type {ShoppingListRecipe}
     * @memberof ShoppingListEntry
     */
    recipe_mealplan: ShoppingListRecipe;
    /**
     * 
     * @type {User}
     * @memberof ShoppingListEntry
     */
    created_by: User;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListEntry
     */
    created_at: string;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListEntry
     */
    updated_at: string;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListEntry
     */
    completed_at?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListEntry
     */
    delay_until?: string | null;
}
/**
 * 
 * @export
 * @interface ShoppingListEntryBulk
 */
export interface ShoppingListEntryBulk {
    /**
     * 
     * @type {Array<any>}
     * @memberof ShoppingListEntryBulk
     */
    ids: Array<any>;
    /**
     * 
     * @type {boolean}
     * @memberof ShoppingListEntryBulk
     */
    checked: boolean;
}
/**
 * 
 * @export
 * @interface ShoppingListRecipe
 */
export interface ShoppingListRecipe {
    /**
     * 
     * @type {number}
     * @memberof ShoppingListRecipe
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListRecipe
     */
    recipe_name: string;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListRecipe
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof ShoppingListRecipe
     */
    recipe?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ShoppingListRecipe
     */
    mealplan?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ShoppingListRecipe
     */
    servings: number;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListRecipe
     */
    mealplan_note: string;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListRecipe
     */
    mealplan_from_date: string;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListRecipe
     */
    mealplan_type: string;
}
/**
 * Adds nested create feature
 * @export
 * @interface Space
 */
export interface Space {
    /**
     * 
     * @type {number}
     * @memberof Space
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Space
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof Space
     */
    created_by: number | null;
    /**
     * 
     * @type {string}
     * @memberof Space
     */
    created_at: string;
    /**
     * 
     * @type {string}
     * @memberof Space
     */
    message?: string;
    /**
     * 
     * @type {number}
     * @memberof Space
     */
    max_recipes: number;
    /**
     * Maximum file storage for space in MB. 0 for unlimited, -1 to disable file upload.
     * @type {number}
     * @memberof Space
     */
    max_file_storage_mb: number;
    /**
     * 
     * @type {number}
     * @memberof Space
     */
    max_users: number;
    /**
     * 
     * @type {boolean}
     * @memberof Space
     */
    allow_sharing: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Space
     */
    demo: boolean;
    /**
     * 
     * @type {Array<FoodInheritField>}
     * @memberof Space
     */
    food_inherit: Array<FoodInheritField>;
    /**
     * 
     * @type {number}
     * @memberof Space
     */
    user_count: number;
    /**
     * 
     * @type {number}
     * @memberof Space
     */
    recipe_count: number;
    /**
     * 
     * @type {number}
     * @memberof Space
     */
    file_size_mb: number;
    /**
     * 
     * @type {UserFileView}
     * @memberof Space
     */
    image?: UserFileView | null;
    /**
     * 
     * @type {UserFileView}
     * @memberof Space
     */
    nav_logo?: UserFileView | null;
    /**
     * 
     * @type {SpaceThemeEnum}
     * @memberof Space
     */
    space_theme?: SpaceThemeEnum;
    /**
     * 
     * @type {UserFileView}
     * @memberof Space
     */
    custom_space_theme?: UserFileView | null;
    /**
     * 
     * @type {string}
     * @memberof Space
     */
    nav_bg_color?: string;
    /**
     * 
     * @type {SpaceNavTextColorEnum}
     * @memberof Space
     */
    nav_text_color?: SpaceNavTextColorEnum;
    /**
     * 
     * @type {UserFileView}
     * @memberof Space
     */
    logo_color_32?: UserFileView | null;
    /**
     * 
     * @type {UserFileView}
     * @memberof Space
     */
    logo_color_128?: UserFileView | null;
    /**
     * 
     * @type {UserFileView}
     * @memberof Space
     */
    logo_color_144?: UserFileView | null;
    /**
     * 
     * @type {UserFileView}
     * @memberof Space
     */
    logo_color_180?: UserFileView | null;
    /**
     * 
     * @type {UserFileView}
     * @memberof Space
     */
    logo_color_192?: UserFileView | null;
    /**
     * 
     * @type {UserFileView}
     * @memberof Space
     */
    logo_color_512?: UserFileView | null;
    /**
     * 
     * @type {UserFileView}
     * @memberof Space
     */
    logo_color_svg?: UserFileView | null;
}
/**
 * * `BLANK` - ------- * `LIGHT` - Light * `DARK` - Dark
 * @export
 * @enum {string}
 */
export enum SpaceNavTextColorEnum {
    Blank = 'BLANK',
    Light = 'LIGHT',
    Dark = 'DARK'
}

/**
 * * `BLANK` - ------- * `TANDOOR` - Tandoor * `BOOTSTRAP` - Bootstrap * `DARKLY` - Darkly * `FLATLY` - Flatly * `SUPERHERO` - Superhero * `TANDOOR_DARK` - Tandoor Dark (INCOMPLETE)
 * @export
 * @enum {string}
 */
export enum SpaceThemeEnum {
    Blank = 'BLANK',
    Tandoor = 'TANDOOR',
    Bootstrap = 'BOOTSTRAP',
    Darkly = 'DARKLY',
    Flatly = 'FLATLY',
    Superhero = 'SUPERHERO',
    TandoorDark = 'TANDOOR_DARK'
}

/**
 * Adds nested create feature
 * @export
 * @interface Step
 */
export interface Step {
    /**
     * 
     * @type {number}
     * @memberof Step
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Step
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Step
     */
    instruction?: string;
    /**
     * 
     * @type {Array<Ingredient>}
     * @memberof Step
     */
    ingredients: Array<Ingredient>;
    /**
     * 
     * @type {string}
     * @memberof Step
     */
    instructions_markdown: string;
    /**
     * 
     * @type {number}
     * @memberof Step
     */
    time?: number;
    /**
     * 
     * @type {number}
     * @memberof Step
     */
    order?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Step
     */
    show_as_header?: boolean;
    /**
     * 
     * @type {UserFileView}
     * @memberof Step
     */
    file?: UserFileView | null;
    /**
     * 
     * @type {number}
     * @memberof Step
     */
    step_recipe?: number | null;
    /**
     * 
     * @type {any}
     * @memberof Step
     */
    step_recipe_data: any | null;
    /**
     * 
     * @type {number}
     * @memberof Step
     */
    numrecipe: number;
    /**
     * 
     * @type {boolean}
     * @memberof Step
     */
    show_ingredients_table?: boolean;
}
/**
 * 
 * @export
 * @interface Storage
 */
export interface Storage {
    /**
     * 
     * @type {number}
     * @memberof Storage
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Storage
     */
    name: string;
    /**
     * 
     * @type {MethodEnum}
     * @memberof Storage
     */
    method?: MethodEnum;
    /**
     * 
     * @type {string}
     * @memberof Storage
     */
    username?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Storage
     */
    password?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Storage
     */
    token?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Storage
     */
    created_by: number;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface Supermarket
 */
export interface Supermarket {
    /**
     * 
     * @type {number}
     * @memberof Supermarket
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Supermarket
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Supermarket
     */
    description?: string | null;
    /**
     * 
     * @type {Array<SupermarketCategoryRelation>}
     * @memberof Supermarket
     */
    category_to_supermarket: Array<SupermarketCategoryRelation>;
    /**
     * 
     * @type {string}
     * @memberof Supermarket
     */
    open_data_slug?: string | null;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface SupermarketCategory
 */
export interface SupermarketCategory {
    /**
     * 
     * @type {number}
     * @memberof SupermarketCategory
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof SupermarketCategory
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof SupermarketCategory
     */
    description?: string | null;
}
/**
 * Adds nested create feature
 * @export
 * @interface SupermarketCategoryRelation
 */
export interface SupermarketCategoryRelation {
    /**
     * 
     * @type {number}
     * @memberof SupermarketCategoryRelation
     */
    id?: number;
    /**
     * 
     * @type {SupermarketCategory}
     * @memberof SupermarketCategoryRelation
     */
    category: SupermarketCategory;
    /**
     * 
     * @type {number}
     * @memberof SupermarketCategoryRelation
     */
    supermarket: number;
    /**
     * 
     * @type {number}
     * @memberof SupermarketCategoryRelation
     */
    order?: number;
}
/**
 * 
 * @export
 * @interface Sync
 */
export interface Sync {
    /**
     * 
     * @type {number}
     * @memberof Sync
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof Sync
     */
    storage: number;
    /**
     * 
     * @type {string}
     * @memberof Sync
     */
    path?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Sync
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Sync
     */
    last_checked?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Sync
     */
    created_at: string;
    /**
     * 
     * @type {string}
     * @memberof Sync
     */
    updated_at: string;
}
/**
 * 
 * @export
 * @interface SyncLog
 */
export interface SyncLog {
    /**
     * 
     * @type {number}
     * @memberof SyncLog
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof SyncLog
     */
    sync: number;
    /**
     * 
     * @type {string}
     * @memberof SyncLog
     */
    status: string;
    /**
     * 
     * @type {string}
     * @memberof SyncLog
     */
    msg?: string;
    /**
     * 
     * @type {string}
     * @memberof SyncLog
     */
    created_at: string;
}
/**
 * * `TANDOOR` - Tandoor * `BOOTSTRAP` - Bootstrap * `DARKLY` - Darkly * `FLATLY` - Flatly * `SUPERHERO` - Superhero * `TANDOOR_DARK` - Tandoor Dark (INCOMPLETE)
 * @export
 * @enum {string}
 */
export enum ThemeEnum {
    Tandoor = 'TANDOOR',
    Bootstrap = 'BOOTSTRAP',
    Darkly = 'DARKLY',
    Flatly = 'FLATLY',
    Superhero = 'SUPERHERO',
    TandoorDark = 'TANDOOR_DARK'
}

/**
 * * `FOOD_ALIAS` - Food Alias * `UNIT_ALIAS` - Unit Alias * `KEYWORD_ALIAS` - Keyword Alias * `DESCRIPTION_REPLACE` - Description Replace * `INSTRUCTION_REPLACE` - Instruction Replace * `NEVER_UNIT` - Never Unit * `TRANSPOSE_WORDS` - Transpose Words * `FOOD_REPLACE` - Food Replace * `UNIT_REPLACE` - Unit Replace * `NAME_REPLACE` - Name Replace
 * @export
 * @enum {string}
 */
export enum TypeEnum {
    FoodAlias = 'FOOD_ALIAS',
    UnitAlias = 'UNIT_ALIAS',
    KeywordAlias = 'KEYWORD_ALIAS',
    DescriptionReplace = 'DESCRIPTION_REPLACE',
    InstructionReplace = 'INSTRUCTION_REPLACE',
    NeverUnit = 'NEVER_UNIT',
    TransposeWords = 'TRANSPOSE_WORDS',
    FoodReplace = 'FOOD_REPLACE',
    UnitReplace = 'UNIT_REPLACE',
    NameReplace = 'NAME_REPLACE'
}

/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface Unit
 */
export interface Unit {
    /**
     * 
     * @type {number}
     * @memberof Unit
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Unit
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Unit
     */
    plural_name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Unit
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Unit
     */
    base_unit?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Unit
     */
    open_data_slug?: string | null;
}
/**
 * Adds nested create feature
 * @export
 * @interface UnitConversion
 */
export interface UnitConversion {
    /**
     * 
     * @type {number}
     * @memberof UnitConversion
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof UnitConversion
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof UnitConversion
     */
    base_amount: number;
    /**
     * 
     * @type {Unit}
     * @memberof UnitConversion
     */
    base_unit: Unit;
    /**
     * 
     * @type {number}
     * @memberof UnitConversion
     */
    converted_amount: number;
    /**
     * 
     * @type {Unit}
     * @memberof UnitConversion
     */
    converted_unit: Unit;
    /**
     * 
     * @type {Food}
     * @memberof UnitConversion
     */
    food?: Food | null;
    /**
     * 
     * @type {string}
     * @memberof UnitConversion
     */
    open_data_slug?: string | null;
}
/**
 * Adds nested create feature
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    id?: number;
    /**
     * Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.
     * @type {string}
     * @memberof User
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    first_name?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    last_name?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    display_name: string;
}
/**
 * 
 * @export
 * @interface UserFile
 */
export interface UserFile {
    /**
     * 
     * @type {number}
     * @memberof UserFile
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof UserFile
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof UserFile
     */
    file: string;
    /**
     * 
     * @type {string}
     * @memberof UserFile
     */
    file_download: string;
    /**
     * 
     * @type {string}
     * @memberof UserFile
     */
    preview: string;
    /**
     * 
     * @type {number}
     * @memberof UserFile
     */
    file_size_kb: number;
}
/**
 * 
 * @export
 * @interface UserFileView
 */
export interface UserFileView {
    /**
     * 
     * @type {number}
     * @memberof UserFileView
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof UserFileView
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof UserFileView
     */
    file_download: string;
    /**
     * 
     * @type {string}
     * @memberof UserFileView
     */
    preview: string;
}
/**
 * Adds nested create feature
 * @export
 * @interface UserPreference
 */
export interface UserPreference {
    /**
     * 
     * @type {number}
     * @memberof UserPreference
     */
    user: number;
    /**
     * 
     * @type {UserFileView}
     * @memberof UserPreference
     */
    image?: UserFileView | null;
    /**
     * 
     * @type {ThemeEnum}
     * @memberof UserPreference
     */
    theme?: ThemeEnum;
    /**
     * 
     * @type {string}
     * @memberof UserPreference
     */
    nav_bg_color?: string;
    /**
     * 
     * @type {UserPreferenceNavTextColorEnum}
     * @memberof UserPreference
     */
    nav_text_color?: UserPreferenceNavTextColorEnum;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreference
     */
    nav_show_logo?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserPreference
     */
    default_unit?: string;
    /**
     * 
     * @type {DefaultPageEnum}
     * @memberof UserPreference
     */
    default_page?: DefaultPageEnum;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreference
     */
    use_fractions?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreference
     */
    use_kj?: boolean;
    /**
     * 
     * @type {Array<User>}
     * @memberof UserPreference
     */
    plan_share?: Array<User> | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreference
     */
    nav_sticky?: boolean;
    /**
     * 
     * @type {number}
     * @memberof UserPreference
     */
    ingredient_decimals?: number;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreference
     */
    comments?: boolean;
    /**
     * 
     * @type {number}
     * @memberof UserPreference
     */
    shopping_auto_sync?: number;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreference
     */
    mealplan_autoadd_shopping?: boolean;
    /**
     * 
     * @type {FoodInheritField}
     * @memberof UserPreference
     */
    food_inherit_default: FoodInheritField;
    /**
     * 
     * @type {number}
     * @memberof UserPreference
     */
    default_delay?: number;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreference
     */
    mealplan_autoinclude_related?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreference
     */
    mealplan_autoexclude_onhand?: boolean;
    /**
     * 
     * @type {Array<User>}
     * @memberof UserPreference
     */
    shopping_share?: Array<User> | null;
    /**
     * 
     * @type {number}
     * @memberof UserPreference
     */
    shopping_recent_days?: number;
    /**
     * 
     * @type {string}
     * @memberof UserPreference
     */
    csv_delim?: string;
    /**
     * 
     * @type {string}
     * @memberof UserPreference
     */
    csv_prefix?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreference
     */
    filter_to_supermarket?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreference
     */
    shopping_add_onhand?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreference
     */
    left_handed?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreference
     */
    show_step_ingredients?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreference
     */
    food_children_exist: boolean;
}
/**
 * * `LIGHT` - Light * `DARK` - Dark
 * @export
 * @enum {string}
 */
export enum UserPreferenceNavTextColorEnum {
    Light = 'LIGHT',
    Dark = 'DARK'
}

/**
 * Adds nested create feature
 * @export
 * @interface UserSpace
 */
export interface UserSpace {
    /**
     * 
     * @type {number}
     * @memberof UserSpace
     */
    id?: number;
    /**
     * 
     * @type {User}
     * @memberof UserSpace
     */
    user: User;
    /**
     * 
     * @type {number}
     * @memberof UserSpace
     */
    space: number;
    /**
     * 
     * @type {Array<Group>}
     * @memberof UserSpace
     */
    groups: Array<Group>;
    /**
     * 
     * @type {boolean}
     * @memberof UserSpace
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserSpace
     */
    internal_note?: string | null;
    /**
     * 
     * @type {number}
     * @memberof UserSpace
     */
    invite_link: number | null;
    /**
     * 
     * @type {string}
     * @memberof UserSpace
     */
    created_at: string;
    /**
     * 
     * @type {string}
     * @memberof UserSpace
     */
    updated_at: string;
}
/**
 * 
 * @export
 * @interface ViewLog
 */
export interface ViewLog {
    /**
     * 
     * @type {number}
     * @memberof ViewLog
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ViewLog
     */
    recipe: number;
    /**
     * 
     * @type {number}
     * @memberof ViewLog
     */
    created_by: number;
    /**
     * 
     * @type {string}
     * @memberof ViewLog
     */
    created_at: string;
}

/**
 * ApiApi - axios parameter creator
 * @export
 */
export const ApiApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ShoppingListEntryBulk} shoppingListEntryBulk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkShoppingListEntry: async (shoppingListEntryBulk: ShoppingListEntryBulk, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'shoppingListEntryBulk' is not null or undefined
            assertParamExists('bulkShoppingListEntry', 'shoppingListEntryBulk', shoppingListEntryBulk)
            const localVarPath = `/api/shopping-list-entry/bulk/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shoppingListEntryBulk, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AccessToken} accessToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccessToken: async (accessToken: AccessToken, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessToken' is not null or undefined
            assertParamExists('createAccessToken', 'accessToken', accessToken)
            const localVarPath = `/api/access-token/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accessToken, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AutoMealPlan} autoMealPlan 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAutoMealPlan: async (autoMealPlan: AutoMealPlan, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'autoMealPlan' is not null or undefined
            assertParamExists('createAutoMealPlan', 'autoMealPlan', autoMealPlan)
            const localVarPath = `/api/auto-plan/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(autoMealPlan, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Automation} automation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAutomation: async (automation: Automation, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'automation' is not null or undefined
            assertParamExists('createAutomation', 'automation', automation)
            const localVarPath = `/api/automation/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(automation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {BookmarkletImport} bookmarkletImport 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBookmarkletImport: async (bookmarkletImport: BookmarkletImport, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bookmarkletImport' is not null or undefined
            assertParamExists('createBookmarkletImport', 'bookmarkletImport', bookmarkletImport)
            const localVarPath = `/api/bookmarklet-import/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bookmarkletImport, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ConnectorConfigConfig} connectorConfigConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnectorConfig: async (connectorConfigConfig: ConnectorConfigConfig, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorConfigConfig' is not null or undefined
            assertParamExists('createConnectorConfig', 'connectorConfigConfig', connectorConfigConfig)
            const localVarPath = `/api/connector-config/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connectorConfigConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CookLog} cookLog 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCookLog: async (cookLog: CookLog, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cookLog' is not null or undefined
            assertParamExists('createCookLog', 'cookLog', cookLog)
            const localVarPath = `/api/cook-log/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cookLog, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CustomFilter} customFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomFilter: async (customFilter: CustomFilter, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customFilter' is not null or undefined
            assertParamExists('createCustomFilter', 'customFilter', customFilter)
            const localVarPath = `/api/custom-filter/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customFilter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ExportLog} exportLog 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExportLog: async (exportLog: ExportLog, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'exportLog' is not null or undefined
            assertParamExists('createExportLog', 'exportLog', exportLog)
            const localVarPath = `/api/export-log/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(exportLog, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Food} food 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFood: async (food: Food, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'food' is not null or undefined
            assertParamExists('createFood', 'food', food)
            const localVarPath = `/api/food/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(food, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ImportLog} importLog 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createImportLog: async (importLog: ImportLog, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'importLog' is not null or undefined
            assertParamExists('createImportLog', 'importLog', importLog)
            const localVarPath = `/api/import-log/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(importLog, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Ingredient} ingredient 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIngredient: async (ingredient: Ingredient, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'ingredient' is not null or undefined
            assertParamExists('createIngredient', 'ingredient', ingredient)
            const localVarPath = `/api/ingredient/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ingredient, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {InviteLink} inviteLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInviteLink: async (inviteLink: InviteLink, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inviteLink' is not null or undefined
            assertParamExists('createInviteLink', 'inviteLink', inviteLink)
            const localVarPath = `/api/invite-link/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inviteLink, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Keyword} keyword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKeyword: async (keyword: Keyword, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'keyword' is not null or undefined
            assertParamExists('createKeyword', 'keyword', keyword)
            const localVarPath = `/api/keyword/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(keyword, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {MealPlan} mealPlan 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMealPlan: async (mealPlan: MealPlan, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'mealPlan' is not null or undefined
            assertParamExists('createMealPlan', 'mealPlan', mealPlan)
            const localVarPath = `/api/meal-plan/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mealPlan, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {MealType} mealType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMealType: async (mealType: MealType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'mealType' is not null or undefined
            assertParamExists('createMealType', 'mealType', mealType)
            const localVarPath = `/api/meal-type/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mealType, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Property} property 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProperty: async (property: Property, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'property' is not null or undefined
            assertParamExists('createProperty', 'property', property)
            const localVarPath = `/api/property/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(property, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PropertyType} propertyType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyType: async (propertyType: PropertyType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'propertyType' is not null or undefined
            assertParamExists('createPropertyType', 'propertyType', propertyType)
            const localVarPath = `/api/property-type/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(propertyType, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Recipe} recipe 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecipe: async (recipe: Recipe, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'recipe' is not null or undefined
            assertParamExists('createRecipe', 'recipe', recipe)
            const localVarPath = `/api/recipe/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recipe, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RecipeBook} recipeBook 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecipeBook: async (recipeBook: RecipeBook, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'recipeBook' is not null or undefined
            assertParamExists('createRecipeBook', 'recipeBook', recipeBook)
            const localVarPath = `/api/recipe-book/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recipeBook, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RecipeBookEntry} recipeBookEntry 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecipeBookEntry: async (recipeBookEntry: RecipeBookEntry, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'recipeBookEntry' is not null or undefined
            assertParamExists('createRecipeBookEntry', 'recipeBookEntry', recipeBookEntry)
            const localVarPath = `/api/recipe-book-entry/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recipeBookEntry, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * function to retrieve a recipe from a given url or source string :param request: standard request with additional post parameters         - url: url to use for importing recipe         - data: if no url is given recipe is imported from provided source data         - (optional) bookmarklet: id of bookmarklet import to use, overrides URL and data attributes :return: JsonResponse containing the parsed json and images
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecipeUrlImport: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/recipe-from-source/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ShoppingListEntry} shoppingListEntry 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShoppingListEntry: async (shoppingListEntry: ShoppingListEntry, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'shoppingListEntry' is not null or undefined
            assertParamExists('createShoppingListEntry', 'shoppingListEntry', shoppingListEntry)
            const localVarPath = `/api/shopping-list-entry/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shoppingListEntry, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ShoppingListRecipe} shoppingListRecipe 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShoppingListRecipe: async (shoppingListRecipe: ShoppingListRecipe, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'shoppingListRecipe' is not null or undefined
            assertParamExists('createShoppingListRecipe', 'shoppingListRecipe', shoppingListRecipe)
            const localVarPath = `/api/shopping-list-recipe/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shoppingListRecipe, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Step} step 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStep: async (step: Step, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'step' is not null or undefined
            assertParamExists('createStep', 'step', step)
            const localVarPath = `/api/step/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(step, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Storage} storage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStorage: async (storage: Storage, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'storage' is not null or undefined
            assertParamExists('createStorage', 'storage', storage)
            const localVarPath = `/api/storage/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storage, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Supermarket} supermarket 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSupermarket: async (supermarket: Supermarket, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'supermarket' is not null or undefined
            assertParamExists('createSupermarket', 'supermarket', supermarket)
            const localVarPath = `/api/supermarket/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(supermarket, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SupermarketCategory} supermarketCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSupermarketCategory: async (supermarketCategory: SupermarketCategory, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'supermarketCategory' is not null or undefined
            assertParamExists('createSupermarketCategory', 'supermarketCategory', supermarketCategory)
            const localVarPath = `/api/supermarket-category/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(supermarketCategory, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SupermarketCategoryRelation} supermarketCategoryRelation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSupermarketCategoryRelation: async (supermarketCategoryRelation: SupermarketCategoryRelation, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'supermarketCategoryRelation' is not null or undefined
            assertParamExists('createSupermarketCategoryRelation', 'supermarketCategoryRelation', supermarketCategoryRelation)
            const localVarPath = `/api/supermarket-category-relation/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(supermarketCategoryRelation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Sync} sync 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSync: async (sync: Sync, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sync' is not null or undefined
            assertParamExists('createSync', 'sync', sync)
            const localVarPath = `/api/sync/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sync, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Unit} unit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUnit: async (unit: Unit, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'unit' is not null or undefined
            assertParamExists('createUnit', 'unit', unit)
            const localVarPath = `/api/unit/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(unit, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UnitConversion} unitConversion 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUnitConversion: async (unitConversion: UnitConversion, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'unitConversion' is not null or undefined
            assertParamExists('createUnitConversion', 'unitConversion', unitConversion)
            const localVarPath = `/api/unit-conversion/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(unitConversion, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {string} file 
         * @param {string} fileDownload 
         * @param {string} preview 
         * @param {number} fileSizeKb 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserFile: async (name: string, file: string, fileDownload: string, preview: string, fileSizeKb: number, id?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('createUserFile', 'name', name)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('createUserFile', 'file', file)
            // verify required parameter 'fileDownload' is not null or undefined
            assertParamExists('createUserFile', 'fileDownload', fileDownload)
            // verify required parameter 'preview' is not null or undefined
            assertParamExists('createUserFile', 'preview', preview)
            // verify required parameter 'fileSizeKb' is not null or undefined
            assertParamExists('createUserFile', 'fileSizeKb', fileSizeKb)
            const localVarPath = `/api/user-file/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (id !== undefined) { 
                localVarFormParams.append('id', id as any);
            }
    
            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (fileDownload !== undefined) { 
                localVarFormParams.append('file_download', fileDownload as any);
            }
    
            if (preview !== undefined) { 
                localVarFormParams.append('preview', preview as any);
            }
    
            if (fileSizeKb !== undefined) { 
                localVarFormParams.append('file_size_kb', fileSizeKb as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ViewLog} viewLog 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createViewLog: async (viewLog: ViewLog, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'viewLog' is not null or undefined
            assertParamExists('createViewLog', 'viewLog', viewLog)
            const localVarPath = `/api/view-log/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(viewLog, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * function to handle files passed by application importer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createimportFiles: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/import/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {IngredientString} ingredientString 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createingredientFromString: async (ingredientString: IngredientString, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'ingredientString' is not null or undefined
            assertParamExists('createingredientFromString', 'ingredientString', ingredientString)
            const localVarPath = `/api/ingredient-from-string/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ingredientString, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * function to reset inheritance from api, see food method for docs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createresetFoodInheritance: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/reset-food-inheritance/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this access token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyAccessToken: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyAccessToken', 'id', id)
            const localVarPath = `/api/access-token/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this automation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyAutomation: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyAutomation', 'id', id)
            const localVarPath = `/api/automation/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this bookmarklet import.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyBookmarkletImport: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyBookmarkletImport', 'id', id)
            const localVarPath = `/api/bookmarklet-import/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this connector config.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyConnectorConfig: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyConnectorConfig', 'id', id)
            const localVarPath = `/api/connector-config/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cook log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyCookLog: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyCookLog', 'id', id)
            const localVarPath = `/api/cook-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this custom filter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyCustomFilter: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyCustomFilter', 'id', id)
            const localVarPath = `/api/custom-filter/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this export log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyExportLog: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyExportLog', 'id', id)
            const localVarPath = `/api/export-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyFood: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyFood', 'id', id)
            const localVarPath = `/api/food/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this import log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyImportLog: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyImportLog', 'id', id)
            const localVarPath = `/api/import-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ingredient.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyIngredient: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyIngredient', 'id', id)
            const localVarPath = `/api/ingredient/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this invite link.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyInviteLink: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyInviteLink', 'id', id)
            const localVarPath = `/api/invite-link/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyKeyword: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyKeyword', 'id', id)
            const localVarPath = `/api/keyword/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this meal plan.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyMealPlan: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyMealPlan', 'id', id)
            const localVarPath = `/api/meal-plan/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {number} id A unique integer value identifying this meal type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyMealType: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyMealType', 'id', id)
            const localVarPath = `/api/meal-type/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyProperty: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyProperty', 'id', id)
            const localVarPath = `/api/property/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyPropertyType: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyPropertyType', 'id', id)
            const localVarPath = `/api/property-type/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyRecipe: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyRecipe', 'id', id)
            const localVarPath = `/api/recipe/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyRecipeBook: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyRecipeBook', 'id', id)
            const localVarPath = `/api/recipe-book/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyRecipeBookEntry: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyRecipeBookEntry', 'id', id)
            const localVarPath = `/api/recipe-book-entry/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyShoppingListEntry: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyShoppingListEntry', 'id', id)
            const localVarPath = `/api/shopping-list-entry/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyShoppingListRecipe: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyShoppingListRecipe', 'id', id)
            const localVarPath = `/api/shopping-list-recipe/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this step.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyStep: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyStep', 'id', id)
            const localVarPath = `/api/step/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this storage.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyStorage: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyStorage', 'id', id)
            const localVarPath = `/api/storage/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroySupermarket: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroySupermarket', 'id', id)
            const localVarPath = `/api/supermarket/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroySupermarketCategory: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroySupermarketCategory', 'id', id)
            const localVarPath = `/api/supermarket-category/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category relation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroySupermarketCategoryRelation: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroySupermarketCategoryRelation', 'id', id)
            const localVarPath = `/api/supermarket-category-relation/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this sync.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroySync: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroySync', 'id', id)
            const localVarPath = `/api/sync/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyUnit: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyUnit', 'id', id)
            const localVarPath = `/api/unit/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit conversion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyUnitConversion: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyUnitConversion', 'id', id)
            const localVarPath = `/api/unit-conversion/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyUserFile: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyUserFile', 'id', id)
            const localVarPath = `/api/user-file/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user space.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyUserSpace: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyUserSpace', 'id', id)
            const localVarPath = `/api/user-space/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this view log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyViewLog: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyViewLog', 'id', id)
            const localVarPath = `/api/view-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * updates the food with all possible data from the FDC Api if properties with a fdc_id already exist they will be overridden, if existing properties don\'t have a fdc_id they won\'t be changed
         * @param {number} id A unique integer value identifying this food.
         * @param {Food} food 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fdcFood: async (id: number, food: Food, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('fdcFood', 'id', id)
            // verify required parameter 'food' is not null or undefined
            assertParamExists('fdcFood', 'food', food)
            const localVarPath = `/api/food/{id}/fdc/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(food, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [fromDate] Filter meal plans from date (inclusive).
         * @param {Array<string>} [mealType] Filter meal plans with MealType ID. For multiple repeat parameter.
         * @param {string} [toDate] Filter meal plans to date (inclusive).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        icalMealPlan: async (fromDate?: string, mealType?: Array<string>, toDate?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/meal-plan/ical/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (fromDate !== undefined) {
                localVarQueryParameter['from_date'] = fromDate;
            }

            if (mealType) {
                localVarQueryParameter['meal_type'] = mealType;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['to_date'] = toDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {string} [image] 
         * @param {string} [imageUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageRecipe: async (id: number, image?: string, imageUrl?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imageRecipe', 'id', id)
            const localVarPath = `/api/recipe/{id}/image/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
            if (imageUrl !== undefined) { 
                localVarFormParams.append('image_url', imageUrl as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccessTokens: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/access-token/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {Array<'DESCRIPTION_REPLACE' | 'FOOD_ALIAS' | 'FOOD_REPLACE' | 'INSTRUCTION_REPLACE' | 'KEYWORD_ALIAS' | 'NAME_REPLACE' | 'NEVER_UNIT' | 'TRANSPOSE_WORDS' | 'UNIT_ALIAS' | 'UNIT_REPLACE'>} [type] Return the Automations matching the automation type.  Repeat for multiple.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAutomations: async (page?: number, pageSize?: number, type?: Array<'DESCRIPTION_REPLACE' | 'FOOD_ALIAS' | 'FOOD_REPLACE' | 'INSTRUCTION_REPLACE' | 'KEYWORD_ALIAS' | 'NAME_REPLACE' | 'NEVER_UNIT' | 'TRANSPOSE_WORDS' | 'UNIT_ALIAS' | 'UNIT_REPLACE'>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/automation/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (type) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBookmarkletImports: async (page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/bookmarklet-import/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConnectorConfigs: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/connector-config/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {number} [recipe] Filter for entries with the given recipe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCookLogs: async (page?: number, pageSize?: number, recipe?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/cook-log/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (recipe !== undefined) {
                localVarQueryParameter['recipe'] = recipe;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {Array<'FOOD' | 'KEYWORD' | 'RECIPE'>} [type] Return the CustomFilters matching the model type.  Repeat for multiple.
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCustomFilters: async (limit?: string, page?: number, pageSize?: number, query?: string, random?: string, type?: Array<'FOOD' | 'KEYWORD' | 'RECIPE'>, updatedAt?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/custom-filter/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (random !== undefined) {
                localVarQueryParameter['random'] = random;
            }

            if (type) {
                localVarQueryParameter['type'] = type;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExportLogs: async (page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/export-log/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFoodInheritFields: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/food-inherit-field/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {number} [root] Return first level children of {obj} with ID [int].  Integer 0 will return root {obj}s.
         * @param {number} [tree] Return all self and children of {obj} with ID [int].
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFoods: async (limit?: string, page?: number, pageSize?: number, query?: string, random?: string, root?: number, tree?: number, updatedAt?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/food/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (random !== undefined) {
                localVarQueryParameter['random'] = random;
            }

            if (root !== undefined) {
                localVarQueryParameter['root'] = root;
            }

            if (tree !== undefined) {
                localVarQueryParameter['tree'] = tree;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroups: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/group/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listImportLogs: async (page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/import-log/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [food] ID of food to filter for
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {number} [unit] ID of unit to filter for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIngredients: async (food?: number, page?: number, pageSize?: number, unit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/ingredient/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (food !== undefined) {
                localVarQueryParameter['food'] = food;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (unit !== undefined) {
                localVarQueryParameter['unit'] = unit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [internalNote] I have no idea what internal_note is for.
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInviteLinks: async (internalNote?: string, limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/invite-link/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (internalNote !== undefined) {
                localVarQueryParameter['internal_note'] = internalNote;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (random !== undefined) {
                localVarQueryParameter['random'] = random;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {number} [root] Return first level children of {obj} with ID [int].  Integer 0 will return root {obj}s.
         * @param {number} [tree] Return all self and children of {obj} with ID [int].
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listKeywords: async (limit?: string, page?: number, pageSize?: number, query?: string, random?: string, root?: number, tree?: number, updatedAt?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/keyword/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (random !== undefined) {
                localVarQueryParameter['random'] = random;
            }

            if (root !== undefined) {
                localVarQueryParameter['root'] = root;
            }

            if (tree !== undefined) {
                localVarQueryParameter['tree'] = tree;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [fromDate] Filter meal plans from date (inclusive).
         * @param {Array<string>} [mealType] Filter meal plans with MealType ID. For multiple repeat parameter.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [toDate] Filter meal plans to date (inclusive).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMealPlans: async (fromDate?: string, mealType?: Array<string>, page?: number, pageSize?: number, toDate?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/meal-plan/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (fromDate !== undefined) {
                localVarQueryParameter['from_date'] = fromDate;
            }

            if (mealType) {
                localVarQueryParameter['meal_type'] = mealType;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['to_date'] = toDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMealTypes: async (page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/meal-type/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<'ALLERGEN' | 'GOAL' | 'NUTRITION' | 'OTHER' | 'PRICE'>} [category] Return the PropertyTypes matching the property category.  Repeat for multiple.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPropertyTypes: async (category?: Array<'ALLERGEN' | 'GOAL' | 'NUTRITION' | 'OTHER' | 'PRICE'>, page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/property-type/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (category) {
                localVarQueryParameter['category'] = category;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPropertys: async (page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/property/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [book] id of book - only return recipes in that book
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {number} [recipe] id of recipe - only return books for that recipe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRecipeBookEntrys: async (book?: number, page?: number, pageSize?: number, recipe?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/recipe-book-entry/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (book !== undefined) {
                localVarQueryParameter['book'] = book;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (recipe !== undefined) {
                localVarQueryParameter['recipe'] = recipe;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {'asc' | 'desc'} [orderDirection] Order ascending or descending
         * @param {'id' | 'name' | 'order'} [orderField] Field to order recipe books on
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRecipeBooks: async (limit?: string, orderDirection?: 'asc' | 'desc', orderField?: 'id' | 'name' | 'order', page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/recipe-book/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['order_direction'] = orderDirection;
            }

            if (orderField !== undefined) {
                localVarQueryParameter['order_field'] = orderField;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (random !== undefined) {
                localVarQueryParameter['random'] = random;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<number>} [books] ID of book a recipe should be in. For multiple repeat parameter.
         * @param {Array<number>} [booksAnd] Book IDs, repeat for multiple. Return recipes with all of the books.
         * @param {Array<number>} [booksAndNot] Book IDs, repeat for multiple. Exclude recipes with all of the books.
         * @param {Array<number>} [booksOr] Book IDs, repeat for multiple. Return recipes with any of the books
         * @param {Array<number>} [booksOrNot] Book IDs, repeat for multiple. Exclude recipes with any of the books.
         * @param {string} [cookedon] Filter recipes last cooked on or after YYYY-MM-DD. Prepending - filters on or before date.
         * @param {string} [createdon] Filter recipes created on or after YYYY-MM-DD. Prepending - filters on or before date.
         * @param {Array<number>} [foods] ID of food a recipe should have. For multiple repeat parameter.
         * @param {Array<number>} [foodsAnd] Food IDs, repeat for multiple. Return recipes with all of the foods.
         * @param {Array<number>} [foodsAndNot] Food IDs, repeat for multiple. Exclude recipes with all of the foods.
         * @param {Array<number>} [foodsOr] Food IDs, repeat for multiple. Return recipes with any of the foods
         * @param {Array<number>} [foodsOrNot] Food IDs, repeat for multiple. Exclude recipes with any of the foods.
         * @param {boolean} [internal] If only internal recipes should be returned. [true/&lt;b&gt;false&lt;/b&gt;]
         * @param {Array<number>} [keywords] ID of keyword a recipe should have. For multiple repeat parameter. Equivalent to keywords_or
         * @param {Array<number>} [keywordsAnd] Keyword IDs, repeat for multiple. Return recipes with all of the keywords.
         * @param {Array<number>} [keywordsAndNot] Keyword IDs, repeat for multiple. Exclude recipes with all of the keywords.
         * @param {Array<number>} [keywordsOr] Keyword IDs, repeat for multiple. Return recipes with any of the keywords
         * @param {Array<number>} [keywordsOrNot] Keyword IDs, repeat for multiple. Exclude recipes with any of the keywords.
         * @param {boolean} [makenow] Filter recipes that can be made with OnHand food. [true/&lt;b&gt;false&lt;/b&gt;]
         * @param {string} [_new] Returns new results first in search results. [true/&lt;b&gt;false&lt;/b&gt;]
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] Query string matched (fuzzy) against recipe name. In the future also fulltext search.
         * @param {string} [random] Returns the results in randomized order. [true/&lt;b&gt;false&lt;/b&gt;]
         * @param {number} [rating] Rating a recipe should have or greater. [0 - 5] Negative value filters rating less than.
         * @param {number} [timescooked] Filter recipes cooked X times or more.  Negative values returns cooked less than X times
         * @param {number} [units] ID of unit a recipe should have.
         * @param {string} [updatedon] Filter recipes updated on or after YYYY-MM-DD. Prepending - filters on or before date.
         * @param {string} [viewedon] Filter recipes lasts viewed on or after YYYY-MM-DD. Prepending - filters on or before date.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRecipes: async (books?: Array<number>, booksAnd?: Array<number>, booksAndNot?: Array<number>, booksOr?: Array<number>, booksOrNot?: Array<number>, cookedon?: string, createdon?: string, foods?: Array<number>, foodsAnd?: Array<number>, foodsAndNot?: Array<number>, foodsOr?: Array<number>, foodsOrNot?: Array<number>, internal?: boolean, keywords?: Array<number>, keywordsAnd?: Array<number>, keywordsAndNot?: Array<number>, keywordsOr?: Array<number>, keywordsOrNot?: Array<number>, makenow?: boolean, _new?: string, page?: number, pageSize?: number, query?: string, random?: string, rating?: number, timescooked?: number, units?: number, updatedon?: string, viewedon?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/recipe/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (books) {
                localVarQueryParameter['books'] = books;
            }

            if (booksAnd) {
                localVarQueryParameter['books_and'] = booksAnd;
            }

            if (booksAndNot) {
                localVarQueryParameter['books_and_not'] = booksAndNot;
            }

            if (booksOr) {
                localVarQueryParameter['books_or'] = booksOr;
            }

            if (booksOrNot) {
                localVarQueryParameter['books_or_not'] = booksOrNot;
            }

            if (cookedon !== undefined) {
                localVarQueryParameter['cookedon'] = cookedon;
            }

            if (createdon !== undefined) {
                localVarQueryParameter['createdon'] = createdon;
            }

            if (foods) {
                localVarQueryParameter['foods'] = foods;
            }

            if (foodsAnd) {
                localVarQueryParameter['foods_and'] = foodsAnd;
            }

            if (foodsAndNot) {
                localVarQueryParameter['foods_and_not'] = foodsAndNot;
            }

            if (foodsOr) {
                localVarQueryParameter['foods_or'] = foodsOr;
            }

            if (foodsOrNot) {
                localVarQueryParameter['foods_or_not'] = foodsOrNot;
            }

            if (internal !== undefined) {
                localVarQueryParameter['internal'] = internal;
            }

            if (keywords) {
                localVarQueryParameter['keywords'] = keywords;
            }

            if (keywordsAnd) {
                localVarQueryParameter['keywords_and'] = keywordsAnd;
            }

            if (keywordsAndNot) {
                localVarQueryParameter['keywords_and_not'] = keywordsAndNot;
            }

            if (keywordsOr) {
                localVarQueryParameter['keywords_or'] = keywordsOr;
            }

            if (keywordsOrNot) {
                localVarQueryParameter['keywords_or_not'] = keywordsOrNot;
            }

            if (makenow !== undefined) {
                localVarQueryParameter['makenow'] = makenow;
            }

            if (_new !== undefined) {
                localVarQueryParameter['new'] = _new;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (random !== undefined) {
                localVarQueryParameter['random'] = random;
            }

            if (rating !== undefined) {
                localVarQueryParameter['rating'] = rating;
            }

            if (timescooked !== undefined) {
                localVarQueryParameter['timescooked'] = timescooked;
            }

            if (units !== undefined) {
                localVarQueryParameter['units'] = units;
            }

            if (updatedon !== undefined) {
                localVarQueryParameter['updatedon'] = updatedon;
            }

            if (viewedon !== undefined) {
                localVarQueryParameter['viewedon'] = viewedon;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRecipes2: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/recipe/flat/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [checked] Filter shopping list entries on checked.  [true, false, both, &lt;b&gt;recent&lt;/b&gt;]&lt;br&gt;                              - recent includes unchecked items and recently completed items.
         * @param {number} [id] Returns the shopping list entry with a primary key of id.  Multiple values allowed.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {number} [supermarket] Returns the shopping list entries sorted by supermarket category order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listShoppingListEntrys: async (checked?: string, id?: number, page?: number, pageSize?: number, supermarket?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/shopping-list-entry/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (checked !== undefined) {
                localVarQueryParameter['checked'] = checked;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (supermarket !== undefined) {
                localVarQueryParameter['supermarket'] = supermarket;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listShoppingListRecipes: async (page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/shopping-list-recipe/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSpaces: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/space/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] Query string matched (fuzzy) against object name.
         * @param {Array<number>} [recipe] ID of recipe a step is part of. For multiple repeat parameter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSteps: async (page?: number, pageSize?: number, query?: string, recipe?: Array<number>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/step/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (recipe) {
                localVarQueryParameter['recipe'] = recipe;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listStorages: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/storage/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSupermarketCategoryRelations: async (limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/supermarket-category-relation/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (random !== undefined) {
                localVarQueryParameter['random'] = random;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSupermarketCategorys: async (limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/supermarket-category/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (random !== undefined) {
                localVarQueryParameter['random'] = random;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSupermarkets: async (limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/supermarket/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (random !== undefined) {
                localVarQueryParameter['random'] = random;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSyncLogs: async (page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sync-log/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSyncs: async (page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sync/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [foodId] ID of food to filter for
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUnitConversions: async (foodId?: number, page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/unit-conversion/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (foodId !== undefined) {
                localVarQueryParameter['food_id'] = foodId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUnits: async (limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/unit/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (random !== undefined) {
                localVarQueryParameter['random'] = random;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserFiles: async (limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user-file/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (random !== undefined) {
                localVarQueryParameter['random'] = random;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserPreferences: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user-preference/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [internalNote] I have no idea what this is
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserSpaces: async (internalNote?: string, page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user-space/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (internalNote !== undefined) {
                localVarQueryParameter['internal_note'] = internalNote;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<string>} [filterList] User IDs, repeat for multiple
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers: async (filterList?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (filterList) {
                localVarQueryParameter['filter_list'] = filterList;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listViewLogs: async (page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/view-log/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {number} target The ID of the {obj} you want to merge with.
         * @param {Food} food 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeFood: async (id: number, target: number, food: Food, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('mergeFood', 'id', id)
            // verify required parameter 'target' is not null or undefined
            assertParamExists('mergeFood', 'target', target)
            // verify required parameter 'food' is not null or undefined
            assertParamExists('mergeFood', 'food', food)
            const localVarPath = `/api/food/{id}/merge/{target}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"target"}}`, encodeURIComponent(String(target)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(food, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {number} target The ID of the {obj} you want to merge with.
         * @param {Keyword} keyword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeKeyword: async (id: number, target: number, keyword: Keyword, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('mergeKeyword', 'id', id)
            // verify required parameter 'target' is not null or undefined
            assertParamExists('mergeKeyword', 'target', target)
            // verify required parameter 'keyword' is not null or undefined
            assertParamExists('mergeKeyword', 'keyword', keyword)
            const localVarPath = `/api/keyword/{id}/merge/{target}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"target"}}`, encodeURIComponent(String(target)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(keyword, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category.
         * @param {number} target The ID of the {obj} you want to merge with.
         * @param {SupermarketCategory} supermarketCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeSupermarketCategory: async (id: number, target: number, supermarketCategory: SupermarketCategory, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('mergeSupermarketCategory', 'id', id)
            // verify required parameter 'target' is not null or undefined
            assertParamExists('mergeSupermarketCategory', 'target', target)
            // verify required parameter 'supermarketCategory' is not null or undefined
            assertParamExists('mergeSupermarketCategory', 'supermarketCategory', supermarketCategory)
            const localVarPath = `/api/supermarket-category/{id}/merge/{target}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"target"}}`, encodeURIComponent(String(target)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(supermarketCategory, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit.
         * @param {number} target The ID of the {obj} you want to merge with.
         * @param {Unit} unit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeUnit: async (id: number, target: number, unit: Unit, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('mergeUnit', 'id', id)
            // verify required parameter 'target' is not null or undefined
            assertParamExists('mergeUnit', 'target', target)
            // verify required parameter 'unit' is not null or undefined
            assertParamExists('mergeUnit', 'unit', unit)
            const localVarPath = `/api/unit/{id}/merge/{target}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"target"}}`, encodeURIComponent(String(target)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(unit, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {number} parent The ID of the desired parent of the {obj}.
         * @param {Food} food 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveFood: async (id: number, parent: number, food: Food, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('moveFood', 'id', id)
            // verify required parameter 'parent' is not null or undefined
            assertParamExists('moveFood', 'parent', parent)
            // verify required parameter 'food' is not null or undefined
            assertParamExists('moveFood', 'food', food)
            const localVarPath = `/api/food/{id}/move/{parent}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent"}}`, encodeURIComponent(String(parent)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(food, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {number} parent The ID of the desired parent of the {obj}.
         * @param {Keyword} keyword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveKeyword: async (id: number, parent: number, keyword: Keyword, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('moveKeyword', 'id', id)
            // verify required parameter 'parent' is not null or undefined
            assertParamExists('moveKeyword', 'parent', parent)
            // verify required parameter 'keyword' is not null or undefined
            assertParamExists('moveKeyword', 'keyword', keyword)
            const localVarPath = `/api/keyword/{id}/move/{parent}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent"}}`, encodeURIComponent(String(parent)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(keyword, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this access token.
         * @param {PatchedAccessToken} [patchedAccessToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateAccessToken: async (id: number, patchedAccessToken?: PatchedAccessToken, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateAccessToken', 'id', id)
            const localVarPath = `/api/access-token/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedAccessToken, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this automation.
         * @param {PatchedAutomation} [patchedAutomation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateAutomation: async (id: number, patchedAutomation?: PatchedAutomation, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateAutomation', 'id', id)
            const localVarPath = `/api/automation/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedAutomation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this bookmarklet import.
         * @param {PatchedBookmarkletImport} [patchedBookmarkletImport] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateBookmarkletImport: async (id: number, patchedBookmarkletImport?: PatchedBookmarkletImport, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateBookmarkletImport', 'id', id)
            const localVarPath = `/api/bookmarklet-import/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedBookmarkletImport, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this connector config.
         * @param {PatchedConnectorConfigConfig} [patchedConnectorConfigConfig] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateConnectorConfig: async (id: number, patchedConnectorConfigConfig?: PatchedConnectorConfigConfig, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateConnectorConfig', 'id', id)
            const localVarPath = `/api/connector-config/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedConnectorConfigConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cook log.
         * @param {PatchedCookLog} [patchedCookLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateCookLog: async (id: number, patchedCookLog?: PatchedCookLog, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateCookLog', 'id', id)
            const localVarPath = `/api/cook-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedCookLog, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this custom filter.
         * @param {PatchedCustomFilter} [patchedCustomFilter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateCustomFilter: async (id: number, patchedCustomFilter?: PatchedCustomFilter, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateCustomFilter', 'id', id)
            const localVarPath = `/api/custom-filter/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedCustomFilter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this export log.
         * @param {PatchedExportLog} [patchedExportLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateExportLog: async (id: number, patchedExportLog?: PatchedExportLog, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateExportLog', 'id', id)
            const localVarPath = `/api/export-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedExportLog, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {PatchedFood} [patchedFood] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateFood: async (id: number, patchedFood?: PatchedFood, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateFood', 'id', id)
            const localVarPath = `/api/food/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedFood, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this import log.
         * @param {PatchedImportLog} [patchedImportLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateImportLog: async (id: number, patchedImportLog?: PatchedImportLog, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateImportLog', 'id', id)
            const localVarPath = `/api/import-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedImportLog, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ingredient.
         * @param {PatchedIngredient} [patchedIngredient] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateIngredient: async (id: number, patchedIngredient?: PatchedIngredient, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateIngredient', 'id', id)
            const localVarPath = `/api/ingredient/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedIngredient, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this invite link.
         * @param {PatchedInviteLink} [patchedInviteLink] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateInviteLink: async (id: number, patchedInviteLink?: PatchedInviteLink, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateInviteLink', 'id', id)
            const localVarPath = `/api/invite-link/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedInviteLink, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {PatchedKeyword} [patchedKeyword] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateKeyword: async (id: number, patchedKeyword?: PatchedKeyword, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateKeyword', 'id', id)
            const localVarPath = `/api/keyword/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedKeyword, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this meal plan.
         * @param {PatchedMealPlan} [patchedMealPlan] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateMealPlan: async (id: number, patchedMealPlan?: PatchedMealPlan, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateMealPlan', 'id', id)
            const localVarPath = `/api/meal-plan/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedMealPlan, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {number} id A unique integer value identifying this meal type.
         * @param {PatchedMealType} [patchedMealType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateMealType: async (id: number, patchedMealType?: PatchedMealType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateMealType', 'id', id)
            const localVarPath = `/api/meal-type/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedMealType, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property.
         * @param {PatchedProperty} [patchedProperty] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateProperty: async (id: number, patchedProperty?: PatchedProperty, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateProperty', 'id', id)
            const localVarPath = `/api/property/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedProperty, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property type.
         * @param {PatchedPropertyType} [patchedPropertyType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdatePropertyType: async (id: number, patchedPropertyType?: PatchedPropertyType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdatePropertyType', 'id', id)
            const localVarPath = `/api/property-type/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedPropertyType, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {PatchedRecipe} [patchedRecipe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateRecipe: async (id: number, patchedRecipe?: PatchedRecipe, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateRecipe', 'id', id)
            const localVarPath = `/api/recipe/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedRecipe, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book.
         * @param {PatchedRecipeBook} [patchedRecipeBook] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateRecipeBook: async (id: number, patchedRecipeBook?: PatchedRecipeBook, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateRecipeBook', 'id', id)
            const localVarPath = `/api/recipe-book/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedRecipeBook, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book entry.
         * @param {PatchedRecipeBookEntry} [patchedRecipeBookEntry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateRecipeBookEntry: async (id: number, patchedRecipeBookEntry?: PatchedRecipeBookEntry, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateRecipeBookEntry', 'id', id)
            const localVarPath = `/api/recipe-book-entry/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedRecipeBookEntry, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list entry.
         * @param {PatchedShoppingListEntry} [patchedShoppingListEntry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateShoppingListEntry: async (id: number, patchedShoppingListEntry?: PatchedShoppingListEntry, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateShoppingListEntry', 'id', id)
            const localVarPath = `/api/shopping-list-entry/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedShoppingListEntry, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list recipe.
         * @param {PatchedShoppingListRecipe} [patchedShoppingListRecipe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateShoppingListRecipe: async (id: number, patchedShoppingListRecipe?: PatchedShoppingListRecipe, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateShoppingListRecipe', 'id', id)
            const localVarPath = `/api/shopping-list-recipe/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedShoppingListRecipe, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this space.
         * @param {PatchedSpace} [patchedSpace] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateSpace: async (id: number, patchedSpace?: PatchedSpace, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateSpace', 'id', id)
            const localVarPath = `/api/space/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedSpace, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this step.
         * @param {PatchedStep} [patchedStep] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateStep: async (id: number, patchedStep?: PatchedStep, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateStep', 'id', id)
            const localVarPath = `/api/step/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedStep, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this storage.
         * @param {PatchedStorage} [patchedStorage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateStorage: async (id: number, patchedStorage?: PatchedStorage, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateStorage', 'id', id)
            const localVarPath = `/api/storage/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedStorage, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket.
         * @param {PatchedSupermarket} [patchedSupermarket] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateSupermarket: async (id: number, patchedSupermarket?: PatchedSupermarket, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateSupermarket', 'id', id)
            const localVarPath = `/api/supermarket/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedSupermarket, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category.
         * @param {PatchedSupermarketCategory} [patchedSupermarketCategory] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateSupermarketCategory: async (id: number, patchedSupermarketCategory?: PatchedSupermarketCategory, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateSupermarketCategory', 'id', id)
            const localVarPath = `/api/supermarket-category/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedSupermarketCategory, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category relation.
         * @param {PatchedSupermarketCategoryRelation} [patchedSupermarketCategoryRelation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateSupermarketCategoryRelation: async (id: number, patchedSupermarketCategoryRelation?: PatchedSupermarketCategoryRelation, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateSupermarketCategoryRelation', 'id', id)
            const localVarPath = `/api/supermarket-category-relation/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedSupermarketCategoryRelation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this sync.
         * @param {PatchedSync} [patchedSync] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateSync: async (id: number, patchedSync?: PatchedSync, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateSync', 'id', id)
            const localVarPath = `/api/sync/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedSync, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit.
         * @param {PatchedUnit} [patchedUnit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateUnit: async (id: number, patchedUnit?: PatchedUnit, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateUnit', 'id', id)
            const localVarPath = `/api/unit/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedUnit, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit conversion.
         * @param {PatchedUnitConversion} [patchedUnitConversion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateUnitConversion: async (id: number, patchedUnitConversion?: PatchedUnitConversion, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateUnitConversion', 'id', id)
            const localVarPath = `/api/unit-conversion/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedUnitConversion, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {PatchedUser} [patchedUser] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateUser: async (id: number, patchedUser?: PatchedUser, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateUser', 'id', id)
            const localVarPath = `/api/user/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedUser, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user file.
         * @param {number} [id2] 
         * @param {string} [name] 
         * @param {string} [file] 
         * @param {string} [fileDownload] 
         * @param {string} [preview] 
         * @param {number} [fileSizeKb] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateUserFile: async (id: number, id2?: number, name?: string, file?: string, fileDownload?: string, preview?: string, fileSizeKb?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateUserFile', 'id', id)
            const localVarPath = `/api/user-file/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (id2 !== undefined) { 
                localVarFormParams.append('id', id2 as any);
            }
    
            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (fileDownload !== undefined) { 
                localVarFormParams.append('file_download', fileDownload as any);
            }
    
            if (preview !== undefined) { 
                localVarFormParams.append('preview', preview as any);
            }
    
            if (fileSizeKb !== undefined) { 
                localVarFormParams.append('file_size_kb', fileSizeKb as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} user A unique value identifying this user preference.
         * @param {PatchedUserPreference} [patchedUserPreference] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateUserPreference: async (user: number, patchedUserPreference?: PatchedUserPreference, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('partialUpdateUserPreference', 'user', user)
            const localVarPath = `/api/user-preference/{user}/`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedUserPreference, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user space.
         * @param {PatchedUserSpace} [patchedUserSpace] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateUserSpace: async (id: number, patchedUserSpace?: PatchedUserSpace, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateUserSpace', 'id', id)
            const localVarPath = `/api/user-space/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedUserSpace, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this view log.
         * @param {PatchedViewLog} [patchedViewLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateViewLog: async (id: number, patchedViewLog?: PatchedViewLog, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateViewLog', 'id', id)
            const localVarPath = `/api/view-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedViewLog, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        relatedRecipe: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('relatedRecipe', 'id', id)
            const localVarPath = `/api/recipe/{id}/related/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this access token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAccessToken: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveAccessToken', 'id', id)
            const localVarPath = `/api/access-token/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this automation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAutomation: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveAutomation', 'id', id)
            const localVarPath = `/api/automation/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this bookmarklet import.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveBookmarkletImport: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveBookmarkletImport', 'id', id)
            const localVarPath = `/api/bookmarklet-import/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this connector config.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveConnectorConfig: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveConnectorConfig', 'id', id)
            const localVarPath = `/api/connector-config/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cook log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveCookLog: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveCookLog', 'id', id)
            const localVarPath = `/api/cook-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this custom filter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveCustomFilter: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveCustomFilter', 'id', id)
            const localVarPath = `/api/custom-filter/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this export log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveExportLog: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveExportLog', 'id', id)
            const localVarPath = `/api/export-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveFood: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveFood', 'id', id)
            const localVarPath = `/api/food/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food inherit field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveFoodInheritField: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveFoodInheritField', 'id', id)
            const localVarPath = `/api/food-inherit-field/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveGroup: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveGroup', 'id', id)
            const localVarPath = `/api/group/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this import log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveImportLog: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveImportLog', 'id', id)
            const localVarPath = `/api/import-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ingredient.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveIngredient: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveIngredient', 'id', id)
            const localVarPath = `/api/ingredient/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this invite link.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveInviteLink: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveInviteLink', 'id', id)
            const localVarPath = `/api/invite-link/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveKeyword: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveKeyword', 'id', id)
            const localVarPath = `/api/keyword/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this meal plan.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveMealPlan: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveMealPlan', 'id', id)
            const localVarPath = `/api/meal-plan/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {number} id A unique integer value identifying this meal type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveMealType: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveMealType', 'id', id)
            const localVarPath = `/api/meal-type/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveProperty: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveProperty', 'id', id)
            const localVarPath = `/api/property/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrievePropertyType: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrievePropertyType', 'id', id)
            const localVarPath = `/api/property-type/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRecipe: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveRecipe', 'id', id)
            const localVarPath = `/api/recipe/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRecipeBook: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveRecipeBook', 'id', id)
            const localVarPath = `/api/recipe-book/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRecipeBookEntry: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveRecipeBookEntry', 'id', id)
            const localVarPath = `/api/recipe-book-entry/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveShoppingListEntry: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveShoppingListEntry', 'id', id)
            const localVarPath = `/api/shopping-list-entry/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveShoppingListRecipe: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveShoppingListRecipe', 'id', id)
            const localVarPath = `/api/shopping-list-recipe/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this space.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSpace: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveSpace', 'id', id)
            const localVarPath = `/api/space/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this step.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveStep: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveStep', 'id', id)
            const localVarPath = `/api/step/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this storage.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveStorage: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveStorage', 'id', id)
            const localVarPath = `/api/storage/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSupermarket: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveSupermarket', 'id', id)
            const localVarPath = `/api/supermarket/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSupermarketCategory: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveSupermarketCategory', 'id', id)
            const localVarPath = `/api/supermarket-category/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category relation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSupermarketCategoryRelation: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveSupermarketCategoryRelation', 'id', id)
            const localVarPath = `/api/supermarket-category-relation/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this sync.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSync: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveSync', 'id', id)
            const localVarPath = `/api/sync/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this sync log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSyncLog: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveSyncLog', 'id', id)
            const localVarPath = `/api/sync-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUnit: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveUnit', 'id', id)
            const localVarPath = `/api/unit/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit conversion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUnitConversion: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveUnitConversion', 'id', id)
            const localVarPath = `/api/unit-conversion/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUser: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveUser', 'id', id)
            const localVarPath = `/api/user/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUserFile: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveUserFile', 'id', id)
            const localVarPath = `/api/user-file/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} user A unique value identifying this user preference.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUserPreference: async (user: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('retrieveUserPreference', 'user', user)
            const localVarPath = `/api/user-preference/{user}/`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user space.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUserSpace: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveUserSpace', 'id', id)
            const localVarPath = `/api/user-space/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this view log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveViewLog: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveViewLog', 'id', id)
            const localVarPath = `/api/view-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * function to download a user file securely (wrapping as zip to prevent any context based XSS problems) temporary solution until a real file manager is implemented
         * @param {number} fileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrievedownloadFile: async (fileId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('retrievedownloadFile', 'fileId', fileId)
            const localVarPath = `/api/download-file/{fileId}/`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} recipeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrievegetExternalFileLink: async (recipeId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'recipeId' is not null or undefined
            assertParamExists('retrievegetExternalFileLink', 'recipeId', recipeId)
            const localVarPath = `/api/get_external_file_link/{recipeId}/`
                .replace(`{${"recipeId"}}`, encodeURIComponent(String(recipeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} recipeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrievegetRecipeFile: async (recipeId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'recipeId' is not null or undefined
            assertParamExists('retrievegetRecipeFile', 'recipeId', recipeId)
            const localVarPath = `/api/get_recipe_file/{recipeId}/`
                .replace(`{${"recipeId"}}`, encodeURIComponent(String(recipeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveshareLink: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveshareLink', 'id', id)
            const localVarPath = `/api/share-link/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * api endpoint to switch space function
         * @param {number} spaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveswitchActiveSpace: async (spaceId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'spaceId' is not null or undefined
            assertParamExists('retrieveswitchActiveSpace', 'spaceId', spaceId)
            const localVarPath = `/api/switch-active-space/{spaceId}/`
                .replace(`{${"spaceId"}}`, encodeURIComponent(String(spaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {FoodShoppingUpdate} foodShoppingUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shoppingFood: async (id: number, foodShoppingUpdate: FoodShoppingUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('shoppingFood', 'id', id)
            // verify required parameter 'foodShoppingUpdate' is not null or undefined
            assertParamExists('shoppingFood', 'foodShoppingUpdate', foodShoppingUpdate)
            const localVarPath = `/api/food/{id}/shopping/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(foodShoppingUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {RecipeShoppingUpdate} [recipeShoppingUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shoppingRecipe: async (id: number, recipeShoppingUpdate?: RecipeShoppingUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('shoppingRecipe', 'id', id)
            const localVarPath = `/api/recipe/{id}/shopping/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recipeShoppingUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this access token.
         * @param {AccessToken} accessToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccessToken: async (id: number, accessToken: AccessToken, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateAccessToken', 'id', id)
            // verify required parameter 'accessToken' is not null or undefined
            assertParamExists('updateAccessToken', 'accessToken', accessToken)
            const localVarPath = `/api/access-token/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accessToken, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this automation.
         * @param {Automation} automation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAutomation: async (id: number, automation: Automation, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateAutomation', 'id', id)
            // verify required parameter 'automation' is not null or undefined
            assertParamExists('updateAutomation', 'automation', automation)
            const localVarPath = `/api/automation/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(automation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this bookmarklet import.
         * @param {BookmarkletImport} bookmarkletImport 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBookmarkletImport: async (id: number, bookmarkletImport: BookmarkletImport, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateBookmarkletImport', 'id', id)
            // verify required parameter 'bookmarkletImport' is not null or undefined
            assertParamExists('updateBookmarkletImport', 'bookmarkletImport', bookmarkletImport)
            const localVarPath = `/api/bookmarklet-import/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bookmarkletImport, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this connector config.
         * @param {ConnectorConfigConfig} connectorConfigConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConnectorConfig: async (id: number, connectorConfigConfig: ConnectorConfigConfig, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateConnectorConfig', 'id', id)
            // verify required parameter 'connectorConfigConfig' is not null or undefined
            assertParamExists('updateConnectorConfig', 'connectorConfigConfig', connectorConfigConfig)
            const localVarPath = `/api/connector-config/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connectorConfigConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cook log.
         * @param {CookLog} cookLog 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCookLog: async (id: number, cookLog: CookLog, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateCookLog', 'id', id)
            // verify required parameter 'cookLog' is not null or undefined
            assertParamExists('updateCookLog', 'cookLog', cookLog)
            const localVarPath = `/api/cook-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cookLog, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this custom filter.
         * @param {CustomFilter} customFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomFilter: async (id: number, customFilter: CustomFilter, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateCustomFilter', 'id', id)
            // verify required parameter 'customFilter' is not null or undefined
            assertParamExists('updateCustomFilter', 'customFilter', customFilter)
            const localVarPath = `/api/custom-filter/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customFilter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this export log.
         * @param {ExportLog} exportLog 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExportLog: async (id: number, exportLog: ExportLog, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateExportLog', 'id', id)
            // verify required parameter 'exportLog' is not null or undefined
            assertParamExists('updateExportLog', 'exportLog', exportLog)
            const localVarPath = `/api/export-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(exportLog, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {Food} food 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFood: async (id: number, food: Food, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateFood', 'id', id)
            // verify required parameter 'food' is not null or undefined
            assertParamExists('updateFood', 'food', food)
            const localVarPath = `/api/food/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(food, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this import log.
         * @param {ImportLog} importLog 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateImportLog: async (id: number, importLog: ImportLog, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateImportLog', 'id', id)
            // verify required parameter 'importLog' is not null or undefined
            assertParamExists('updateImportLog', 'importLog', importLog)
            const localVarPath = `/api/import-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(importLog, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ingredient.
         * @param {Ingredient} ingredient 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIngredient: async (id: number, ingredient: Ingredient, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateIngredient', 'id', id)
            // verify required parameter 'ingredient' is not null or undefined
            assertParamExists('updateIngredient', 'ingredient', ingredient)
            const localVarPath = `/api/ingredient/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ingredient, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this invite link.
         * @param {InviteLink} inviteLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInviteLink: async (id: number, inviteLink: InviteLink, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateInviteLink', 'id', id)
            // verify required parameter 'inviteLink' is not null or undefined
            assertParamExists('updateInviteLink', 'inviteLink', inviteLink)
            const localVarPath = `/api/invite-link/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inviteLink, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {Keyword} keyword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKeyword: async (id: number, keyword: Keyword, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateKeyword', 'id', id)
            // verify required parameter 'keyword' is not null or undefined
            assertParamExists('updateKeyword', 'keyword', keyword)
            const localVarPath = `/api/keyword/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(keyword, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this meal plan.
         * @param {MealPlan} mealPlan 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMealPlan: async (id: number, mealPlan: MealPlan, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateMealPlan', 'id', id)
            // verify required parameter 'mealPlan' is not null or undefined
            assertParamExists('updateMealPlan', 'mealPlan', mealPlan)
            const localVarPath = `/api/meal-plan/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mealPlan, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {number} id A unique integer value identifying this meal type.
         * @param {MealType} mealType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMealType: async (id: number, mealType: MealType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateMealType', 'id', id)
            // verify required parameter 'mealType' is not null or undefined
            assertParamExists('updateMealType', 'mealType', mealType)
            const localVarPath = `/api/meal-type/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mealType, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property.
         * @param {Property} property 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProperty: async (id: number, property: Property, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateProperty', 'id', id)
            // verify required parameter 'property' is not null or undefined
            assertParamExists('updateProperty', 'property', property)
            const localVarPath = `/api/property/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(property, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property type.
         * @param {PropertyType} propertyType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePropertyType: async (id: number, propertyType: PropertyType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePropertyType', 'id', id)
            // verify required parameter 'propertyType' is not null or undefined
            assertParamExists('updatePropertyType', 'propertyType', propertyType)
            const localVarPath = `/api/property-type/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(propertyType, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {Recipe} recipe 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecipe: async (id: number, recipe: Recipe, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateRecipe', 'id', id)
            // verify required parameter 'recipe' is not null or undefined
            assertParamExists('updateRecipe', 'recipe', recipe)
            const localVarPath = `/api/recipe/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recipe, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book.
         * @param {RecipeBook} recipeBook 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecipeBook: async (id: number, recipeBook: RecipeBook, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateRecipeBook', 'id', id)
            // verify required parameter 'recipeBook' is not null or undefined
            assertParamExists('updateRecipeBook', 'recipeBook', recipeBook)
            const localVarPath = `/api/recipe-book/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recipeBook, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book entry.
         * @param {RecipeBookEntry} recipeBookEntry 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecipeBookEntry: async (id: number, recipeBookEntry: RecipeBookEntry, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateRecipeBookEntry', 'id', id)
            // verify required parameter 'recipeBookEntry' is not null or undefined
            assertParamExists('updateRecipeBookEntry', 'recipeBookEntry', recipeBookEntry)
            const localVarPath = `/api/recipe-book-entry/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recipeBookEntry, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list entry.
         * @param {ShoppingListEntry} shoppingListEntry 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShoppingListEntry: async (id: number, shoppingListEntry: ShoppingListEntry, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateShoppingListEntry', 'id', id)
            // verify required parameter 'shoppingListEntry' is not null or undefined
            assertParamExists('updateShoppingListEntry', 'shoppingListEntry', shoppingListEntry)
            const localVarPath = `/api/shopping-list-entry/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shoppingListEntry, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list recipe.
         * @param {ShoppingListRecipe} shoppingListRecipe 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShoppingListRecipe: async (id: number, shoppingListRecipe: ShoppingListRecipe, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateShoppingListRecipe', 'id', id)
            // verify required parameter 'shoppingListRecipe' is not null or undefined
            assertParamExists('updateShoppingListRecipe', 'shoppingListRecipe', shoppingListRecipe)
            const localVarPath = `/api/shopping-list-recipe/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shoppingListRecipe, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this step.
         * @param {Step} step 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStep: async (id: number, step: Step, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateStep', 'id', id)
            // verify required parameter 'step' is not null or undefined
            assertParamExists('updateStep', 'step', step)
            const localVarPath = `/api/step/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(step, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this storage.
         * @param {Storage} storage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStorage: async (id: number, storage: Storage, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateStorage', 'id', id)
            // verify required parameter 'storage' is not null or undefined
            assertParamExists('updateStorage', 'storage', storage)
            const localVarPath = `/api/storage/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storage, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket.
         * @param {Supermarket} supermarket 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSupermarket: async (id: number, supermarket: Supermarket, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSupermarket', 'id', id)
            // verify required parameter 'supermarket' is not null or undefined
            assertParamExists('updateSupermarket', 'supermarket', supermarket)
            const localVarPath = `/api/supermarket/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(supermarket, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category.
         * @param {SupermarketCategory} supermarketCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSupermarketCategory: async (id: number, supermarketCategory: SupermarketCategory, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSupermarketCategory', 'id', id)
            // verify required parameter 'supermarketCategory' is not null or undefined
            assertParamExists('updateSupermarketCategory', 'supermarketCategory', supermarketCategory)
            const localVarPath = `/api/supermarket-category/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(supermarketCategory, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category relation.
         * @param {SupermarketCategoryRelation} supermarketCategoryRelation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSupermarketCategoryRelation: async (id: number, supermarketCategoryRelation: SupermarketCategoryRelation, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSupermarketCategoryRelation', 'id', id)
            // verify required parameter 'supermarketCategoryRelation' is not null or undefined
            assertParamExists('updateSupermarketCategoryRelation', 'supermarketCategoryRelation', supermarketCategoryRelation)
            const localVarPath = `/api/supermarket-category-relation/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(supermarketCategoryRelation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this sync.
         * @param {Sync} sync 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSync: async (id: number, sync: Sync, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSync', 'id', id)
            // verify required parameter 'sync' is not null or undefined
            assertParamExists('updateSync', 'sync', sync)
            const localVarPath = `/api/sync/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sync, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit.
         * @param {Unit} unit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUnit: async (id: number, unit: Unit, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUnit', 'id', id)
            // verify required parameter 'unit' is not null or undefined
            assertParamExists('updateUnit', 'unit', unit)
            const localVarPath = `/api/unit/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(unit, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit conversion.
         * @param {UnitConversion} unitConversion 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUnitConversion: async (id: number, unitConversion: UnitConversion, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUnitConversion', 'id', id)
            // verify required parameter 'unitConversion' is not null or undefined
            assertParamExists('updateUnitConversion', 'unitConversion', unitConversion)
            const localVarPath = `/api/unit-conversion/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(unitConversion, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user file.
         * @param {string} name 
         * @param {string} file 
         * @param {string} fileDownload 
         * @param {string} preview 
         * @param {number} fileSizeKb 
         * @param {number} [id2] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserFile: async (id: number, name: string, file: string, fileDownload: string, preview: string, fileSizeKb: number, id2?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUserFile', 'id', id)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('updateUserFile', 'name', name)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('updateUserFile', 'file', file)
            // verify required parameter 'fileDownload' is not null or undefined
            assertParamExists('updateUserFile', 'fileDownload', fileDownload)
            // verify required parameter 'preview' is not null or undefined
            assertParamExists('updateUserFile', 'preview', preview)
            // verify required parameter 'fileSizeKb' is not null or undefined
            assertParamExists('updateUserFile', 'fileSizeKb', fileSizeKb)
            const localVarPath = `/api/user-file/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (id2 !== undefined) { 
                localVarFormParams.append('id', id2 as any);
            }
    
            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (fileDownload !== undefined) { 
                localVarFormParams.append('file_download', fileDownload as any);
            }
    
            if (preview !== undefined) { 
                localVarFormParams.append('preview', preview as any);
            }
    
            if (fileSizeKb !== undefined) { 
                localVarFormParams.append('file_size_kb', fileSizeKb as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this view log.
         * @param {ViewLog} viewLog 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateViewLog: async (id: number, viewLog: ViewLog, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateViewLog', 'id', id)
            // verify required parameter 'viewLog' is not null or undefined
            assertParamExists('updateViewLog', 'viewLog', viewLog)
            const localVarPath = `/api/view-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(viewLog, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApiApi - functional programming interface
 * @export
 */
export const ApiApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApiApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ShoppingListEntryBulk} shoppingListEntryBulk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkShoppingListEntry(shoppingListEntryBulk: ShoppingListEntryBulk, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShoppingListEntryBulk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkShoppingListEntry(shoppingListEntryBulk, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {AccessToken} accessToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAccessToken(accessToken: AccessToken, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAccessToken(accessToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {AutoMealPlan} autoMealPlan 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAutoMealPlan(autoMealPlan: AutoMealPlan, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutoMealPlan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAutoMealPlan(autoMealPlan, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Automation} automation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAutomation(automation: Automation, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Automation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAutomation(automation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {BookmarkletImport} bookmarkletImport 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBookmarkletImport(bookmarkletImport: BookmarkletImport, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BookmarkletImport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBookmarkletImport(bookmarkletImport, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ConnectorConfigConfig} connectorConfigConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createConnectorConfig(connectorConfigConfig: ConnectorConfigConfig, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectorConfigConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createConnectorConfig(connectorConfigConfig, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CookLog} cookLog 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCookLog(cookLog: CookLog, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CookLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCookLog(cookLog, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CustomFilter} customFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCustomFilter(customFilter: CustomFilter, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomFilter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCustomFilter(customFilter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ExportLog} exportLog 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createExportLog(exportLog: ExportLog, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExportLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createExportLog(exportLog, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Food} food 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFood(food: Food, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Food>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFood(food, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ImportLog} importLog 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createImportLog(importLog: ImportLog, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createImportLog(importLog, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Ingredient} ingredient 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createIngredient(ingredient: Ingredient, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ingredient>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createIngredient(ingredient, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {InviteLink} inviteLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInviteLink(inviteLink: InviteLink, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InviteLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createInviteLink(inviteLink, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Keyword} keyword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createKeyword(keyword: Keyword, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Keyword>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createKeyword(keyword, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {MealPlan} mealPlan 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMealPlan(mealPlan: MealPlan, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MealPlan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMealPlan(mealPlan, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {MealType} mealType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMealType(mealType: MealType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MealType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMealType(mealType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Property} property 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProperty(property: Property, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Property>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProperty(property, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {PropertyType} propertyType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPropertyType(propertyType: PropertyType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PropertyType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPropertyType(propertyType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Recipe} recipe 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRecipe(recipe: Recipe, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Recipe>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRecipe(recipe, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {RecipeBook} recipeBook 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRecipeBook(recipeBook: RecipeBook, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecipeBook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRecipeBook(recipeBook, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {RecipeBookEntry} recipeBookEntry 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRecipeBookEntry(recipeBookEntry: RecipeBookEntry, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecipeBookEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRecipeBookEntry(recipeBookEntry, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * function to retrieve a recipe from a given url or source string :param request: standard request with additional post parameters         - url: url to use for importing recipe         - data: if no url is given recipe is imported from provided source data         - (optional) bookmarklet: id of bookmarklet import to use, overrides URL and data attributes :return: JsonResponse containing the parsed json and images
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRecipeUrlImport(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRecipeUrlImport(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ShoppingListEntry} shoppingListEntry 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createShoppingListEntry(shoppingListEntry: ShoppingListEntry, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShoppingListEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createShoppingListEntry(shoppingListEntry, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ShoppingListRecipe} shoppingListRecipe 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createShoppingListRecipe(shoppingListRecipe: ShoppingListRecipe, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShoppingListRecipe>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createShoppingListRecipe(shoppingListRecipe, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Step} step 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createStep(step: Step, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Step>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createStep(step, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Storage} storage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createStorage(storage: Storage, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Storage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createStorage(storage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Supermarket} supermarket 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSupermarket(supermarket: Supermarket, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Supermarket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSupermarket(supermarket, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SupermarketCategory} supermarketCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSupermarketCategory(supermarketCategory: SupermarketCategory, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupermarketCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSupermarketCategory(supermarketCategory, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SupermarketCategoryRelation} supermarketCategoryRelation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSupermarketCategoryRelation(supermarketCategoryRelation: SupermarketCategoryRelation, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupermarketCategoryRelation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSupermarketCategoryRelation(supermarketCategoryRelation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Sync} sync 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSync(sync: Sync, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sync>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSync(sync, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Unit} unit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUnit(unit: Unit, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Unit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUnit(unit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {UnitConversion} unitConversion 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUnitConversion(unitConversion: UnitConversion, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitConversion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUnitConversion(unitConversion, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} name 
         * @param {string} file 
         * @param {string} fileDownload 
         * @param {string} preview 
         * @param {number} fileSizeKb 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserFile(name: string, file: string, fileDownload: string, preview: string, fileSizeKb: number, id?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserFile(name, file, fileDownload, preview, fileSizeKb, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ViewLog} viewLog 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createViewLog(viewLog: ViewLog, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ViewLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createViewLog(viewLog, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * function to handle files passed by application importer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createimportFiles(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createimportFiles(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {IngredientString} ingredientString 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createingredientFromString(ingredientString: IngredientString, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ParsedIngredient>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createingredientFromString(ingredientString, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * function to reset inheritance from api, see food method for docs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createresetFoodInheritance(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createresetFoodInheritance(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this access token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyAccessToken(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyAccessToken(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this automation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyAutomation(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyAutomation(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this bookmarklet import.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyBookmarkletImport(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyBookmarkletImport(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this connector config.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyConnectorConfig(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyConnectorConfig(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cook log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyCookLog(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyCookLog(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this custom filter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyCustomFilter(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyCustomFilter(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this export log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyExportLog(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyExportLog(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyFood(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyFood(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this import log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyImportLog(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyImportLog(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ingredient.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyIngredient(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyIngredient(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this invite link.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyInviteLink(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyInviteLink(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyKeyword(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyKeyword(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this meal plan.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyMealPlan(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyMealPlan(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {number} id A unique integer value identifying this meal type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyMealType(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyMealType(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyProperty(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyProperty(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyPropertyType(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyPropertyType(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyRecipe(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyRecipe(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyRecipeBook(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyRecipeBook(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyRecipeBookEntry(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyRecipeBookEntry(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyShoppingListEntry(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyShoppingListEntry(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyShoppingListRecipe(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyShoppingListRecipe(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this step.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyStep(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyStep(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this storage.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyStorage(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyStorage(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroySupermarket(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroySupermarket(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroySupermarketCategory(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroySupermarketCategory(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category relation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroySupermarketCategoryRelation(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroySupermarketCategoryRelation(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this sync.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroySync(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroySync(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyUnit(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyUnit(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit conversion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyUnitConversion(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyUnitConversion(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyUserFile(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyUserFile(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user space.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyUserSpace(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyUserSpace(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this view log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyViewLog(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyViewLog(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * updates the food with all possible data from the FDC Api if properties with a fdc_id already exist they will be overridden, if existing properties don\'t have a fdc_id they won\'t be changed
         * @param {number} id A unique integer value identifying this food.
         * @param {Food} food 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fdcFood(id: number, food: Food, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Food>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fdcFood(id, food, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [fromDate] Filter meal plans from date (inclusive).
         * @param {Array<string>} [mealType] Filter meal plans with MealType ID. For multiple repeat parameter.
         * @param {string} [toDate] Filter meal plans to date (inclusive).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async icalMealPlan(fromDate?: string, mealType?: Array<string>, toDate?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.icalMealPlan(fromDate, mealType, toDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {string} [image] 
         * @param {string} [imageUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageRecipe(id: number, image?: string, imageUrl?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecipeImage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageRecipe(id, image, imageUrl, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAccessTokens(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccessToken>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAccessTokens(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {Array<'DESCRIPTION_REPLACE' | 'FOOD_ALIAS' | 'FOOD_REPLACE' | 'INSTRUCTION_REPLACE' | 'KEYWORD_ALIAS' | 'NAME_REPLACE' | 'NEVER_UNIT' | 'TRANSPOSE_WORDS' | 'UNIT_ALIAS' | 'UNIT_REPLACE'>} [type] Return the Automations matching the automation type.  Repeat for multiple.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAutomations(page?: number, pageSize?: number, type?: Array<'DESCRIPTION_REPLACE' | 'FOOD_ALIAS' | 'FOOD_REPLACE' | 'INSTRUCTION_REPLACE' | 'KEYWORD_ALIAS' | 'NAME_REPLACE' | 'NEVER_UNIT' | 'TRANSPOSE_WORDS' | 'UNIT_ALIAS' | 'UNIT_REPLACE'>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedAutomationList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAutomations(page, pageSize, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBookmarkletImports(page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedBookmarkletImportListList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBookmarkletImports(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listConnectorConfigs(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConnectorConfigConfig>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listConnectorConfigs(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {number} [recipe] Filter for entries with the given recipe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCookLogs(page?: number, pageSize?: number, recipe?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedCookLogList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCookLogs(page, pageSize, recipe, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {Array<'FOOD' | 'KEYWORD' | 'RECIPE'>} [type] Return the CustomFilters matching the model type.  Repeat for multiple.
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCustomFilters(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, type?: Array<'FOOD' | 'KEYWORD' | 'RECIPE'>, updatedAt?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedCustomFilterList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCustomFilters(limit, page, pageSize, query, random, type, updatedAt, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listExportLogs(page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedExportLogList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listExportLogs(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFoodInheritFields(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FoodInheritField>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFoodInheritFields(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {number} [root] Return first level children of {obj} with ID [int].  Integer 0 will return root {obj}s.
         * @param {number} [tree] Return all self and children of {obj} with ID [int].
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFoods(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, root?: number, tree?: number, updatedAt?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedFoodList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFoods(limit, page, pageSize, query, random, root, tree, updatedAt, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGroups(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Group>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGroups(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listImportLogs(page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedImportLogList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listImportLogs(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [food] ID of food to filter for
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {number} [unit] ID of unit to filter for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listIngredients(food?: number, page?: number, pageSize?: number, unit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedIngredientList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listIngredients(food, page, pageSize, unit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [internalNote] I have no idea what internal_note is for.
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listInviteLinks(internalNote?: string, limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedInviteLinkList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listInviteLinks(internalNote, limit, page, pageSize, query, random, updatedAt, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {number} [root] Return first level children of {obj} with ID [int].  Integer 0 will return root {obj}s.
         * @param {number} [tree] Return all self and children of {obj} with ID [int].
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listKeywords(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, root?: number, tree?: number, updatedAt?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedKeywordList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listKeywords(limit, page, pageSize, query, random, root, tree, updatedAt, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [fromDate] Filter meal plans from date (inclusive).
         * @param {Array<string>} [mealType] Filter meal plans with MealType ID. For multiple repeat parameter.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [toDate] Filter meal plans to date (inclusive).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMealPlans(fromDate?: string, mealType?: Array<string>, page?: number, pageSize?: number, toDate?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedMealPlanList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMealPlans(fromDate, mealType, page, pageSize, toDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMealTypes(page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedMealTypeList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMealTypes(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Array<'ALLERGEN' | 'GOAL' | 'NUTRITION' | 'OTHER' | 'PRICE'>} [category] Return the PropertyTypes matching the property category.  Repeat for multiple.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPropertyTypes(category?: Array<'ALLERGEN' | 'GOAL' | 'NUTRITION' | 'OTHER' | 'PRICE'>, page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPropertyTypeList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPropertyTypes(category, page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPropertys(page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPropertyList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPropertys(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [book] id of book - only return recipes in that book
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {number} [recipe] id of recipe - only return books for that recipe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRecipeBookEntrys(book?: number, page?: number, pageSize?: number, recipe?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedRecipeBookEntryList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRecipeBookEntrys(book, page, pageSize, recipe, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {'asc' | 'desc'} [orderDirection] Order ascending or descending
         * @param {'id' | 'name' | 'order'} [orderField] Field to order recipe books on
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRecipeBooks(limit?: string, orderDirection?: 'asc' | 'desc', orderField?: 'id' | 'name' | 'order', page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedRecipeBookList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRecipeBooks(limit, orderDirection, orderField, page, pageSize, query, random, updatedAt, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Array<number>} [books] ID of book a recipe should be in. For multiple repeat parameter.
         * @param {Array<number>} [booksAnd] Book IDs, repeat for multiple. Return recipes with all of the books.
         * @param {Array<number>} [booksAndNot] Book IDs, repeat for multiple. Exclude recipes with all of the books.
         * @param {Array<number>} [booksOr] Book IDs, repeat for multiple. Return recipes with any of the books
         * @param {Array<number>} [booksOrNot] Book IDs, repeat for multiple. Exclude recipes with any of the books.
         * @param {string} [cookedon] Filter recipes last cooked on or after YYYY-MM-DD. Prepending - filters on or before date.
         * @param {string} [createdon] Filter recipes created on or after YYYY-MM-DD. Prepending - filters on or before date.
         * @param {Array<number>} [foods] ID of food a recipe should have. For multiple repeat parameter.
         * @param {Array<number>} [foodsAnd] Food IDs, repeat for multiple. Return recipes with all of the foods.
         * @param {Array<number>} [foodsAndNot] Food IDs, repeat for multiple. Exclude recipes with all of the foods.
         * @param {Array<number>} [foodsOr] Food IDs, repeat for multiple. Return recipes with any of the foods
         * @param {Array<number>} [foodsOrNot] Food IDs, repeat for multiple. Exclude recipes with any of the foods.
         * @param {boolean} [internal] If only internal recipes should be returned. [true/&lt;b&gt;false&lt;/b&gt;]
         * @param {Array<number>} [keywords] ID of keyword a recipe should have. For multiple repeat parameter. Equivalent to keywords_or
         * @param {Array<number>} [keywordsAnd] Keyword IDs, repeat for multiple. Return recipes with all of the keywords.
         * @param {Array<number>} [keywordsAndNot] Keyword IDs, repeat for multiple. Exclude recipes with all of the keywords.
         * @param {Array<number>} [keywordsOr] Keyword IDs, repeat for multiple. Return recipes with any of the keywords
         * @param {Array<number>} [keywordsOrNot] Keyword IDs, repeat for multiple. Exclude recipes with any of the keywords.
         * @param {boolean} [makenow] Filter recipes that can be made with OnHand food. [true/&lt;b&gt;false&lt;/b&gt;]
         * @param {string} [_new] Returns new results first in search results. [true/&lt;b&gt;false&lt;/b&gt;]
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] Query string matched (fuzzy) against recipe name. In the future also fulltext search.
         * @param {string} [random] Returns the results in randomized order. [true/&lt;b&gt;false&lt;/b&gt;]
         * @param {number} [rating] Rating a recipe should have or greater. [0 - 5] Negative value filters rating less than.
         * @param {number} [timescooked] Filter recipes cooked X times or more.  Negative values returns cooked less than X times
         * @param {number} [units] ID of unit a recipe should have.
         * @param {string} [updatedon] Filter recipes updated on or after YYYY-MM-DD. Prepending - filters on or before date.
         * @param {string} [viewedon] Filter recipes lasts viewed on or after YYYY-MM-DD. Prepending - filters on or before date.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRecipes(books?: Array<number>, booksAnd?: Array<number>, booksAndNot?: Array<number>, booksOr?: Array<number>, booksOrNot?: Array<number>, cookedon?: string, createdon?: string, foods?: Array<number>, foodsAnd?: Array<number>, foodsAndNot?: Array<number>, foodsOr?: Array<number>, foodsOrNot?: Array<number>, internal?: boolean, keywords?: Array<number>, keywordsAnd?: Array<number>, keywordsAndNot?: Array<number>, keywordsOr?: Array<number>, keywordsOrNot?: Array<number>, makenow?: boolean, _new?: string, page?: number, pageSize?: number, query?: string, random?: string, rating?: number, timescooked?: number, units?: number, updatedon?: string, viewedon?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedRecipeOverviewList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRecipes(books, booksAnd, booksAndNot, booksOr, booksOrNot, cookedon, createdon, foods, foodsAnd, foodsAndNot, foodsOr, foodsOrNot, internal, keywords, keywordsAnd, keywordsAndNot, keywordsOr, keywordsOrNot, makenow, _new, page, pageSize, query, random, rating, timescooked, units, updatedon, viewedon, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRecipes2(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RecipeFlat>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRecipes2(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [checked] Filter shopping list entries on checked.  [true, false, both, &lt;b&gt;recent&lt;/b&gt;]&lt;br&gt;                              - recent includes unchecked items and recently completed items.
         * @param {number} [id] Returns the shopping list entry with a primary key of id.  Multiple values allowed.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {number} [supermarket] Returns the shopping list entries sorted by supermarket category order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listShoppingListEntrys(checked?: string, id?: number, page?: number, pageSize?: number, supermarket?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedShoppingListEntryList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listShoppingListEntrys(checked, id, page, pageSize, supermarket, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listShoppingListRecipes(page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedShoppingListRecipeList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listShoppingListRecipes(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSpaces(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Space>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSpaces(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] Query string matched (fuzzy) against object name.
         * @param {Array<number>} [recipe] ID of recipe a step is part of. For multiple repeat parameter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSteps(page?: number, pageSize?: number, query?: string, recipe?: Array<number>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedStepList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSteps(page, pageSize, query, recipe, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listStorages(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Storage>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listStorages(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSupermarketCategoryRelations(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedSupermarketCategoryRelationList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSupermarketCategoryRelations(limit, page, pageSize, query, random, updatedAt, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSupermarketCategorys(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedSupermarketCategoryList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSupermarketCategorys(limit, page, pageSize, query, random, updatedAt, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSupermarkets(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedSupermarketList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSupermarkets(limit, page, pageSize, query, random, updatedAt, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSyncLogs(page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedSyncLogList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSyncLogs(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSyncs(page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedSyncList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSyncs(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [foodId] ID of food to filter for
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUnitConversions(foodId?: number, page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedUnitConversionList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUnitConversions(foodId, page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUnits(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedUnitList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUnits(limit, page, pageSize, query, random, updatedAt, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserFiles(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedUserFileList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserFiles(limit, page, pageSize, query, random, updatedAt, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserPreferences(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserPreference>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserPreferences(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [internalNote] I have no idea what this is
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserSpaces(internalNote?: string, page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedUserSpaceList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserSpaces(internalNote, page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Array<string>} [filterList] User IDs, repeat for multiple
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUsers(filterList?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUsers(filterList, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listViewLogs(page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedViewLogList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listViewLogs(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {number} target The ID of the {obj} you want to merge with.
         * @param {Food} food 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mergeFood(id: number, target: number, food: Food, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Food>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mergeFood(id, target, food, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {number} target The ID of the {obj} you want to merge with.
         * @param {Keyword} keyword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mergeKeyword(id: number, target: number, keyword: Keyword, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Keyword>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mergeKeyword(id, target, keyword, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category.
         * @param {number} target The ID of the {obj} you want to merge with.
         * @param {SupermarketCategory} supermarketCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mergeSupermarketCategory(id: number, target: number, supermarketCategory: SupermarketCategory, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupermarketCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mergeSupermarketCategory(id, target, supermarketCategory, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit.
         * @param {number} target The ID of the {obj} you want to merge with.
         * @param {Unit} unit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mergeUnit(id: number, target: number, unit: Unit, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Unit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mergeUnit(id, target, unit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {number} parent The ID of the desired parent of the {obj}.
         * @param {Food} food 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moveFood(id: number, parent: number, food: Food, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Food>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moveFood(id, parent, food, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {number} parent The ID of the desired parent of the {obj}.
         * @param {Keyword} keyword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moveKeyword(id: number, parent: number, keyword: Keyword, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Keyword>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moveKeyword(id, parent, keyword, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this access token.
         * @param {PatchedAccessToken} [patchedAccessToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateAccessToken(id: number, patchedAccessToken?: PatchedAccessToken, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateAccessToken(id, patchedAccessToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this automation.
         * @param {PatchedAutomation} [patchedAutomation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateAutomation(id: number, patchedAutomation?: PatchedAutomation, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Automation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateAutomation(id, patchedAutomation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this bookmarklet import.
         * @param {PatchedBookmarkletImport} [patchedBookmarkletImport] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateBookmarkletImport(id: number, patchedBookmarkletImport?: PatchedBookmarkletImport, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BookmarkletImport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateBookmarkletImport(id, patchedBookmarkletImport, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this connector config.
         * @param {PatchedConnectorConfigConfig} [patchedConnectorConfigConfig] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateConnectorConfig(id: number, patchedConnectorConfigConfig?: PatchedConnectorConfigConfig, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectorConfigConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateConnectorConfig(id, patchedConnectorConfigConfig, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cook log.
         * @param {PatchedCookLog} [patchedCookLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateCookLog(id: number, patchedCookLog?: PatchedCookLog, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CookLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateCookLog(id, patchedCookLog, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this custom filter.
         * @param {PatchedCustomFilter} [patchedCustomFilter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateCustomFilter(id: number, patchedCustomFilter?: PatchedCustomFilter, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomFilter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateCustomFilter(id, patchedCustomFilter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this export log.
         * @param {PatchedExportLog} [patchedExportLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateExportLog(id: number, patchedExportLog?: PatchedExportLog, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExportLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateExportLog(id, patchedExportLog, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {PatchedFood} [patchedFood] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateFood(id: number, patchedFood?: PatchedFood, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Food>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateFood(id, patchedFood, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this import log.
         * @param {PatchedImportLog} [patchedImportLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateImportLog(id: number, patchedImportLog?: PatchedImportLog, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateImportLog(id, patchedImportLog, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ingredient.
         * @param {PatchedIngredient} [patchedIngredient] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateIngredient(id: number, patchedIngredient?: PatchedIngredient, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ingredient>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateIngredient(id, patchedIngredient, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this invite link.
         * @param {PatchedInviteLink} [patchedInviteLink] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateInviteLink(id: number, patchedInviteLink?: PatchedInviteLink, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InviteLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateInviteLink(id, patchedInviteLink, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {PatchedKeyword} [patchedKeyword] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateKeyword(id: number, patchedKeyword?: PatchedKeyword, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Keyword>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateKeyword(id, patchedKeyword, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this meal plan.
         * @param {PatchedMealPlan} [patchedMealPlan] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateMealPlan(id: number, patchedMealPlan?: PatchedMealPlan, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MealPlan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateMealPlan(id, patchedMealPlan, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {number} id A unique integer value identifying this meal type.
         * @param {PatchedMealType} [patchedMealType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateMealType(id: number, patchedMealType?: PatchedMealType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MealType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateMealType(id, patchedMealType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property.
         * @param {PatchedProperty} [patchedProperty] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateProperty(id: number, patchedProperty?: PatchedProperty, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Property>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateProperty(id, patchedProperty, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property type.
         * @param {PatchedPropertyType} [patchedPropertyType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdatePropertyType(id: number, patchedPropertyType?: PatchedPropertyType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PropertyType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdatePropertyType(id, patchedPropertyType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {PatchedRecipe} [patchedRecipe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateRecipe(id: number, patchedRecipe?: PatchedRecipe, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Recipe>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateRecipe(id, patchedRecipe, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book.
         * @param {PatchedRecipeBook} [patchedRecipeBook] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateRecipeBook(id: number, patchedRecipeBook?: PatchedRecipeBook, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecipeBook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateRecipeBook(id, patchedRecipeBook, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book entry.
         * @param {PatchedRecipeBookEntry} [patchedRecipeBookEntry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateRecipeBookEntry(id: number, patchedRecipeBookEntry?: PatchedRecipeBookEntry, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecipeBookEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateRecipeBookEntry(id, patchedRecipeBookEntry, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list entry.
         * @param {PatchedShoppingListEntry} [patchedShoppingListEntry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateShoppingListEntry(id: number, patchedShoppingListEntry?: PatchedShoppingListEntry, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShoppingListEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateShoppingListEntry(id, patchedShoppingListEntry, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list recipe.
         * @param {PatchedShoppingListRecipe} [patchedShoppingListRecipe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateShoppingListRecipe(id: number, patchedShoppingListRecipe?: PatchedShoppingListRecipe, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShoppingListRecipe>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateShoppingListRecipe(id, patchedShoppingListRecipe, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this space.
         * @param {PatchedSpace} [patchedSpace] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateSpace(id: number, patchedSpace?: PatchedSpace, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Space>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateSpace(id, patchedSpace, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this step.
         * @param {PatchedStep} [patchedStep] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateStep(id: number, patchedStep?: PatchedStep, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Step>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateStep(id, patchedStep, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this storage.
         * @param {PatchedStorage} [patchedStorage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateStorage(id: number, patchedStorage?: PatchedStorage, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Storage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateStorage(id, patchedStorage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket.
         * @param {PatchedSupermarket} [patchedSupermarket] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateSupermarket(id: number, patchedSupermarket?: PatchedSupermarket, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Supermarket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateSupermarket(id, patchedSupermarket, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category.
         * @param {PatchedSupermarketCategory} [patchedSupermarketCategory] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateSupermarketCategory(id: number, patchedSupermarketCategory?: PatchedSupermarketCategory, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupermarketCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateSupermarketCategory(id, patchedSupermarketCategory, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category relation.
         * @param {PatchedSupermarketCategoryRelation} [patchedSupermarketCategoryRelation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateSupermarketCategoryRelation(id: number, patchedSupermarketCategoryRelation?: PatchedSupermarketCategoryRelation, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupermarketCategoryRelation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateSupermarketCategoryRelation(id, patchedSupermarketCategoryRelation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this sync.
         * @param {PatchedSync} [patchedSync] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateSync(id: number, patchedSync?: PatchedSync, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sync>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateSync(id, patchedSync, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit.
         * @param {PatchedUnit} [patchedUnit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateUnit(id: number, patchedUnit?: PatchedUnit, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Unit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateUnit(id, patchedUnit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit conversion.
         * @param {PatchedUnitConversion} [patchedUnitConversion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateUnitConversion(id: number, patchedUnitConversion?: PatchedUnitConversion, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitConversion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateUnitConversion(id, patchedUnitConversion, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {PatchedUser} [patchedUser] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateUser(id: number, patchedUser?: PatchedUser, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateUser(id, patchedUser, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user file.
         * @param {number} [id2] 
         * @param {string} [name] 
         * @param {string} [file] 
         * @param {string} [fileDownload] 
         * @param {string} [preview] 
         * @param {number} [fileSizeKb] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateUserFile(id: number, id2?: number, name?: string, file?: string, fileDownload?: string, preview?: string, fileSizeKb?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateUserFile(id, id2, name, file, fileDownload, preview, fileSizeKb, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} user A unique value identifying this user preference.
         * @param {PatchedUserPreference} [patchedUserPreference] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateUserPreference(user: number, patchedUserPreference?: PatchedUserPreference, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPreference>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateUserPreference(user, patchedUserPreference, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user space.
         * @param {PatchedUserSpace} [patchedUserSpace] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateUserSpace(id: number, patchedUserSpace?: PatchedUserSpace, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSpace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateUserSpace(id, patchedUserSpace, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this view log.
         * @param {PatchedViewLog} [patchedViewLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateViewLog(id: number, patchedViewLog?: PatchedViewLog, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ViewLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateViewLog(id, patchedViewLog, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async relatedRecipe(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecipeSimple>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.relatedRecipe(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this access token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveAccessToken(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveAccessToken(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this automation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveAutomation(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Automation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveAutomation(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this bookmarklet import.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveBookmarkletImport(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BookmarkletImport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveBookmarkletImport(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this connector config.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveConnectorConfig(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectorConfigConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveConnectorConfig(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cook log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveCookLog(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CookLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveCookLog(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this custom filter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveCustomFilter(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomFilter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveCustomFilter(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this export log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveExportLog(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExportLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveExportLog(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveFood(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Food>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveFood(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food inherit field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveFoodInheritField(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FoodInheritField>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveFoodInheritField(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveGroup(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveGroup(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this import log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveImportLog(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveImportLog(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ingredient.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveIngredient(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ingredient>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveIngredient(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this invite link.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveInviteLink(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InviteLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveInviteLink(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveKeyword(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Keyword>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveKeyword(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this meal plan.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveMealPlan(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MealPlan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveMealPlan(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {number} id A unique integer value identifying this meal type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveMealType(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MealType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveMealType(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveProperty(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Property>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveProperty(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrievePropertyType(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PropertyType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrievePropertyType(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveRecipe(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Recipe>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveRecipe(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveRecipeBook(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecipeBook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveRecipeBook(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveRecipeBookEntry(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecipeBookEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveRecipeBookEntry(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveShoppingListEntry(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShoppingListEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveShoppingListEntry(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveShoppingListRecipe(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShoppingListRecipe>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveShoppingListRecipe(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this space.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveSpace(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Space>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveSpace(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this step.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveStep(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Step>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveStep(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this storage.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveStorage(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Storage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveStorage(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveSupermarket(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Supermarket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveSupermarket(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveSupermarketCategory(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupermarketCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveSupermarketCategory(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category relation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveSupermarketCategoryRelation(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupermarketCategoryRelation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveSupermarketCategoryRelation(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this sync.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveSync(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sync>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveSync(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this sync log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveSyncLog(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SyncLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveSyncLog(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveUnit(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Unit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveUnit(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit conversion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveUnitConversion(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitConversion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveUnitConversion(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveUser(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveUser(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveUserFile(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveUserFile(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} user A unique value identifying this user preference.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveUserPreference(user: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPreference>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveUserPreference(user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user space.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveUserSpace(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSpace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveUserSpace(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this view log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveViewLog(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ViewLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveViewLog(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * function to download a user file securely (wrapping as zip to prevent any context based XSS problems) temporary solution until a real file manager is implemented
         * @param {number} fileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrievedownloadFile(fileId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrievedownloadFile(fileId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} recipeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrievegetExternalFileLink(recipeId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrievegetExternalFileLink(recipeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} recipeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrievegetRecipeFile(recipeId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrievegetRecipeFile(recipeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveshareLink(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShareLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveshareLink(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * api endpoint to switch space function
         * @param {number} spaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveswitchActiveSpace(spaceId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveswitchActiveSpace(spaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {FoodShoppingUpdate} foodShoppingUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shoppingFood(id: number, foodShoppingUpdate: FoodShoppingUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FoodShoppingUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shoppingFood(id, foodShoppingUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {RecipeShoppingUpdate} [recipeShoppingUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shoppingRecipe(id: number, recipeShoppingUpdate?: RecipeShoppingUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecipeShoppingUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shoppingRecipe(id, recipeShoppingUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this access token.
         * @param {AccessToken} accessToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAccessToken(id: number, accessToken: AccessToken, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAccessToken(id, accessToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this automation.
         * @param {Automation} automation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAutomation(id: number, automation: Automation, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Automation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAutomation(id, automation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this bookmarklet import.
         * @param {BookmarkletImport} bookmarkletImport 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBookmarkletImport(id: number, bookmarkletImport: BookmarkletImport, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BookmarkletImport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBookmarkletImport(id, bookmarkletImport, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this connector config.
         * @param {ConnectorConfigConfig} connectorConfigConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateConnectorConfig(id: number, connectorConfigConfig: ConnectorConfigConfig, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectorConfigConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateConnectorConfig(id, connectorConfigConfig, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cook log.
         * @param {CookLog} cookLog 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCookLog(id: number, cookLog: CookLog, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CookLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCookLog(id, cookLog, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this custom filter.
         * @param {CustomFilter} customFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCustomFilter(id: number, customFilter: CustomFilter, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomFilter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCustomFilter(id, customFilter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this export log.
         * @param {ExportLog} exportLog 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateExportLog(id: number, exportLog: ExportLog, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExportLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateExportLog(id, exportLog, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {Food} food 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFood(id: number, food: Food, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Food>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFood(id, food, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this import log.
         * @param {ImportLog} importLog 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateImportLog(id: number, importLog: ImportLog, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateImportLog(id, importLog, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ingredient.
         * @param {Ingredient} ingredient 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateIngredient(id: number, ingredient: Ingredient, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ingredient>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateIngredient(id, ingredient, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this invite link.
         * @param {InviteLink} inviteLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateInviteLink(id: number, inviteLink: InviteLink, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InviteLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateInviteLink(id, inviteLink, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {Keyword} keyword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateKeyword(id: number, keyword: Keyword, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Keyword>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateKeyword(id, keyword, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this meal plan.
         * @param {MealPlan} mealPlan 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMealPlan(id: number, mealPlan: MealPlan, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MealPlan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMealPlan(id, mealPlan, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {number} id A unique integer value identifying this meal type.
         * @param {MealType} mealType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMealType(id: number, mealType: MealType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MealType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMealType(id, mealType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property.
         * @param {Property} property 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProperty(id: number, property: Property, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Property>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProperty(id, property, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property type.
         * @param {PropertyType} propertyType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePropertyType(id: number, propertyType: PropertyType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PropertyType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePropertyType(id, propertyType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {Recipe} recipe 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRecipe(id: number, recipe: Recipe, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Recipe>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRecipe(id, recipe, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book.
         * @param {RecipeBook} recipeBook 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRecipeBook(id: number, recipeBook: RecipeBook, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecipeBook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRecipeBook(id, recipeBook, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book entry.
         * @param {RecipeBookEntry} recipeBookEntry 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRecipeBookEntry(id: number, recipeBookEntry: RecipeBookEntry, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecipeBookEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRecipeBookEntry(id, recipeBookEntry, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list entry.
         * @param {ShoppingListEntry} shoppingListEntry 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateShoppingListEntry(id: number, shoppingListEntry: ShoppingListEntry, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShoppingListEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateShoppingListEntry(id, shoppingListEntry, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list recipe.
         * @param {ShoppingListRecipe} shoppingListRecipe 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateShoppingListRecipe(id: number, shoppingListRecipe: ShoppingListRecipe, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShoppingListRecipe>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateShoppingListRecipe(id, shoppingListRecipe, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this step.
         * @param {Step} step 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateStep(id: number, step: Step, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Step>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateStep(id, step, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this storage.
         * @param {Storage} storage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateStorage(id: number, storage: Storage, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Storage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateStorage(id, storage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket.
         * @param {Supermarket} supermarket 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSupermarket(id: number, supermarket: Supermarket, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Supermarket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSupermarket(id, supermarket, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category.
         * @param {SupermarketCategory} supermarketCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSupermarketCategory(id: number, supermarketCategory: SupermarketCategory, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupermarketCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSupermarketCategory(id, supermarketCategory, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category relation.
         * @param {SupermarketCategoryRelation} supermarketCategoryRelation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSupermarketCategoryRelation(id: number, supermarketCategoryRelation: SupermarketCategoryRelation, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupermarketCategoryRelation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSupermarketCategoryRelation(id, supermarketCategoryRelation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this sync.
         * @param {Sync} sync 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSync(id: number, sync: Sync, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sync>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSync(id, sync, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit.
         * @param {Unit} unit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUnit(id: number, unit: Unit, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Unit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUnit(id, unit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit conversion.
         * @param {UnitConversion} unitConversion 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUnitConversion(id: number, unitConversion: UnitConversion, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitConversion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUnitConversion(id, unitConversion, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user file.
         * @param {string} name 
         * @param {string} file 
         * @param {string} fileDownload 
         * @param {string} preview 
         * @param {number} fileSizeKb 
         * @param {number} [id2] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserFile(id: number, name: string, file: string, fileDownload: string, preview: string, fileSizeKb: number, id2?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserFile(id, name, file, fileDownload, preview, fileSizeKb, id2, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this view log.
         * @param {ViewLog} viewLog 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateViewLog(id: number, viewLog: ViewLog, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ViewLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateViewLog(id, viewLog, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApiApi - factory interface
 * @export
 */
export const ApiApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApiApiFp(configuration)
    return {
        /**
         * 
         * @param {ShoppingListEntryBulk} shoppingListEntryBulk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkShoppingListEntry(shoppingListEntryBulk: ShoppingListEntryBulk, options?: any): AxiosPromise<ShoppingListEntryBulk> {
            return localVarFp.bulkShoppingListEntry(shoppingListEntryBulk, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AccessToken} accessToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccessToken(accessToken: AccessToken, options?: any): AxiosPromise<AccessToken> {
            return localVarFp.createAccessToken(accessToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AutoMealPlan} autoMealPlan 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAutoMealPlan(autoMealPlan: AutoMealPlan, options?: any): AxiosPromise<AutoMealPlan> {
            return localVarFp.createAutoMealPlan(autoMealPlan, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Automation} automation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAutomation(automation: Automation, options?: any): AxiosPromise<Automation> {
            return localVarFp.createAutomation(automation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {BookmarkletImport} bookmarkletImport 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBookmarkletImport(bookmarkletImport: BookmarkletImport, options?: any): AxiosPromise<BookmarkletImport> {
            return localVarFp.createBookmarkletImport(bookmarkletImport, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ConnectorConfigConfig} connectorConfigConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnectorConfig(connectorConfigConfig: ConnectorConfigConfig, options?: any): AxiosPromise<ConnectorConfigConfig> {
            return localVarFp.createConnectorConfig(connectorConfigConfig, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CookLog} cookLog 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCookLog(cookLog: CookLog, options?: any): AxiosPromise<CookLog> {
            return localVarFp.createCookLog(cookLog, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CustomFilter} customFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomFilter(customFilter: CustomFilter, options?: any): AxiosPromise<CustomFilter> {
            return localVarFp.createCustomFilter(customFilter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ExportLog} exportLog 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExportLog(exportLog: ExportLog, options?: any): AxiosPromise<ExportLog> {
            return localVarFp.createExportLog(exportLog, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Food} food 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFood(food: Food, options?: any): AxiosPromise<Food> {
            return localVarFp.createFood(food, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ImportLog} importLog 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createImportLog(importLog: ImportLog, options?: any): AxiosPromise<ImportLog> {
            return localVarFp.createImportLog(importLog, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Ingredient} ingredient 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIngredient(ingredient: Ingredient, options?: any): AxiosPromise<Ingredient> {
            return localVarFp.createIngredient(ingredient, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {InviteLink} inviteLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInviteLink(inviteLink: InviteLink, options?: any): AxiosPromise<InviteLink> {
            return localVarFp.createInviteLink(inviteLink, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Keyword} keyword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKeyword(keyword: Keyword, options?: any): AxiosPromise<Keyword> {
            return localVarFp.createKeyword(keyword, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {MealPlan} mealPlan 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMealPlan(mealPlan: MealPlan, options?: any): AxiosPromise<MealPlan> {
            return localVarFp.createMealPlan(mealPlan, options).then((request) => request(axios, basePath));
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {MealType} mealType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMealType(mealType: MealType, options?: any): AxiosPromise<MealType> {
            return localVarFp.createMealType(mealType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Property} property 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProperty(property: Property, options?: any): AxiosPromise<Property> {
            return localVarFp.createProperty(property, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PropertyType} propertyType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyType(propertyType: PropertyType, options?: any): AxiosPromise<PropertyType> {
            return localVarFp.createPropertyType(propertyType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Recipe} recipe 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecipe(recipe: Recipe, options?: any): AxiosPromise<Recipe> {
            return localVarFp.createRecipe(recipe, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RecipeBook} recipeBook 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecipeBook(recipeBook: RecipeBook, options?: any): AxiosPromise<RecipeBook> {
            return localVarFp.createRecipeBook(recipeBook, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RecipeBookEntry} recipeBookEntry 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecipeBookEntry(recipeBookEntry: RecipeBookEntry, options?: any): AxiosPromise<RecipeBookEntry> {
            return localVarFp.createRecipeBookEntry(recipeBookEntry, options).then((request) => request(axios, basePath));
        },
        /**
         * function to retrieve a recipe from a given url or source string :param request: standard request with additional post parameters         - url: url to use for importing recipe         - data: if no url is given recipe is imported from provided source data         - (optional) bookmarklet: id of bookmarklet import to use, overrides URL and data attributes :return: JsonResponse containing the parsed json and images
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecipeUrlImport(options?: any): AxiosPromise<void> {
            return localVarFp.createRecipeUrlImport(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ShoppingListEntry} shoppingListEntry 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShoppingListEntry(shoppingListEntry: ShoppingListEntry, options?: any): AxiosPromise<ShoppingListEntry> {
            return localVarFp.createShoppingListEntry(shoppingListEntry, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ShoppingListRecipe} shoppingListRecipe 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShoppingListRecipe(shoppingListRecipe: ShoppingListRecipe, options?: any): AxiosPromise<ShoppingListRecipe> {
            return localVarFp.createShoppingListRecipe(shoppingListRecipe, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Step} step 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStep(step: Step, options?: any): AxiosPromise<Step> {
            return localVarFp.createStep(step, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Storage} storage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStorage(storage: Storage, options?: any): AxiosPromise<Storage> {
            return localVarFp.createStorage(storage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Supermarket} supermarket 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSupermarket(supermarket: Supermarket, options?: any): AxiosPromise<Supermarket> {
            return localVarFp.createSupermarket(supermarket, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SupermarketCategory} supermarketCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSupermarketCategory(supermarketCategory: SupermarketCategory, options?: any): AxiosPromise<SupermarketCategory> {
            return localVarFp.createSupermarketCategory(supermarketCategory, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SupermarketCategoryRelation} supermarketCategoryRelation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSupermarketCategoryRelation(supermarketCategoryRelation: SupermarketCategoryRelation, options?: any): AxiosPromise<SupermarketCategoryRelation> {
            return localVarFp.createSupermarketCategoryRelation(supermarketCategoryRelation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Sync} sync 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSync(sync: Sync, options?: any): AxiosPromise<Sync> {
            return localVarFp.createSync(sync, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Unit} unit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUnit(unit: Unit, options?: any): AxiosPromise<Unit> {
            return localVarFp.createUnit(unit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UnitConversion} unitConversion 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUnitConversion(unitConversion: UnitConversion, options?: any): AxiosPromise<UnitConversion> {
            return localVarFp.createUnitConversion(unitConversion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} name 
         * @param {string} file 
         * @param {string} fileDownload 
         * @param {string} preview 
         * @param {number} fileSizeKb 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserFile(name: string, file: string, fileDownload: string, preview: string, fileSizeKb: number, id?: number, options?: any): AxiosPromise<UserFile> {
            return localVarFp.createUserFile(name, file, fileDownload, preview, fileSizeKb, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ViewLog} viewLog 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createViewLog(viewLog: ViewLog, options?: any): AxiosPromise<ViewLog> {
            return localVarFp.createViewLog(viewLog, options).then((request) => request(axios, basePath));
        },
        /**
         * function to handle files passed by application importer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createimportFiles(options?: any): AxiosPromise<void> {
            return localVarFp.createimportFiles(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {IngredientString} ingredientString 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createingredientFromString(ingredientString: IngredientString, options?: any): AxiosPromise<ParsedIngredient> {
            return localVarFp.createingredientFromString(ingredientString, options).then((request) => request(axios, basePath));
        },
        /**
         * function to reset inheritance from api, see food method for docs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createresetFoodInheritance(options?: any): AxiosPromise<void> {
            return localVarFp.createresetFoodInheritance(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this access token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyAccessToken(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.destroyAccessToken(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this automation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyAutomation(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.destroyAutomation(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this bookmarklet import.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyBookmarkletImport(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.destroyBookmarkletImport(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this connector config.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyConnectorConfig(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.destroyConnectorConfig(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cook log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyCookLog(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.destroyCookLog(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this custom filter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyCustomFilter(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.destroyCustomFilter(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this export log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyExportLog(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.destroyExportLog(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyFood(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.destroyFood(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this import log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyImportLog(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.destroyImportLog(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ingredient.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyIngredient(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.destroyIngredient(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this invite link.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyInviteLink(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.destroyInviteLink(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyKeyword(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.destroyKeyword(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this meal plan.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyMealPlan(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.destroyMealPlan(id, options).then((request) => request(axios, basePath));
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {number} id A unique integer value identifying this meal type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyMealType(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.destroyMealType(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyProperty(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.destroyProperty(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyPropertyType(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.destroyPropertyType(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyRecipe(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.destroyRecipe(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyRecipeBook(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.destroyRecipeBook(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyRecipeBookEntry(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.destroyRecipeBookEntry(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyShoppingListEntry(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.destroyShoppingListEntry(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyShoppingListRecipe(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.destroyShoppingListRecipe(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this step.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyStep(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.destroyStep(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this storage.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyStorage(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.destroyStorage(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroySupermarket(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.destroySupermarket(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroySupermarketCategory(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.destroySupermarketCategory(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category relation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroySupermarketCategoryRelation(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.destroySupermarketCategoryRelation(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this sync.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroySync(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.destroySync(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyUnit(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.destroyUnit(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit conversion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyUnitConversion(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.destroyUnitConversion(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyUserFile(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.destroyUserFile(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user space.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyUserSpace(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.destroyUserSpace(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this view log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyViewLog(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.destroyViewLog(id, options).then((request) => request(axios, basePath));
        },
        /**
         * updates the food with all possible data from the FDC Api if properties with a fdc_id already exist they will be overridden, if existing properties don\'t have a fdc_id they won\'t be changed
         * @param {number} id A unique integer value identifying this food.
         * @param {Food} food 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fdcFood(id: number, food: Food, options?: any): AxiosPromise<Food> {
            return localVarFp.fdcFood(id, food, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [fromDate] Filter meal plans from date (inclusive).
         * @param {Array<string>} [mealType] Filter meal plans with MealType ID. For multiple repeat parameter.
         * @param {string} [toDate] Filter meal plans to date (inclusive).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        icalMealPlan(fromDate?: string, mealType?: Array<string>, toDate?: string, options?: any): AxiosPromise<string> {
            return localVarFp.icalMealPlan(fromDate, mealType, toDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {string} [image] 
         * @param {string} [imageUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageRecipe(id: number, image?: string, imageUrl?: string, options?: any): AxiosPromise<RecipeImage> {
            return localVarFp.imageRecipe(id, image, imageUrl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccessTokens(options?: any): AxiosPromise<Array<AccessToken>> {
            return localVarFp.listAccessTokens(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {Array<'DESCRIPTION_REPLACE' | 'FOOD_ALIAS' | 'FOOD_REPLACE' | 'INSTRUCTION_REPLACE' | 'KEYWORD_ALIAS' | 'NAME_REPLACE' | 'NEVER_UNIT' | 'TRANSPOSE_WORDS' | 'UNIT_ALIAS' | 'UNIT_REPLACE'>} [type] Return the Automations matching the automation type.  Repeat for multiple.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAutomations(page?: number, pageSize?: number, type?: Array<'DESCRIPTION_REPLACE' | 'FOOD_ALIAS' | 'FOOD_REPLACE' | 'INSTRUCTION_REPLACE' | 'KEYWORD_ALIAS' | 'NAME_REPLACE' | 'NEVER_UNIT' | 'TRANSPOSE_WORDS' | 'UNIT_ALIAS' | 'UNIT_REPLACE'>, options?: any): AxiosPromise<PaginatedAutomationList> {
            return localVarFp.listAutomations(page, pageSize, type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBookmarkletImports(page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedBookmarkletImportListList> {
            return localVarFp.listBookmarkletImports(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConnectorConfigs(options?: any): AxiosPromise<Array<ConnectorConfigConfig>> {
            return localVarFp.listConnectorConfigs(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {number} [recipe] Filter for entries with the given recipe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCookLogs(page?: number, pageSize?: number, recipe?: number, options?: any): AxiosPromise<PaginatedCookLogList> {
            return localVarFp.listCookLogs(page, pageSize, recipe, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {Array<'FOOD' | 'KEYWORD' | 'RECIPE'>} [type] Return the CustomFilters matching the model type.  Repeat for multiple.
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCustomFilters(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, type?: Array<'FOOD' | 'KEYWORD' | 'RECIPE'>, updatedAt?: string, options?: any): AxiosPromise<PaginatedCustomFilterList> {
            return localVarFp.listCustomFilters(limit, page, pageSize, query, random, type, updatedAt, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExportLogs(page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedExportLogList> {
            return localVarFp.listExportLogs(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFoodInheritFields(options?: any): AxiosPromise<Array<FoodInheritField>> {
            return localVarFp.listFoodInheritFields(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {number} [root] Return first level children of {obj} with ID [int].  Integer 0 will return root {obj}s.
         * @param {number} [tree] Return all self and children of {obj} with ID [int].
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFoods(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, root?: number, tree?: number, updatedAt?: string, options?: any): AxiosPromise<PaginatedFoodList> {
            return localVarFp.listFoods(limit, page, pageSize, query, random, root, tree, updatedAt, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroups(options?: any): AxiosPromise<Array<Group>> {
            return localVarFp.listGroups(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listImportLogs(page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedImportLogList> {
            return localVarFp.listImportLogs(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [food] ID of food to filter for
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {number} [unit] ID of unit to filter for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIngredients(food?: number, page?: number, pageSize?: number, unit?: number, options?: any): AxiosPromise<PaginatedIngredientList> {
            return localVarFp.listIngredients(food, page, pageSize, unit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [internalNote] I have no idea what internal_note is for.
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInviteLinks(internalNote?: string, limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any): AxiosPromise<PaginatedInviteLinkList> {
            return localVarFp.listInviteLinks(internalNote, limit, page, pageSize, query, random, updatedAt, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {number} [root] Return first level children of {obj} with ID [int].  Integer 0 will return root {obj}s.
         * @param {number} [tree] Return all self and children of {obj} with ID [int].
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listKeywords(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, root?: number, tree?: number, updatedAt?: string, options?: any): AxiosPromise<PaginatedKeywordList> {
            return localVarFp.listKeywords(limit, page, pageSize, query, random, root, tree, updatedAt, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [fromDate] Filter meal plans from date (inclusive).
         * @param {Array<string>} [mealType] Filter meal plans with MealType ID. For multiple repeat parameter.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [toDate] Filter meal plans to date (inclusive).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMealPlans(fromDate?: string, mealType?: Array<string>, page?: number, pageSize?: number, toDate?: string, options?: any): AxiosPromise<PaginatedMealPlanList> {
            return localVarFp.listMealPlans(fromDate, mealType, page, pageSize, toDate, options).then((request) => request(axios, basePath));
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMealTypes(page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedMealTypeList> {
            return localVarFp.listMealTypes(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<'ALLERGEN' | 'GOAL' | 'NUTRITION' | 'OTHER' | 'PRICE'>} [category] Return the PropertyTypes matching the property category.  Repeat for multiple.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPropertyTypes(category?: Array<'ALLERGEN' | 'GOAL' | 'NUTRITION' | 'OTHER' | 'PRICE'>, page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedPropertyTypeList> {
            return localVarFp.listPropertyTypes(category, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPropertys(page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedPropertyList> {
            return localVarFp.listPropertys(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [book] id of book - only return recipes in that book
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {number} [recipe] id of recipe - only return books for that recipe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRecipeBookEntrys(book?: number, page?: number, pageSize?: number, recipe?: number, options?: any): AxiosPromise<PaginatedRecipeBookEntryList> {
            return localVarFp.listRecipeBookEntrys(book, page, pageSize, recipe, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {'asc' | 'desc'} [orderDirection] Order ascending or descending
         * @param {'id' | 'name' | 'order'} [orderField] Field to order recipe books on
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRecipeBooks(limit?: string, orderDirection?: 'asc' | 'desc', orderField?: 'id' | 'name' | 'order', page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any): AxiosPromise<PaginatedRecipeBookList> {
            return localVarFp.listRecipeBooks(limit, orderDirection, orderField, page, pageSize, query, random, updatedAt, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<number>} [books] ID of book a recipe should be in. For multiple repeat parameter.
         * @param {Array<number>} [booksAnd] Book IDs, repeat for multiple. Return recipes with all of the books.
         * @param {Array<number>} [booksAndNot] Book IDs, repeat for multiple. Exclude recipes with all of the books.
         * @param {Array<number>} [booksOr] Book IDs, repeat for multiple. Return recipes with any of the books
         * @param {Array<number>} [booksOrNot] Book IDs, repeat for multiple. Exclude recipes with any of the books.
         * @param {string} [cookedon] Filter recipes last cooked on or after YYYY-MM-DD. Prepending - filters on or before date.
         * @param {string} [createdon] Filter recipes created on or after YYYY-MM-DD. Prepending - filters on or before date.
         * @param {Array<number>} [foods] ID of food a recipe should have. For multiple repeat parameter.
         * @param {Array<number>} [foodsAnd] Food IDs, repeat for multiple. Return recipes with all of the foods.
         * @param {Array<number>} [foodsAndNot] Food IDs, repeat for multiple. Exclude recipes with all of the foods.
         * @param {Array<number>} [foodsOr] Food IDs, repeat for multiple. Return recipes with any of the foods
         * @param {Array<number>} [foodsOrNot] Food IDs, repeat for multiple. Exclude recipes with any of the foods.
         * @param {boolean} [internal] If only internal recipes should be returned. [true/&lt;b&gt;false&lt;/b&gt;]
         * @param {Array<number>} [keywords] ID of keyword a recipe should have. For multiple repeat parameter. Equivalent to keywords_or
         * @param {Array<number>} [keywordsAnd] Keyword IDs, repeat for multiple. Return recipes with all of the keywords.
         * @param {Array<number>} [keywordsAndNot] Keyword IDs, repeat for multiple. Exclude recipes with all of the keywords.
         * @param {Array<number>} [keywordsOr] Keyword IDs, repeat for multiple. Return recipes with any of the keywords
         * @param {Array<number>} [keywordsOrNot] Keyword IDs, repeat for multiple. Exclude recipes with any of the keywords.
         * @param {boolean} [makenow] Filter recipes that can be made with OnHand food. [true/&lt;b&gt;false&lt;/b&gt;]
         * @param {string} [_new] Returns new results first in search results. [true/&lt;b&gt;false&lt;/b&gt;]
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] Query string matched (fuzzy) against recipe name. In the future also fulltext search.
         * @param {string} [random] Returns the results in randomized order. [true/&lt;b&gt;false&lt;/b&gt;]
         * @param {number} [rating] Rating a recipe should have or greater. [0 - 5] Negative value filters rating less than.
         * @param {number} [timescooked] Filter recipes cooked X times or more.  Negative values returns cooked less than X times
         * @param {number} [units] ID of unit a recipe should have.
         * @param {string} [updatedon] Filter recipes updated on or after YYYY-MM-DD. Prepending - filters on or before date.
         * @param {string} [viewedon] Filter recipes lasts viewed on or after YYYY-MM-DD. Prepending - filters on or before date.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRecipes(books?: Array<number>, booksAnd?: Array<number>, booksAndNot?: Array<number>, booksOr?: Array<number>, booksOrNot?: Array<number>, cookedon?: string, createdon?: string, foods?: Array<number>, foodsAnd?: Array<number>, foodsAndNot?: Array<number>, foodsOr?: Array<number>, foodsOrNot?: Array<number>, internal?: boolean, keywords?: Array<number>, keywordsAnd?: Array<number>, keywordsAndNot?: Array<number>, keywordsOr?: Array<number>, keywordsOrNot?: Array<number>, makenow?: boolean, _new?: string, page?: number, pageSize?: number, query?: string, random?: string, rating?: number, timescooked?: number, units?: number, updatedon?: string, viewedon?: string, options?: any): AxiosPromise<PaginatedRecipeOverviewList> {
            return localVarFp.listRecipes(books, booksAnd, booksAndNot, booksOr, booksOrNot, cookedon, createdon, foods, foodsAnd, foodsAndNot, foodsOr, foodsOrNot, internal, keywords, keywordsAnd, keywordsAndNot, keywordsOr, keywordsOrNot, makenow, _new, page, pageSize, query, random, rating, timescooked, units, updatedon, viewedon, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRecipes2(options?: any): AxiosPromise<Array<RecipeFlat>> {
            return localVarFp.listRecipes2(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [checked] Filter shopping list entries on checked.  [true, false, both, &lt;b&gt;recent&lt;/b&gt;]&lt;br&gt;                              - recent includes unchecked items and recently completed items.
         * @param {number} [id] Returns the shopping list entry with a primary key of id.  Multiple values allowed.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {number} [supermarket] Returns the shopping list entries sorted by supermarket category order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listShoppingListEntrys(checked?: string, id?: number, page?: number, pageSize?: number, supermarket?: number, options?: any): AxiosPromise<PaginatedShoppingListEntryList> {
            return localVarFp.listShoppingListEntrys(checked, id, page, pageSize, supermarket, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listShoppingListRecipes(page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedShoppingListRecipeList> {
            return localVarFp.listShoppingListRecipes(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSpaces(options?: any): AxiosPromise<Array<Space>> {
            return localVarFp.listSpaces(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] Query string matched (fuzzy) against object name.
         * @param {Array<number>} [recipe] ID of recipe a step is part of. For multiple repeat parameter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSteps(page?: number, pageSize?: number, query?: string, recipe?: Array<number>, options?: any): AxiosPromise<PaginatedStepList> {
            return localVarFp.listSteps(page, pageSize, query, recipe, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listStorages(options?: any): AxiosPromise<Array<Storage>> {
            return localVarFp.listStorages(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSupermarketCategoryRelations(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any): AxiosPromise<PaginatedSupermarketCategoryRelationList> {
            return localVarFp.listSupermarketCategoryRelations(limit, page, pageSize, query, random, updatedAt, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSupermarketCategorys(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any): AxiosPromise<PaginatedSupermarketCategoryList> {
            return localVarFp.listSupermarketCategorys(limit, page, pageSize, query, random, updatedAt, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSupermarkets(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any): AxiosPromise<PaginatedSupermarketList> {
            return localVarFp.listSupermarkets(limit, page, pageSize, query, random, updatedAt, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSyncLogs(page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedSyncLogList> {
            return localVarFp.listSyncLogs(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSyncs(page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedSyncList> {
            return localVarFp.listSyncs(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [foodId] ID of food to filter for
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUnitConversions(foodId?: number, page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedUnitConversionList> {
            return localVarFp.listUnitConversions(foodId, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUnits(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any): AxiosPromise<PaginatedUnitList> {
            return localVarFp.listUnits(limit, page, pageSize, query, random, updatedAt, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserFiles(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any): AxiosPromise<PaginatedUserFileList> {
            return localVarFp.listUserFiles(limit, page, pageSize, query, random, updatedAt, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserPreferences(options?: any): AxiosPromise<Array<UserPreference>> {
            return localVarFp.listUserPreferences(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [internalNote] I have no idea what this is
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserSpaces(internalNote?: string, page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedUserSpaceList> {
            return localVarFp.listUserSpaces(internalNote, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<string>} [filterList] User IDs, repeat for multiple
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(filterList?: Array<string>, options?: any): AxiosPromise<Array<User>> {
            return localVarFp.listUsers(filterList, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listViewLogs(page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedViewLogList> {
            return localVarFp.listViewLogs(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {number} target The ID of the {obj} you want to merge with.
         * @param {Food} food 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeFood(id: number, target: number, food: Food, options?: any): AxiosPromise<Food> {
            return localVarFp.mergeFood(id, target, food, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {number} target The ID of the {obj} you want to merge with.
         * @param {Keyword} keyword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeKeyword(id: number, target: number, keyword: Keyword, options?: any): AxiosPromise<Keyword> {
            return localVarFp.mergeKeyword(id, target, keyword, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category.
         * @param {number} target The ID of the {obj} you want to merge with.
         * @param {SupermarketCategory} supermarketCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeSupermarketCategory(id: number, target: number, supermarketCategory: SupermarketCategory, options?: any): AxiosPromise<SupermarketCategory> {
            return localVarFp.mergeSupermarketCategory(id, target, supermarketCategory, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit.
         * @param {number} target The ID of the {obj} you want to merge with.
         * @param {Unit} unit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeUnit(id: number, target: number, unit: Unit, options?: any): AxiosPromise<Unit> {
            return localVarFp.mergeUnit(id, target, unit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {number} parent The ID of the desired parent of the {obj}.
         * @param {Food} food 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveFood(id: number, parent: number, food: Food, options?: any): AxiosPromise<Food> {
            return localVarFp.moveFood(id, parent, food, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {number} parent The ID of the desired parent of the {obj}.
         * @param {Keyword} keyword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveKeyword(id: number, parent: number, keyword: Keyword, options?: any): AxiosPromise<Keyword> {
            return localVarFp.moveKeyword(id, parent, keyword, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this access token.
         * @param {PatchedAccessToken} [patchedAccessToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateAccessToken(id: number, patchedAccessToken?: PatchedAccessToken, options?: any): AxiosPromise<AccessToken> {
            return localVarFp.partialUpdateAccessToken(id, patchedAccessToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this automation.
         * @param {PatchedAutomation} [patchedAutomation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateAutomation(id: number, patchedAutomation?: PatchedAutomation, options?: any): AxiosPromise<Automation> {
            return localVarFp.partialUpdateAutomation(id, patchedAutomation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this bookmarklet import.
         * @param {PatchedBookmarkletImport} [patchedBookmarkletImport] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateBookmarkletImport(id: number, patchedBookmarkletImport?: PatchedBookmarkletImport, options?: any): AxiosPromise<BookmarkletImport> {
            return localVarFp.partialUpdateBookmarkletImport(id, patchedBookmarkletImport, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this connector config.
         * @param {PatchedConnectorConfigConfig} [patchedConnectorConfigConfig] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateConnectorConfig(id: number, patchedConnectorConfigConfig?: PatchedConnectorConfigConfig, options?: any): AxiosPromise<ConnectorConfigConfig> {
            return localVarFp.partialUpdateConnectorConfig(id, patchedConnectorConfigConfig, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cook log.
         * @param {PatchedCookLog} [patchedCookLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateCookLog(id: number, patchedCookLog?: PatchedCookLog, options?: any): AxiosPromise<CookLog> {
            return localVarFp.partialUpdateCookLog(id, patchedCookLog, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this custom filter.
         * @param {PatchedCustomFilter} [patchedCustomFilter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateCustomFilter(id: number, patchedCustomFilter?: PatchedCustomFilter, options?: any): AxiosPromise<CustomFilter> {
            return localVarFp.partialUpdateCustomFilter(id, patchedCustomFilter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this export log.
         * @param {PatchedExportLog} [patchedExportLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateExportLog(id: number, patchedExportLog?: PatchedExportLog, options?: any): AxiosPromise<ExportLog> {
            return localVarFp.partialUpdateExportLog(id, patchedExportLog, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {PatchedFood} [patchedFood] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateFood(id: number, patchedFood?: PatchedFood, options?: any): AxiosPromise<Food> {
            return localVarFp.partialUpdateFood(id, patchedFood, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this import log.
         * @param {PatchedImportLog} [patchedImportLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateImportLog(id: number, patchedImportLog?: PatchedImportLog, options?: any): AxiosPromise<ImportLog> {
            return localVarFp.partialUpdateImportLog(id, patchedImportLog, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ingredient.
         * @param {PatchedIngredient} [patchedIngredient] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateIngredient(id: number, patchedIngredient?: PatchedIngredient, options?: any): AxiosPromise<Ingredient> {
            return localVarFp.partialUpdateIngredient(id, patchedIngredient, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this invite link.
         * @param {PatchedInviteLink} [patchedInviteLink] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateInviteLink(id: number, patchedInviteLink?: PatchedInviteLink, options?: any): AxiosPromise<InviteLink> {
            return localVarFp.partialUpdateInviteLink(id, patchedInviteLink, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {PatchedKeyword} [patchedKeyword] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateKeyword(id: number, patchedKeyword?: PatchedKeyword, options?: any): AxiosPromise<Keyword> {
            return localVarFp.partialUpdateKeyword(id, patchedKeyword, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this meal plan.
         * @param {PatchedMealPlan} [patchedMealPlan] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateMealPlan(id: number, patchedMealPlan?: PatchedMealPlan, options?: any): AxiosPromise<MealPlan> {
            return localVarFp.partialUpdateMealPlan(id, patchedMealPlan, options).then((request) => request(axios, basePath));
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {number} id A unique integer value identifying this meal type.
         * @param {PatchedMealType} [patchedMealType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateMealType(id: number, patchedMealType?: PatchedMealType, options?: any): AxiosPromise<MealType> {
            return localVarFp.partialUpdateMealType(id, patchedMealType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property.
         * @param {PatchedProperty} [patchedProperty] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateProperty(id: number, patchedProperty?: PatchedProperty, options?: any): AxiosPromise<Property> {
            return localVarFp.partialUpdateProperty(id, patchedProperty, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property type.
         * @param {PatchedPropertyType} [patchedPropertyType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdatePropertyType(id: number, patchedPropertyType?: PatchedPropertyType, options?: any): AxiosPromise<PropertyType> {
            return localVarFp.partialUpdatePropertyType(id, patchedPropertyType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {PatchedRecipe} [patchedRecipe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateRecipe(id: number, patchedRecipe?: PatchedRecipe, options?: any): AxiosPromise<Recipe> {
            return localVarFp.partialUpdateRecipe(id, patchedRecipe, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book.
         * @param {PatchedRecipeBook} [patchedRecipeBook] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateRecipeBook(id: number, patchedRecipeBook?: PatchedRecipeBook, options?: any): AxiosPromise<RecipeBook> {
            return localVarFp.partialUpdateRecipeBook(id, patchedRecipeBook, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book entry.
         * @param {PatchedRecipeBookEntry} [patchedRecipeBookEntry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateRecipeBookEntry(id: number, patchedRecipeBookEntry?: PatchedRecipeBookEntry, options?: any): AxiosPromise<RecipeBookEntry> {
            return localVarFp.partialUpdateRecipeBookEntry(id, patchedRecipeBookEntry, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list entry.
         * @param {PatchedShoppingListEntry} [patchedShoppingListEntry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateShoppingListEntry(id: number, patchedShoppingListEntry?: PatchedShoppingListEntry, options?: any): AxiosPromise<ShoppingListEntry> {
            return localVarFp.partialUpdateShoppingListEntry(id, patchedShoppingListEntry, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list recipe.
         * @param {PatchedShoppingListRecipe} [patchedShoppingListRecipe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateShoppingListRecipe(id: number, patchedShoppingListRecipe?: PatchedShoppingListRecipe, options?: any): AxiosPromise<ShoppingListRecipe> {
            return localVarFp.partialUpdateShoppingListRecipe(id, patchedShoppingListRecipe, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this space.
         * @param {PatchedSpace} [patchedSpace] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateSpace(id: number, patchedSpace?: PatchedSpace, options?: any): AxiosPromise<Space> {
            return localVarFp.partialUpdateSpace(id, patchedSpace, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this step.
         * @param {PatchedStep} [patchedStep] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateStep(id: number, patchedStep?: PatchedStep, options?: any): AxiosPromise<Step> {
            return localVarFp.partialUpdateStep(id, patchedStep, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this storage.
         * @param {PatchedStorage} [patchedStorage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateStorage(id: number, patchedStorage?: PatchedStorage, options?: any): AxiosPromise<Storage> {
            return localVarFp.partialUpdateStorage(id, patchedStorage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket.
         * @param {PatchedSupermarket} [patchedSupermarket] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateSupermarket(id: number, patchedSupermarket?: PatchedSupermarket, options?: any): AxiosPromise<Supermarket> {
            return localVarFp.partialUpdateSupermarket(id, patchedSupermarket, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category.
         * @param {PatchedSupermarketCategory} [patchedSupermarketCategory] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateSupermarketCategory(id: number, patchedSupermarketCategory?: PatchedSupermarketCategory, options?: any): AxiosPromise<SupermarketCategory> {
            return localVarFp.partialUpdateSupermarketCategory(id, patchedSupermarketCategory, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category relation.
         * @param {PatchedSupermarketCategoryRelation} [patchedSupermarketCategoryRelation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateSupermarketCategoryRelation(id: number, patchedSupermarketCategoryRelation?: PatchedSupermarketCategoryRelation, options?: any): AxiosPromise<SupermarketCategoryRelation> {
            return localVarFp.partialUpdateSupermarketCategoryRelation(id, patchedSupermarketCategoryRelation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this sync.
         * @param {PatchedSync} [patchedSync] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateSync(id: number, patchedSync?: PatchedSync, options?: any): AxiosPromise<Sync> {
            return localVarFp.partialUpdateSync(id, patchedSync, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit.
         * @param {PatchedUnit} [patchedUnit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateUnit(id: number, patchedUnit?: PatchedUnit, options?: any): AxiosPromise<Unit> {
            return localVarFp.partialUpdateUnit(id, patchedUnit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit conversion.
         * @param {PatchedUnitConversion} [patchedUnitConversion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateUnitConversion(id: number, patchedUnitConversion?: PatchedUnitConversion, options?: any): AxiosPromise<UnitConversion> {
            return localVarFp.partialUpdateUnitConversion(id, patchedUnitConversion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {PatchedUser} [patchedUser] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateUser(id: number, patchedUser?: PatchedUser, options?: any): AxiosPromise<User> {
            return localVarFp.partialUpdateUser(id, patchedUser, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user file.
         * @param {number} [id2] 
         * @param {string} [name] 
         * @param {string} [file] 
         * @param {string} [fileDownload] 
         * @param {string} [preview] 
         * @param {number} [fileSizeKb] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateUserFile(id: number, id2?: number, name?: string, file?: string, fileDownload?: string, preview?: string, fileSizeKb?: number, options?: any): AxiosPromise<UserFile> {
            return localVarFp.partialUpdateUserFile(id, id2, name, file, fileDownload, preview, fileSizeKb, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} user A unique value identifying this user preference.
         * @param {PatchedUserPreference} [patchedUserPreference] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateUserPreference(user: number, patchedUserPreference?: PatchedUserPreference, options?: any): AxiosPromise<UserPreference> {
            return localVarFp.partialUpdateUserPreference(user, patchedUserPreference, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user space.
         * @param {PatchedUserSpace} [patchedUserSpace] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateUserSpace(id: number, patchedUserSpace?: PatchedUserSpace, options?: any): AxiosPromise<UserSpace> {
            return localVarFp.partialUpdateUserSpace(id, patchedUserSpace, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this view log.
         * @param {PatchedViewLog} [patchedViewLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateViewLog(id: number, patchedViewLog?: PatchedViewLog, options?: any): AxiosPromise<ViewLog> {
            return localVarFp.partialUpdateViewLog(id, patchedViewLog, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        relatedRecipe(id: number, options?: any): AxiosPromise<RecipeSimple> {
            return localVarFp.relatedRecipe(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this access token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAccessToken(id: number, options?: any): AxiosPromise<AccessToken> {
            return localVarFp.retrieveAccessToken(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this automation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAutomation(id: number, options?: any): AxiosPromise<Automation> {
            return localVarFp.retrieveAutomation(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this bookmarklet import.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveBookmarkletImport(id: number, options?: any): AxiosPromise<BookmarkletImport> {
            return localVarFp.retrieveBookmarkletImport(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this connector config.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveConnectorConfig(id: number, options?: any): AxiosPromise<ConnectorConfigConfig> {
            return localVarFp.retrieveConnectorConfig(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cook log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveCookLog(id: number, options?: any): AxiosPromise<CookLog> {
            return localVarFp.retrieveCookLog(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this custom filter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveCustomFilter(id: number, options?: any): AxiosPromise<CustomFilter> {
            return localVarFp.retrieveCustomFilter(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this export log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveExportLog(id: number, options?: any): AxiosPromise<ExportLog> {
            return localVarFp.retrieveExportLog(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveFood(id: number, options?: any): AxiosPromise<Food> {
            return localVarFp.retrieveFood(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food inherit field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveFoodInheritField(id: number, options?: any): AxiosPromise<FoodInheritField> {
            return localVarFp.retrieveFoodInheritField(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveGroup(id: number, options?: any): AxiosPromise<Group> {
            return localVarFp.retrieveGroup(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this import log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveImportLog(id: number, options?: any): AxiosPromise<ImportLog> {
            return localVarFp.retrieveImportLog(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ingredient.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveIngredient(id: number, options?: any): AxiosPromise<Ingredient> {
            return localVarFp.retrieveIngredient(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this invite link.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveInviteLink(id: number, options?: any): AxiosPromise<InviteLink> {
            return localVarFp.retrieveInviteLink(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveKeyword(id: number, options?: any): AxiosPromise<Keyword> {
            return localVarFp.retrieveKeyword(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this meal plan.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveMealPlan(id: number, options?: any): AxiosPromise<MealPlan> {
            return localVarFp.retrieveMealPlan(id, options).then((request) => request(axios, basePath));
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {number} id A unique integer value identifying this meal type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveMealType(id: number, options?: any): AxiosPromise<MealType> {
            return localVarFp.retrieveMealType(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveProperty(id: number, options?: any): AxiosPromise<Property> {
            return localVarFp.retrieveProperty(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrievePropertyType(id: number, options?: any): AxiosPromise<PropertyType> {
            return localVarFp.retrievePropertyType(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRecipe(id: number, options?: any): AxiosPromise<Recipe> {
            return localVarFp.retrieveRecipe(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRecipeBook(id: number, options?: any): AxiosPromise<RecipeBook> {
            return localVarFp.retrieveRecipeBook(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRecipeBookEntry(id: number, options?: any): AxiosPromise<RecipeBookEntry> {
            return localVarFp.retrieveRecipeBookEntry(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveShoppingListEntry(id: number, options?: any): AxiosPromise<ShoppingListEntry> {
            return localVarFp.retrieveShoppingListEntry(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveShoppingListRecipe(id: number, options?: any): AxiosPromise<ShoppingListRecipe> {
            return localVarFp.retrieveShoppingListRecipe(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this space.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSpace(id: number, options?: any): AxiosPromise<Space> {
            return localVarFp.retrieveSpace(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this step.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveStep(id: number, options?: any): AxiosPromise<Step> {
            return localVarFp.retrieveStep(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this storage.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveStorage(id: number, options?: any): AxiosPromise<Storage> {
            return localVarFp.retrieveStorage(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSupermarket(id: number, options?: any): AxiosPromise<Supermarket> {
            return localVarFp.retrieveSupermarket(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSupermarketCategory(id: number, options?: any): AxiosPromise<SupermarketCategory> {
            return localVarFp.retrieveSupermarketCategory(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category relation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSupermarketCategoryRelation(id: number, options?: any): AxiosPromise<SupermarketCategoryRelation> {
            return localVarFp.retrieveSupermarketCategoryRelation(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this sync.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSync(id: number, options?: any): AxiosPromise<Sync> {
            return localVarFp.retrieveSync(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this sync log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSyncLog(id: number, options?: any): AxiosPromise<SyncLog> {
            return localVarFp.retrieveSyncLog(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUnit(id: number, options?: any): AxiosPromise<Unit> {
            return localVarFp.retrieveUnit(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit conversion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUnitConversion(id: number, options?: any): AxiosPromise<UnitConversion> {
            return localVarFp.retrieveUnitConversion(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUser(id: number, options?: any): AxiosPromise<User> {
            return localVarFp.retrieveUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUserFile(id: number, options?: any): AxiosPromise<UserFile> {
            return localVarFp.retrieveUserFile(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} user A unique value identifying this user preference.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUserPreference(user: number, options?: any): AxiosPromise<UserPreference> {
            return localVarFp.retrieveUserPreference(user, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user space.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUserSpace(id: number, options?: any): AxiosPromise<UserSpace> {
            return localVarFp.retrieveUserSpace(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this view log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveViewLog(id: number, options?: any): AxiosPromise<ViewLog> {
            return localVarFp.retrieveViewLog(id, options).then((request) => request(axios, basePath));
        },
        /**
         * function to download a user file securely (wrapping as zip to prevent any context based XSS problems) temporary solution until a real file manager is implemented
         * @param {number} fileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrievedownloadFile(fileId: number, options?: any): AxiosPromise<void> {
            return localVarFp.retrievedownloadFile(fileId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} recipeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrievegetExternalFileLink(recipeId: number, options?: any): AxiosPromise<void> {
            return localVarFp.retrievegetExternalFileLink(recipeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} recipeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrievegetRecipeFile(recipeId: number, options?: any): AxiosPromise<void> {
            return localVarFp.retrievegetRecipeFile(recipeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveshareLink(id: number, options?: any): AxiosPromise<ShareLink> {
            return localVarFp.retrieveshareLink(id, options).then((request) => request(axios, basePath));
        },
        /**
         * api endpoint to switch space function
         * @param {number} spaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveswitchActiveSpace(spaceId: number, options?: any): AxiosPromise<void> {
            return localVarFp.retrieveswitchActiveSpace(spaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {FoodShoppingUpdate} foodShoppingUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shoppingFood(id: number, foodShoppingUpdate: FoodShoppingUpdate, options?: any): AxiosPromise<FoodShoppingUpdate> {
            return localVarFp.shoppingFood(id, foodShoppingUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {RecipeShoppingUpdate} [recipeShoppingUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shoppingRecipe(id: number, recipeShoppingUpdate?: RecipeShoppingUpdate, options?: any): AxiosPromise<RecipeShoppingUpdate> {
            return localVarFp.shoppingRecipe(id, recipeShoppingUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this access token.
         * @param {AccessToken} accessToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccessToken(id: number, accessToken: AccessToken, options?: any): AxiosPromise<AccessToken> {
            return localVarFp.updateAccessToken(id, accessToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this automation.
         * @param {Automation} automation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAutomation(id: number, automation: Automation, options?: any): AxiosPromise<Automation> {
            return localVarFp.updateAutomation(id, automation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this bookmarklet import.
         * @param {BookmarkletImport} bookmarkletImport 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBookmarkletImport(id: number, bookmarkletImport: BookmarkletImport, options?: any): AxiosPromise<BookmarkletImport> {
            return localVarFp.updateBookmarkletImport(id, bookmarkletImport, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this connector config.
         * @param {ConnectorConfigConfig} connectorConfigConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConnectorConfig(id: number, connectorConfigConfig: ConnectorConfigConfig, options?: any): AxiosPromise<ConnectorConfigConfig> {
            return localVarFp.updateConnectorConfig(id, connectorConfigConfig, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cook log.
         * @param {CookLog} cookLog 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCookLog(id: number, cookLog: CookLog, options?: any): AxiosPromise<CookLog> {
            return localVarFp.updateCookLog(id, cookLog, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this custom filter.
         * @param {CustomFilter} customFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomFilter(id: number, customFilter: CustomFilter, options?: any): AxiosPromise<CustomFilter> {
            return localVarFp.updateCustomFilter(id, customFilter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this export log.
         * @param {ExportLog} exportLog 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExportLog(id: number, exportLog: ExportLog, options?: any): AxiosPromise<ExportLog> {
            return localVarFp.updateExportLog(id, exportLog, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {Food} food 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFood(id: number, food: Food, options?: any): AxiosPromise<Food> {
            return localVarFp.updateFood(id, food, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this import log.
         * @param {ImportLog} importLog 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateImportLog(id: number, importLog: ImportLog, options?: any): AxiosPromise<ImportLog> {
            return localVarFp.updateImportLog(id, importLog, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ingredient.
         * @param {Ingredient} ingredient 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIngredient(id: number, ingredient: Ingredient, options?: any): AxiosPromise<Ingredient> {
            return localVarFp.updateIngredient(id, ingredient, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this invite link.
         * @param {InviteLink} inviteLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInviteLink(id: number, inviteLink: InviteLink, options?: any): AxiosPromise<InviteLink> {
            return localVarFp.updateInviteLink(id, inviteLink, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {Keyword} keyword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKeyword(id: number, keyword: Keyword, options?: any): AxiosPromise<Keyword> {
            return localVarFp.updateKeyword(id, keyword, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this meal plan.
         * @param {MealPlan} mealPlan 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMealPlan(id: number, mealPlan: MealPlan, options?: any): AxiosPromise<MealPlan> {
            return localVarFp.updateMealPlan(id, mealPlan, options).then((request) => request(axios, basePath));
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {number} id A unique integer value identifying this meal type.
         * @param {MealType} mealType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMealType(id: number, mealType: MealType, options?: any): AxiosPromise<MealType> {
            return localVarFp.updateMealType(id, mealType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property.
         * @param {Property} property 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProperty(id: number, property: Property, options?: any): AxiosPromise<Property> {
            return localVarFp.updateProperty(id, property, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property type.
         * @param {PropertyType} propertyType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePropertyType(id: number, propertyType: PropertyType, options?: any): AxiosPromise<PropertyType> {
            return localVarFp.updatePropertyType(id, propertyType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {Recipe} recipe 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecipe(id: number, recipe: Recipe, options?: any): AxiosPromise<Recipe> {
            return localVarFp.updateRecipe(id, recipe, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book.
         * @param {RecipeBook} recipeBook 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecipeBook(id: number, recipeBook: RecipeBook, options?: any): AxiosPromise<RecipeBook> {
            return localVarFp.updateRecipeBook(id, recipeBook, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book entry.
         * @param {RecipeBookEntry} recipeBookEntry 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecipeBookEntry(id: number, recipeBookEntry: RecipeBookEntry, options?: any): AxiosPromise<RecipeBookEntry> {
            return localVarFp.updateRecipeBookEntry(id, recipeBookEntry, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list entry.
         * @param {ShoppingListEntry} shoppingListEntry 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShoppingListEntry(id: number, shoppingListEntry: ShoppingListEntry, options?: any): AxiosPromise<ShoppingListEntry> {
            return localVarFp.updateShoppingListEntry(id, shoppingListEntry, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list recipe.
         * @param {ShoppingListRecipe} shoppingListRecipe 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShoppingListRecipe(id: number, shoppingListRecipe: ShoppingListRecipe, options?: any): AxiosPromise<ShoppingListRecipe> {
            return localVarFp.updateShoppingListRecipe(id, shoppingListRecipe, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this step.
         * @param {Step} step 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStep(id: number, step: Step, options?: any): AxiosPromise<Step> {
            return localVarFp.updateStep(id, step, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this storage.
         * @param {Storage} storage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStorage(id: number, storage: Storage, options?: any): AxiosPromise<Storage> {
            return localVarFp.updateStorage(id, storage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket.
         * @param {Supermarket} supermarket 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSupermarket(id: number, supermarket: Supermarket, options?: any): AxiosPromise<Supermarket> {
            return localVarFp.updateSupermarket(id, supermarket, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category.
         * @param {SupermarketCategory} supermarketCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSupermarketCategory(id: number, supermarketCategory: SupermarketCategory, options?: any): AxiosPromise<SupermarketCategory> {
            return localVarFp.updateSupermarketCategory(id, supermarketCategory, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category relation.
         * @param {SupermarketCategoryRelation} supermarketCategoryRelation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSupermarketCategoryRelation(id: number, supermarketCategoryRelation: SupermarketCategoryRelation, options?: any): AxiosPromise<SupermarketCategoryRelation> {
            return localVarFp.updateSupermarketCategoryRelation(id, supermarketCategoryRelation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this sync.
         * @param {Sync} sync 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSync(id: number, sync: Sync, options?: any): AxiosPromise<Sync> {
            return localVarFp.updateSync(id, sync, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit.
         * @param {Unit} unit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUnit(id: number, unit: Unit, options?: any): AxiosPromise<Unit> {
            return localVarFp.updateUnit(id, unit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit conversion.
         * @param {UnitConversion} unitConversion 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUnitConversion(id: number, unitConversion: UnitConversion, options?: any): AxiosPromise<UnitConversion> {
            return localVarFp.updateUnitConversion(id, unitConversion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user file.
         * @param {string} name 
         * @param {string} file 
         * @param {string} fileDownload 
         * @param {string} preview 
         * @param {number} fileSizeKb 
         * @param {number} [id2] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserFile(id: number, name: string, file: string, fileDownload: string, preview: string, fileSizeKb: number, id2?: number, options?: any): AxiosPromise<UserFile> {
            return localVarFp.updateUserFile(id, name, file, fileDownload, preview, fileSizeKb, id2, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this view log.
         * @param {ViewLog} viewLog 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateViewLog(id: number, viewLog: ViewLog, options?: any): AxiosPromise<ViewLog> {
            return localVarFp.updateViewLog(id, viewLog, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApiApi - object-oriented interface
 * @export
 * @class ApiApi
 * @extends {BaseAPI}
 */
export class ApiApi extends BaseAPI {
    /**
     * 
     * @param {ShoppingListEntryBulk} shoppingListEntryBulk 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public bulkShoppingListEntry(shoppingListEntryBulk: ShoppingListEntryBulk, options?: any) {
        return ApiApiFp(this.configuration).bulkShoppingListEntry(shoppingListEntryBulk, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AccessToken} accessToken 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createAccessToken(accessToken: AccessToken, options?: any) {
        return ApiApiFp(this.configuration).createAccessToken(accessToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AutoMealPlan} autoMealPlan 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createAutoMealPlan(autoMealPlan: AutoMealPlan, options?: any) {
        return ApiApiFp(this.configuration).createAutoMealPlan(autoMealPlan, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Automation} automation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createAutomation(automation: Automation, options?: any) {
        return ApiApiFp(this.configuration).createAutomation(automation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {BookmarkletImport} bookmarkletImport 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createBookmarkletImport(bookmarkletImport: BookmarkletImport, options?: any) {
        return ApiApiFp(this.configuration).createBookmarkletImport(bookmarkletImport, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ConnectorConfigConfig} connectorConfigConfig 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createConnectorConfig(connectorConfigConfig: ConnectorConfigConfig, options?: any) {
        return ApiApiFp(this.configuration).createConnectorConfig(connectorConfigConfig, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CookLog} cookLog 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createCookLog(cookLog: CookLog, options?: any) {
        return ApiApiFp(this.configuration).createCookLog(cookLog, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CustomFilter} customFilter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createCustomFilter(customFilter: CustomFilter, options?: any) {
        return ApiApiFp(this.configuration).createCustomFilter(customFilter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ExportLog} exportLog 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createExportLog(exportLog: ExportLog, options?: any) {
        return ApiApiFp(this.configuration).createExportLog(exportLog, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Food} food 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createFood(food: Food, options?: any) {
        return ApiApiFp(this.configuration).createFood(food, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ImportLog} importLog 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createImportLog(importLog: ImportLog, options?: any) {
        return ApiApiFp(this.configuration).createImportLog(importLog, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Ingredient} ingredient 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createIngredient(ingredient: Ingredient, options?: any) {
        return ApiApiFp(this.configuration).createIngredient(ingredient, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {InviteLink} inviteLink 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createInviteLink(inviteLink: InviteLink, options?: any) {
        return ApiApiFp(this.configuration).createInviteLink(inviteLink, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Keyword} keyword 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createKeyword(keyword: Keyword, options?: any) {
        return ApiApiFp(this.configuration).createKeyword(keyword, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {MealPlan} mealPlan 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createMealPlan(mealPlan: MealPlan, options?: any) {
        return ApiApiFp(this.configuration).createMealPlan(mealPlan, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * returns list of meal types created by the requesting user ordered by the order field.
     * @param {MealType} mealType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createMealType(mealType: MealType, options?: any) {
        return ApiApiFp(this.configuration).createMealType(mealType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Property} property 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createProperty(property: Property, options?: any) {
        return ApiApiFp(this.configuration).createProperty(property, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PropertyType} propertyType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createPropertyType(propertyType: PropertyType, options?: any) {
        return ApiApiFp(this.configuration).createPropertyType(propertyType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Recipe} recipe 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createRecipe(recipe: Recipe, options?: any) {
        return ApiApiFp(this.configuration).createRecipe(recipe, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RecipeBook} recipeBook 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createRecipeBook(recipeBook: RecipeBook, options?: any) {
        return ApiApiFp(this.configuration).createRecipeBook(recipeBook, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RecipeBookEntry} recipeBookEntry 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createRecipeBookEntry(recipeBookEntry: RecipeBookEntry, options?: any) {
        return ApiApiFp(this.configuration).createRecipeBookEntry(recipeBookEntry, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * function to retrieve a recipe from a given url or source string :param request: standard request with additional post parameters         - url: url to use for importing recipe         - data: if no url is given recipe is imported from provided source data         - (optional) bookmarklet: id of bookmarklet import to use, overrides URL and data attributes :return: JsonResponse containing the parsed json and images
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createRecipeUrlImport(options?: any) {
        return ApiApiFp(this.configuration).createRecipeUrlImport(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ShoppingListEntry} shoppingListEntry 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createShoppingListEntry(shoppingListEntry: ShoppingListEntry, options?: any) {
        return ApiApiFp(this.configuration).createShoppingListEntry(shoppingListEntry, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ShoppingListRecipe} shoppingListRecipe 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createShoppingListRecipe(shoppingListRecipe: ShoppingListRecipe, options?: any) {
        return ApiApiFp(this.configuration).createShoppingListRecipe(shoppingListRecipe, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Step} step 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createStep(step: Step, options?: any) {
        return ApiApiFp(this.configuration).createStep(step, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Storage} storage 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createStorage(storage: Storage, options?: any) {
        return ApiApiFp(this.configuration).createStorage(storage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Supermarket} supermarket 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createSupermarket(supermarket: Supermarket, options?: any) {
        return ApiApiFp(this.configuration).createSupermarket(supermarket, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SupermarketCategory} supermarketCategory 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createSupermarketCategory(supermarketCategory: SupermarketCategory, options?: any) {
        return ApiApiFp(this.configuration).createSupermarketCategory(supermarketCategory, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SupermarketCategoryRelation} supermarketCategoryRelation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createSupermarketCategoryRelation(supermarketCategoryRelation: SupermarketCategoryRelation, options?: any) {
        return ApiApiFp(this.configuration).createSupermarketCategoryRelation(supermarketCategoryRelation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Sync} sync 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createSync(sync: Sync, options?: any) {
        return ApiApiFp(this.configuration).createSync(sync, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Unit} unit 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createUnit(unit: Unit, options?: any) {
        return ApiApiFp(this.configuration).createUnit(unit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UnitConversion} unitConversion 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createUnitConversion(unitConversion: UnitConversion, options?: any) {
        return ApiApiFp(this.configuration).createUnitConversion(unitConversion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} name 
     * @param {string} file 
     * @param {string} fileDownload 
     * @param {string} preview 
     * @param {number} fileSizeKb 
     * @param {number} [id] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createUserFile(name: string, file: string, fileDownload: string, preview: string, fileSizeKb: number, id?: number, options?: any) {
        return ApiApiFp(this.configuration).createUserFile(name, file, fileDownload, preview, fileSizeKb, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ViewLog} viewLog 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createViewLog(viewLog: ViewLog, options?: any) {
        return ApiApiFp(this.configuration).createViewLog(viewLog, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * function to handle files passed by application importer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createimportFiles(options?: any) {
        return ApiApiFp(this.configuration).createimportFiles(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IngredientString} ingredientString 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createingredientFromString(ingredientString: IngredientString, options?: any) {
        return ApiApiFp(this.configuration).createingredientFromString(ingredientString, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * function to reset inheritance from api, see food method for docs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createresetFoodInheritance(options?: any) {
        return ApiApiFp(this.configuration).createresetFoodInheritance(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this access token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyAccessToken(id: number, options?: any) {
        return ApiApiFp(this.configuration).destroyAccessToken(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this automation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyAutomation(id: number, options?: any) {
        return ApiApiFp(this.configuration).destroyAutomation(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this bookmarklet import.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyBookmarkletImport(id: number, options?: any) {
        return ApiApiFp(this.configuration).destroyBookmarkletImport(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this connector config.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyConnectorConfig(id: number, options?: any) {
        return ApiApiFp(this.configuration).destroyConnectorConfig(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this cook log.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyCookLog(id: number, options?: any) {
        return ApiApiFp(this.configuration).destroyCookLog(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this custom filter.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyCustomFilter(id: number, options?: any) {
        return ApiApiFp(this.configuration).destroyCustomFilter(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this export log.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyExportLog(id: number, options?: any) {
        return ApiApiFp(this.configuration).destroyExportLog(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this food.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyFood(id: number, options?: any) {
        return ApiApiFp(this.configuration).destroyFood(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this import log.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyImportLog(id: number, options?: any) {
        return ApiApiFp(this.configuration).destroyImportLog(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this ingredient.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyIngredient(id: number, options?: any) {
        return ApiApiFp(this.configuration).destroyIngredient(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this invite link.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyInviteLink(id: number, options?: any) {
        return ApiApiFp(this.configuration).destroyInviteLink(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this keyword.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyKeyword(id: number, options?: any) {
        return ApiApiFp(this.configuration).destroyKeyword(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this meal plan.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyMealPlan(id: number, options?: any) {
        return ApiApiFp(this.configuration).destroyMealPlan(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * returns list of meal types created by the requesting user ordered by the order field.
     * @param {number} id A unique integer value identifying this meal type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyMealType(id: number, options?: any) {
        return ApiApiFp(this.configuration).destroyMealType(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this property.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyProperty(id: number, options?: any) {
        return ApiApiFp(this.configuration).destroyProperty(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this property type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyPropertyType(id: number, options?: any) {
        return ApiApiFp(this.configuration).destroyPropertyType(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this recipe.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyRecipe(id: number, options?: any) {
        return ApiApiFp(this.configuration).destroyRecipe(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this recipe book.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyRecipeBook(id: number, options?: any) {
        return ApiApiFp(this.configuration).destroyRecipeBook(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this recipe book entry.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyRecipeBookEntry(id: number, options?: any) {
        return ApiApiFp(this.configuration).destroyRecipeBookEntry(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this shopping list entry.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyShoppingListEntry(id: number, options?: any) {
        return ApiApiFp(this.configuration).destroyShoppingListEntry(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this shopping list recipe.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyShoppingListRecipe(id: number, options?: any) {
        return ApiApiFp(this.configuration).destroyShoppingListRecipe(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this step.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyStep(id: number, options?: any) {
        return ApiApiFp(this.configuration).destroyStep(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this storage.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyStorage(id: number, options?: any) {
        return ApiApiFp(this.configuration).destroyStorage(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this supermarket.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroySupermarket(id: number, options?: any) {
        return ApiApiFp(this.configuration).destroySupermarket(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this supermarket category.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroySupermarketCategory(id: number, options?: any) {
        return ApiApiFp(this.configuration).destroySupermarketCategory(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this supermarket category relation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroySupermarketCategoryRelation(id: number, options?: any) {
        return ApiApiFp(this.configuration).destroySupermarketCategoryRelation(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this sync.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroySync(id: number, options?: any) {
        return ApiApiFp(this.configuration).destroySync(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this unit.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyUnit(id: number, options?: any) {
        return ApiApiFp(this.configuration).destroyUnit(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this unit conversion.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyUnitConversion(id: number, options?: any) {
        return ApiApiFp(this.configuration).destroyUnitConversion(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyUserFile(id: number, options?: any) {
        return ApiApiFp(this.configuration).destroyUserFile(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user space.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyUserSpace(id: number, options?: any) {
        return ApiApiFp(this.configuration).destroyUserSpace(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this view log.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyViewLog(id: number, options?: any) {
        return ApiApiFp(this.configuration).destroyViewLog(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * updates the food with all possible data from the FDC Api if properties with a fdc_id already exist they will be overridden, if existing properties don\'t have a fdc_id they won\'t be changed
     * @param {number} id A unique integer value identifying this food.
     * @param {Food} food 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public fdcFood(id: number, food: Food, options?: any) {
        return ApiApiFp(this.configuration).fdcFood(id, food, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [fromDate] Filter meal plans from date (inclusive).
     * @param {Array<string>} [mealType] Filter meal plans with MealType ID. For multiple repeat parameter.
     * @param {string} [toDate] Filter meal plans to date (inclusive).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public icalMealPlan(fromDate?: string, mealType?: Array<string>, toDate?: string, options?: any) {
        return ApiApiFp(this.configuration).icalMealPlan(fromDate, mealType, toDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this recipe.
     * @param {string} [image] 
     * @param {string} [imageUrl] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public imageRecipe(id: number, image?: string, imageUrl?: string, options?: any) {
        return ApiApiFp(this.configuration).imageRecipe(id, image, imageUrl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listAccessTokens(options?: any) {
        return ApiApiFp(this.configuration).listAccessTokens(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {Array<'DESCRIPTION_REPLACE' | 'FOOD_ALIAS' | 'FOOD_REPLACE' | 'INSTRUCTION_REPLACE' | 'KEYWORD_ALIAS' | 'NAME_REPLACE' | 'NEVER_UNIT' | 'TRANSPOSE_WORDS' | 'UNIT_ALIAS' | 'UNIT_REPLACE'>} [type] Return the Automations matching the automation type.  Repeat for multiple.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listAutomations(page?: number, pageSize?: number, type?: Array<'DESCRIPTION_REPLACE' | 'FOOD_ALIAS' | 'FOOD_REPLACE' | 'INSTRUCTION_REPLACE' | 'KEYWORD_ALIAS' | 'NAME_REPLACE' | 'NEVER_UNIT' | 'TRANSPOSE_WORDS' | 'UNIT_ALIAS' | 'UNIT_REPLACE'>, options?: any) {
        return ApiApiFp(this.configuration).listAutomations(page, pageSize, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listBookmarkletImports(page?: number, pageSize?: number, options?: any) {
        return ApiApiFp(this.configuration).listBookmarkletImports(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listConnectorConfigs(options?: any) {
        return ApiApiFp(this.configuration).listConnectorConfigs(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {number} [recipe] Filter for entries with the given recipe
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listCookLogs(page?: number, pageSize?: number, recipe?: number, options?: any) {
        return ApiApiFp(this.configuration).listCookLogs(page, pageSize, recipe, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [limit] limit number of entries to return
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [query] lookup if query string is contained within the name, case insensitive
     * @param {string} [random] randomly orders entries (only works together with limit)
     * @param {Array<'FOOD' | 'KEYWORD' | 'RECIPE'>} [type] Return the CustomFilters matching the model type.  Repeat for multiple.
     * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listCustomFilters(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, type?: Array<'FOOD' | 'KEYWORD' | 'RECIPE'>, updatedAt?: string, options?: any) {
        return ApiApiFp(this.configuration).listCustomFilters(limit, page, pageSize, query, random, type, updatedAt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listExportLogs(page?: number, pageSize?: number, options?: any) {
        return ApiApiFp(this.configuration).listExportLogs(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listFoodInheritFields(options?: any) {
        return ApiApiFp(this.configuration).listFoodInheritFields(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [limit] limit number of entries to return
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [query] lookup if query string is contained within the name, case insensitive
     * @param {string} [random] randomly orders entries (only works together with limit)
     * @param {number} [root] Return first level children of {obj} with ID [int].  Integer 0 will return root {obj}s.
     * @param {number} [tree] Return all self and children of {obj} with ID [int].
     * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listFoods(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, root?: number, tree?: number, updatedAt?: string, options?: any) {
        return ApiApiFp(this.configuration).listFoods(limit, page, pageSize, query, random, root, tree, updatedAt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listGroups(options?: any) {
        return ApiApiFp(this.configuration).listGroups(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listImportLogs(page?: number, pageSize?: number, options?: any) {
        return ApiApiFp(this.configuration).listImportLogs(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [food] ID of food to filter for
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {number} [unit] ID of unit to filter for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listIngredients(food?: number, page?: number, pageSize?: number, unit?: number, options?: any) {
        return ApiApiFp(this.configuration).listIngredients(food, page, pageSize, unit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [internalNote] I have no idea what internal_note is for.
     * @param {string} [limit] limit number of entries to return
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [query] lookup if query string is contained within the name, case insensitive
     * @param {string} [random] randomly orders entries (only works together with limit)
     * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listInviteLinks(internalNote?: string, limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any) {
        return ApiApiFp(this.configuration).listInviteLinks(internalNote, limit, page, pageSize, query, random, updatedAt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [limit] limit number of entries to return
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [query] lookup if query string is contained within the name, case insensitive
     * @param {string} [random] randomly orders entries (only works together with limit)
     * @param {number} [root] Return first level children of {obj} with ID [int].  Integer 0 will return root {obj}s.
     * @param {number} [tree] Return all self and children of {obj} with ID [int].
     * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listKeywords(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, root?: number, tree?: number, updatedAt?: string, options?: any) {
        return ApiApiFp(this.configuration).listKeywords(limit, page, pageSize, query, random, root, tree, updatedAt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [fromDate] Filter meal plans from date (inclusive).
     * @param {Array<string>} [mealType] Filter meal plans with MealType ID. For multiple repeat parameter.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [toDate] Filter meal plans to date (inclusive).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listMealPlans(fromDate?: string, mealType?: Array<string>, page?: number, pageSize?: number, toDate?: string, options?: any) {
        return ApiApiFp(this.configuration).listMealPlans(fromDate, mealType, page, pageSize, toDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * returns list of meal types created by the requesting user ordered by the order field.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listMealTypes(page?: number, pageSize?: number, options?: any) {
        return ApiApiFp(this.configuration).listMealTypes(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<'ALLERGEN' | 'GOAL' | 'NUTRITION' | 'OTHER' | 'PRICE'>} [category] Return the PropertyTypes matching the property category.  Repeat for multiple.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listPropertyTypes(category?: Array<'ALLERGEN' | 'GOAL' | 'NUTRITION' | 'OTHER' | 'PRICE'>, page?: number, pageSize?: number, options?: any) {
        return ApiApiFp(this.configuration).listPropertyTypes(category, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listPropertys(page?: number, pageSize?: number, options?: any) {
        return ApiApiFp(this.configuration).listPropertys(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [book] id of book - only return recipes in that book
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {number} [recipe] id of recipe - only return books for that recipe
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listRecipeBookEntrys(book?: number, page?: number, pageSize?: number, recipe?: number, options?: any) {
        return ApiApiFp(this.configuration).listRecipeBookEntrys(book, page, pageSize, recipe, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [limit] limit number of entries to return
     * @param {'asc' | 'desc'} [orderDirection] Order ascending or descending
     * @param {'id' | 'name' | 'order'} [orderField] Field to order recipe books on
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [query] lookup if query string is contained within the name, case insensitive
     * @param {string} [random] randomly orders entries (only works together with limit)
     * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listRecipeBooks(limit?: string, orderDirection?: 'asc' | 'desc', orderField?: 'id' | 'name' | 'order', page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any) {
        return ApiApiFp(this.configuration).listRecipeBooks(limit, orderDirection, orderField, page, pageSize, query, random, updatedAt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<number>} [books] ID of book a recipe should be in. For multiple repeat parameter.
     * @param {Array<number>} [booksAnd] Book IDs, repeat for multiple. Return recipes with all of the books.
     * @param {Array<number>} [booksAndNot] Book IDs, repeat for multiple. Exclude recipes with all of the books.
     * @param {Array<number>} [booksOr] Book IDs, repeat for multiple. Return recipes with any of the books
     * @param {Array<number>} [booksOrNot] Book IDs, repeat for multiple. Exclude recipes with any of the books.
     * @param {string} [cookedon] Filter recipes last cooked on or after YYYY-MM-DD. Prepending - filters on or before date.
     * @param {string} [createdon] Filter recipes created on or after YYYY-MM-DD. Prepending - filters on or before date.
     * @param {Array<number>} [foods] ID of food a recipe should have. For multiple repeat parameter.
     * @param {Array<number>} [foodsAnd] Food IDs, repeat for multiple. Return recipes with all of the foods.
     * @param {Array<number>} [foodsAndNot] Food IDs, repeat for multiple. Exclude recipes with all of the foods.
     * @param {Array<number>} [foodsOr] Food IDs, repeat for multiple. Return recipes with any of the foods
     * @param {Array<number>} [foodsOrNot] Food IDs, repeat for multiple. Exclude recipes with any of the foods.
     * @param {boolean} [internal] If only internal recipes should be returned. [true/&lt;b&gt;false&lt;/b&gt;]
     * @param {Array<number>} [keywords] ID of keyword a recipe should have. For multiple repeat parameter. Equivalent to keywords_or
     * @param {Array<number>} [keywordsAnd] Keyword IDs, repeat for multiple. Return recipes with all of the keywords.
     * @param {Array<number>} [keywordsAndNot] Keyword IDs, repeat for multiple. Exclude recipes with all of the keywords.
     * @param {Array<number>} [keywordsOr] Keyword IDs, repeat for multiple. Return recipes with any of the keywords
     * @param {Array<number>} [keywordsOrNot] Keyword IDs, repeat for multiple. Exclude recipes with any of the keywords.
     * @param {boolean} [makenow] Filter recipes that can be made with OnHand food. [true/&lt;b&gt;false&lt;/b&gt;]
     * @param {string} [_new] Returns new results first in search results. [true/&lt;b&gt;false&lt;/b&gt;]
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [query] Query string matched (fuzzy) against recipe name. In the future also fulltext search.
     * @param {string} [random] Returns the results in randomized order. [true/&lt;b&gt;false&lt;/b&gt;]
     * @param {number} [rating] Rating a recipe should have or greater. [0 - 5] Negative value filters rating less than.
     * @param {number} [timescooked] Filter recipes cooked X times or more.  Negative values returns cooked less than X times
     * @param {number} [units] ID of unit a recipe should have.
     * @param {string} [updatedon] Filter recipes updated on or after YYYY-MM-DD. Prepending - filters on or before date.
     * @param {string} [viewedon] Filter recipes lasts viewed on or after YYYY-MM-DD. Prepending - filters on or before date.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listRecipes(books?: Array<number>, booksAnd?: Array<number>, booksAndNot?: Array<number>, booksOr?: Array<number>, booksOrNot?: Array<number>, cookedon?: string, createdon?: string, foods?: Array<number>, foodsAnd?: Array<number>, foodsAndNot?: Array<number>, foodsOr?: Array<number>, foodsOrNot?: Array<number>, internal?: boolean, keywords?: Array<number>, keywordsAnd?: Array<number>, keywordsAndNot?: Array<number>, keywordsOr?: Array<number>, keywordsOrNot?: Array<number>, makenow?: boolean, _new?: string, page?: number, pageSize?: number, query?: string, random?: string, rating?: number, timescooked?: number, units?: number, updatedon?: string, viewedon?: string, options?: any) {
        return ApiApiFp(this.configuration).listRecipes(books, booksAnd, booksAndNot, booksOr, booksOrNot, cookedon, createdon, foods, foodsAnd, foodsAndNot, foodsOr, foodsOrNot, internal, keywords, keywordsAnd, keywordsAndNot, keywordsOr, keywordsOrNot, makenow, _new, page, pageSize, query, random, rating, timescooked, units, updatedon, viewedon, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listRecipes2(options?: any) {
        return ApiApiFp(this.configuration).listRecipes2(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [checked] Filter shopping list entries on checked.  [true, false, both, &lt;b&gt;recent&lt;/b&gt;]&lt;br&gt;                              - recent includes unchecked items and recently completed items.
     * @param {number} [id] Returns the shopping list entry with a primary key of id.  Multiple values allowed.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {number} [supermarket] Returns the shopping list entries sorted by supermarket category order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listShoppingListEntrys(checked?: string, id?: number, page?: number, pageSize?: number, supermarket?: number, options?: any) {
        return ApiApiFp(this.configuration).listShoppingListEntrys(checked, id, page, pageSize, supermarket, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listShoppingListRecipes(page?: number, pageSize?: number, options?: any) {
        return ApiApiFp(this.configuration).listShoppingListRecipes(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listSpaces(options?: any) {
        return ApiApiFp(this.configuration).listSpaces(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [query] Query string matched (fuzzy) against object name.
     * @param {Array<number>} [recipe] ID of recipe a step is part of. For multiple repeat parameter.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listSteps(page?: number, pageSize?: number, query?: string, recipe?: Array<number>, options?: any) {
        return ApiApiFp(this.configuration).listSteps(page, pageSize, query, recipe, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listStorages(options?: any) {
        return ApiApiFp(this.configuration).listStorages(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [limit] limit number of entries to return
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [query] lookup if query string is contained within the name, case insensitive
     * @param {string} [random] randomly orders entries (only works together with limit)
     * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listSupermarketCategoryRelations(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any) {
        return ApiApiFp(this.configuration).listSupermarketCategoryRelations(limit, page, pageSize, query, random, updatedAt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [limit] limit number of entries to return
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [query] lookup if query string is contained within the name, case insensitive
     * @param {string} [random] randomly orders entries (only works together with limit)
     * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listSupermarketCategorys(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any) {
        return ApiApiFp(this.configuration).listSupermarketCategorys(limit, page, pageSize, query, random, updatedAt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [limit] limit number of entries to return
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [query] lookup if query string is contained within the name, case insensitive
     * @param {string} [random] randomly orders entries (only works together with limit)
     * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listSupermarkets(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any) {
        return ApiApiFp(this.configuration).listSupermarkets(limit, page, pageSize, query, random, updatedAt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listSyncLogs(page?: number, pageSize?: number, options?: any) {
        return ApiApiFp(this.configuration).listSyncLogs(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listSyncs(page?: number, pageSize?: number, options?: any) {
        return ApiApiFp(this.configuration).listSyncs(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [foodId] ID of food to filter for
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listUnitConversions(foodId?: number, page?: number, pageSize?: number, options?: any) {
        return ApiApiFp(this.configuration).listUnitConversions(foodId, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [limit] limit number of entries to return
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [query] lookup if query string is contained within the name, case insensitive
     * @param {string} [random] randomly orders entries (only works together with limit)
     * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listUnits(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any) {
        return ApiApiFp(this.configuration).listUnits(limit, page, pageSize, query, random, updatedAt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [limit] limit number of entries to return
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [query] lookup if query string is contained within the name, case insensitive
     * @param {string} [random] randomly orders entries (only works together with limit)
     * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listUserFiles(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any) {
        return ApiApiFp(this.configuration).listUserFiles(limit, page, pageSize, query, random, updatedAt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listUserPreferences(options?: any) {
        return ApiApiFp(this.configuration).listUserPreferences(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [internalNote] I have no idea what this is
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listUserSpaces(internalNote?: string, page?: number, pageSize?: number, options?: any) {
        return ApiApiFp(this.configuration).listUserSpaces(internalNote, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<string>} [filterList] User IDs, repeat for multiple
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listUsers(filterList?: Array<string>, options?: any) {
        return ApiApiFp(this.configuration).listUsers(filterList, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listViewLogs(page?: number, pageSize?: number, options?: any) {
        return ApiApiFp(this.configuration).listViewLogs(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this food.
     * @param {number} target The ID of the {obj} you want to merge with.
     * @param {Food} food 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public mergeFood(id: number, target: number, food: Food, options?: any) {
        return ApiApiFp(this.configuration).mergeFood(id, target, food, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this keyword.
     * @param {number} target The ID of the {obj} you want to merge with.
     * @param {Keyword} keyword 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public mergeKeyword(id: number, target: number, keyword: Keyword, options?: any) {
        return ApiApiFp(this.configuration).mergeKeyword(id, target, keyword, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this supermarket category.
     * @param {number} target The ID of the {obj} you want to merge with.
     * @param {SupermarketCategory} supermarketCategory 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public mergeSupermarketCategory(id: number, target: number, supermarketCategory: SupermarketCategory, options?: any) {
        return ApiApiFp(this.configuration).mergeSupermarketCategory(id, target, supermarketCategory, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this unit.
     * @param {number} target The ID of the {obj} you want to merge with.
     * @param {Unit} unit 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public mergeUnit(id: number, target: number, unit: Unit, options?: any) {
        return ApiApiFp(this.configuration).mergeUnit(id, target, unit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this food.
     * @param {number} parent The ID of the desired parent of the {obj}.
     * @param {Food} food 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public moveFood(id: number, parent: number, food: Food, options?: any) {
        return ApiApiFp(this.configuration).moveFood(id, parent, food, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this keyword.
     * @param {number} parent The ID of the desired parent of the {obj}.
     * @param {Keyword} keyword 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public moveKeyword(id: number, parent: number, keyword: Keyword, options?: any) {
        return ApiApiFp(this.configuration).moveKeyword(id, parent, keyword, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this access token.
     * @param {PatchedAccessToken} [patchedAccessToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateAccessToken(id: number, patchedAccessToken?: PatchedAccessToken, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateAccessToken(id, patchedAccessToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this automation.
     * @param {PatchedAutomation} [patchedAutomation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateAutomation(id: number, patchedAutomation?: PatchedAutomation, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateAutomation(id, patchedAutomation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this bookmarklet import.
     * @param {PatchedBookmarkletImport} [patchedBookmarkletImport] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateBookmarkletImport(id: number, patchedBookmarkletImport?: PatchedBookmarkletImport, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateBookmarkletImport(id, patchedBookmarkletImport, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this connector config.
     * @param {PatchedConnectorConfigConfig} [patchedConnectorConfigConfig] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateConnectorConfig(id: number, patchedConnectorConfigConfig?: PatchedConnectorConfigConfig, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateConnectorConfig(id, patchedConnectorConfigConfig, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this cook log.
     * @param {PatchedCookLog} [patchedCookLog] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateCookLog(id: number, patchedCookLog?: PatchedCookLog, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateCookLog(id, patchedCookLog, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this custom filter.
     * @param {PatchedCustomFilter} [patchedCustomFilter] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateCustomFilter(id: number, patchedCustomFilter?: PatchedCustomFilter, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateCustomFilter(id, patchedCustomFilter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this export log.
     * @param {PatchedExportLog} [patchedExportLog] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateExportLog(id: number, patchedExportLog?: PatchedExportLog, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateExportLog(id, patchedExportLog, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this food.
     * @param {PatchedFood} [patchedFood] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateFood(id: number, patchedFood?: PatchedFood, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateFood(id, patchedFood, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this import log.
     * @param {PatchedImportLog} [patchedImportLog] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateImportLog(id: number, patchedImportLog?: PatchedImportLog, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateImportLog(id, patchedImportLog, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this ingredient.
     * @param {PatchedIngredient} [patchedIngredient] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateIngredient(id: number, patchedIngredient?: PatchedIngredient, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateIngredient(id, patchedIngredient, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this invite link.
     * @param {PatchedInviteLink} [patchedInviteLink] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateInviteLink(id: number, patchedInviteLink?: PatchedInviteLink, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateInviteLink(id, patchedInviteLink, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this keyword.
     * @param {PatchedKeyword} [patchedKeyword] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateKeyword(id: number, patchedKeyword?: PatchedKeyword, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateKeyword(id, patchedKeyword, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this meal plan.
     * @param {PatchedMealPlan} [patchedMealPlan] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateMealPlan(id: number, patchedMealPlan?: PatchedMealPlan, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateMealPlan(id, patchedMealPlan, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * returns list of meal types created by the requesting user ordered by the order field.
     * @param {number} id A unique integer value identifying this meal type.
     * @param {PatchedMealType} [patchedMealType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateMealType(id: number, patchedMealType?: PatchedMealType, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateMealType(id, patchedMealType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this property.
     * @param {PatchedProperty} [patchedProperty] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateProperty(id: number, patchedProperty?: PatchedProperty, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateProperty(id, patchedProperty, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this property type.
     * @param {PatchedPropertyType} [patchedPropertyType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdatePropertyType(id: number, patchedPropertyType?: PatchedPropertyType, options?: any) {
        return ApiApiFp(this.configuration).partialUpdatePropertyType(id, patchedPropertyType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this recipe.
     * @param {PatchedRecipe} [patchedRecipe] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateRecipe(id: number, patchedRecipe?: PatchedRecipe, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateRecipe(id, patchedRecipe, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this recipe book.
     * @param {PatchedRecipeBook} [patchedRecipeBook] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateRecipeBook(id: number, patchedRecipeBook?: PatchedRecipeBook, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateRecipeBook(id, patchedRecipeBook, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this recipe book entry.
     * @param {PatchedRecipeBookEntry} [patchedRecipeBookEntry] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateRecipeBookEntry(id: number, patchedRecipeBookEntry?: PatchedRecipeBookEntry, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateRecipeBookEntry(id, patchedRecipeBookEntry, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this shopping list entry.
     * @param {PatchedShoppingListEntry} [patchedShoppingListEntry] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateShoppingListEntry(id: number, patchedShoppingListEntry?: PatchedShoppingListEntry, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateShoppingListEntry(id, patchedShoppingListEntry, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this shopping list recipe.
     * @param {PatchedShoppingListRecipe} [patchedShoppingListRecipe] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateShoppingListRecipe(id: number, patchedShoppingListRecipe?: PatchedShoppingListRecipe, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateShoppingListRecipe(id, patchedShoppingListRecipe, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this space.
     * @param {PatchedSpace} [patchedSpace] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateSpace(id: number, patchedSpace?: PatchedSpace, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateSpace(id, patchedSpace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this step.
     * @param {PatchedStep} [patchedStep] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateStep(id: number, patchedStep?: PatchedStep, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateStep(id, patchedStep, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this storage.
     * @param {PatchedStorage} [patchedStorage] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateStorage(id: number, patchedStorage?: PatchedStorage, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateStorage(id, patchedStorage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this supermarket.
     * @param {PatchedSupermarket} [patchedSupermarket] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateSupermarket(id: number, patchedSupermarket?: PatchedSupermarket, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateSupermarket(id, patchedSupermarket, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this supermarket category.
     * @param {PatchedSupermarketCategory} [patchedSupermarketCategory] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateSupermarketCategory(id: number, patchedSupermarketCategory?: PatchedSupermarketCategory, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateSupermarketCategory(id, patchedSupermarketCategory, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this supermarket category relation.
     * @param {PatchedSupermarketCategoryRelation} [patchedSupermarketCategoryRelation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateSupermarketCategoryRelation(id: number, patchedSupermarketCategoryRelation?: PatchedSupermarketCategoryRelation, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateSupermarketCategoryRelation(id, patchedSupermarketCategoryRelation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this sync.
     * @param {PatchedSync} [patchedSync] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateSync(id: number, patchedSync?: PatchedSync, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateSync(id, patchedSync, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this unit.
     * @param {PatchedUnit} [patchedUnit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateUnit(id: number, patchedUnit?: PatchedUnit, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateUnit(id, patchedUnit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this unit conversion.
     * @param {PatchedUnitConversion} [patchedUnitConversion] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateUnitConversion(id: number, patchedUnitConversion?: PatchedUnitConversion, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateUnitConversion(id, patchedUnitConversion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user.
     * @param {PatchedUser} [patchedUser] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateUser(id: number, patchedUser?: PatchedUser, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateUser(id, patchedUser, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user file.
     * @param {number} [id2] 
     * @param {string} [name] 
     * @param {string} [file] 
     * @param {string} [fileDownload] 
     * @param {string} [preview] 
     * @param {number} [fileSizeKb] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateUserFile(id: number, id2?: number, name?: string, file?: string, fileDownload?: string, preview?: string, fileSizeKb?: number, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateUserFile(id, id2, name, file, fileDownload, preview, fileSizeKb, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} user A unique value identifying this user preference.
     * @param {PatchedUserPreference} [patchedUserPreference] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateUserPreference(user: number, patchedUserPreference?: PatchedUserPreference, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateUserPreference(user, patchedUserPreference, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user space.
     * @param {PatchedUserSpace} [patchedUserSpace] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateUserSpace(id: number, patchedUserSpace?: PatchedUserSpace, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateUserSpace(id, patchedUserSpace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this view log.
     * @param {PatchedViewLog} [patchedViewLog] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateViewLog(id: number, patchedViewLog?: PatchedViewLog, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateViewLog(id, patchedViewLog, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this recipe.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public relatedRecipe(id: number, options?: any) {
        return ApiApiFp(this.configuration).relatedRecipe(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this access token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveAccessToken(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveAccessToken(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this automation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveAutomation(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveAutomation(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this bookmarklet import.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveBookmarkletImport(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveBookmarkletImport(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this connector config.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveConnectorConfig(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveConnectorConfig(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this cook log.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveCookLog(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveCookLog(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this custom filter.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveCustomFilter(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveCustomFilter(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this export log.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveExportLog(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveExportLog(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this food.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveFood(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveFood(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this food inherit field.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveFoodInheritField(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveFoodInheritField(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this group.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveGroup(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveGroup(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this import log.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveImportLog(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveImportLog(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this ingredient.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveIngredient(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveIngredient(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this invite link.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveInviteLink(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveInviteLink(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this keyword.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveKeyword(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveKeyword(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this meal plan.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveMealPlan(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveMealPlan(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * returns list of meal types created by the requesting user ordered by the order field.
     * @param {number} id A unique integer value identifying this meal type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveMealType(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveMealType(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this property.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveProperty(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveProperty(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this property type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrievePropertyType(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrievePropertyType(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this recipe.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveRecipe(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveRecipe(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this recipe book.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveRecipeBook(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveRecipeBook(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this recipe book entry.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveRecipeBookEntry(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveRecipeBookEntry(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this shopping list entry.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveShoppingListEntry(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveShoppingListEntry(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this shopping list recipe.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveShoppingListRecipe(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveShoppingListRecipe(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this space.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveSpace(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveSpace(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this step.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveStep(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveStep(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this storage.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveStorage(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveStorage(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this supermarket.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveSupermarket(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveSupermarket(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this supermarket category.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveSupermarketCategory(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveSupermarketCategory(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this supermarket category relation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveSupermarketCategoryRelation(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveSupermarketCategoryRelation(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this sync.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveSync(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveSync(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this sync log.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveSyncLog(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveSyncLog(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this unit.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveUnit(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveUnit(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this unit conversion.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveUnitConversion(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveUnitConversion(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveUser(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveUserFile(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveUserFile(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} user A unique value identifying this user preference.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveUserPreference(user: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveUserPreference(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user space.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveUserSpace(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveUserSpace(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this view log.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveViewLog(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveViewLog(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * function to download a user file securely (wrapping as zip to prevent any context based XSS problems) temporary solution until a real file manager is implemented
     * @param {number} fileId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrievedownloadFile(fileId: number, options?: any) {
        return ApiApiFp(this.configuration).retrievedownloadFile(fileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} recipeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrievegetExternalFileLink(recipeId: number, options?: any) {
        return ApiApiFp(this.configuration).retrievegetExternalFileLink(recipeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} recipeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrievegetRecipeFile(recipeId: number, options?: any) {
        return ApiApiFp(this.configuration).retrievegetRecipeFile(recipeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveshareLink(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveshareLink(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * api endpoint to switch space function
     * @param {number} spaceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveswitchActiveSpace(spaceId: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveswitchActiveSpace(spaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this food.
     * @param {FoodShoppingUpdate} foodShoppingUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public shoppingFood(id: number, foodShoppingUpdate: FoodShoppingUpdate, options?: any) {
        return ApiApiFp(this.configuration).shoppingFood(id, foodShoppingUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this recipe.
     * @param {RecipeShoppingUpdate} [recipeShoppingUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public shoppingRecipe(id: number, recipeShoppingUpdate?: RecipeShoppingUpdate, options?: any) {
        return ApiApiFp(this.configuration).shoppingRecipe(id, recipeShoppingUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this access token.
     * @param {AccessToken} accessToken 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateAccessToken(id: number, accessToken: AccessToken, options?: any) {
        return ApiApiFp(this.configuration).updateAccessToken(id, accessToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this automation.
     * @param {Automation} automation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateAutomation(id: number, automation: Automation, options?: any) {
        return ApiApiFp(this.configuration).updateAutomation(id, automation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this bookmarklet import.
     * @param {BookmarkletImport} bookmarkletImport 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateBookmarkletImport(id: number, bookmarkletImport: BookmarkletImport, options?: any) {
        return ApiApiFp(this.configuration).updateBookmarkletImport(id, bookmarkletImport, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this connector config.
     * @param {ConnectorConfigConfig} connectorConfigConfig 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateConnectorConfig(id: number, connectorConfigConfig: ConnectorConfigConfig, options?: any) {
        return ApiApiFp(this.configuration).updateConnectorConfig(id, connectorConfigConfig, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this cook log.
     * @param {CookLog} cookLog 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateCookLog(id: number, cookLog: CookLog, options?: any) {
        return ApiApiFp(this.configuration).updateCookLog(id, cookLog, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this custom filter.
     * @param {CustomFilter} customFilter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateCustomFilter(id: number, customFilter: CustomFilter, options?: any) {
        return ApiApiFp(this.configuration).updateCustomFilter(id, customFilter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this export log.
     * @param {ExportLog} exportLog 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateExportLog(id: number, exportLog: ExportLog, options?: any) {
        return ApiApiFp(this.configuration).updateExportLog(id, exportLog, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this food.
     * @param {Food} food 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateFood(id: number, food: Food, options?: any) {
        return ApiApiFp(this.configuration).updateFood(id, food, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this import log.
     * @param {ImportLog} importLog 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateImportLog(id: number, importLog: ImportLog, options?: any) {
        return ApiApiFp(this.configuration).updateImportLog(id, importLog, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this ingredient.
     * @param {Ingredient} ingredient 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateIngredient(id: number, ingredient: Ingredient, options?: any) {
        return ApiApiFp(this.configuration).updateIngredient(id, ingredient, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this invite link.
     * @param {InviteLink} inviteLink 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateInviteLink(id: number, inviteLink: InviteLink, options?: any) {
        return ApiApiFp(this.configuration).updateInviteLink(id, inviteLink, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this keyword.
     * @param {Keyword} keyword 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateKeyword(id: number, keyword: Keyword, options?: any) {
        return ApiApiFp(this.configuration).updateKeyword(id, keyword, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this meal plan.
     * @param {MealPlan} mealPlan 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateMealPlan(id: number, mealPlan: MealPlan, options?: any) {
        return ApiApiFp(this.configuration).updateMealPlan(id, mealPlan, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * returns list of meal types created by the requesting user ordered by the order field.
     * @param {number} id A unique integer value identifying this meal type.
     * @param {MealType} mealType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateMealType(id: number, mealType: MealType, options?: any) {
        return ApiApiFp(this.configuration).updateMealType(id, mealType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this property.
     * @param {Property} property 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateProperty(id: number, property: Property, options?: any) {
        return ApiApiFp(this.configuration).updateProperty(id, property, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this property type.
     * @param {PropertyType} propertyType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updatePropertyType(id: number, propertyType: PropertyType, options?: any) {
        return ApiApiFp(this.configuration).updatePropertyType(id, propertyType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this recipe.
     * @param {Recipe} recipe 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateRecipe(id: number, recipe: Recipe, options?: any) {
        return ApiApiFp(this.configuration).updateRecipe(id, recipe, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this recipe book.
     * @param {RecipeBook} recipeBook 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateRecipeBook(id: number, recipeBook: RecipeBook, options?: any) {
        return ApiApiFp(this.configuration).updateRecipeBook(id, recipeBook, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this recipe book entry.
     * @param {RecipeBookEntry} recipeBookEntry 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateRecipeBookEntry(id: number, recipeBookEntry: RecipeBookEntry, options?: any) {
        return ApiApiFp(this.configuration).updateRecipeBookEntry(id, recipeBookEntry, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this shopping list entry.
     * @param {ShoppingListEntry} shoppingListEntry 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateShoppingListEntry(id: number, shoppingListEntry: ShoppingListEntry, options?: any) {
        return ApiApiFp(this.configuration).updateShoppingListEntry(id, shoppingListEntry, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this shopping list recipe.
     * @param {ShoppingListRecipe} shoppingListRecipe 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateShoppingListRecipe(id: number, shoppingListRecipe: ShoppingListRecipe, options?: any) {
        return ApiApiFp(this.configuration).updateShoppingListRecipe(id, shoppingListRecipe, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this step.
     * @param {Step} step 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateStep(id: number, step: Step, options?: any) {
        return ApiApiFp(this.configuration).updateStep(id, step, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this storage.
     * @param {Storage} storage 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateStorage(id: number, storage: Storage, options?: any) {
        return ApiApiFp(this.configuration).updateStorage(id, storage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this supermarket.
     * @param {Supermarket} supermarket 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateSupermarket(id: number, supermarket: Supermarket, options?: any) {
        return ApiApiFp(this.configuration).updateSupermarket(id, supermarket, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this supermarket category.
     * @param {SupermarketCategory} supermarketCategory 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateSupermarketCategory(id: number, supermarketCategory: SupermarketCategory, options?: any) {
        return ApiApiFp(this.configuration).updateSupermarketCategory(id, supermarketCategory, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this supermarket category relation.
     * @param {SupermarketCategoryRelation} supermarketCategoryRelation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateSupermarketCategoryRelation(id: number, supermarketCategoryRelation: SupermarketCategoryRelation, options?: any) {
        return ApiApiFp(this.configuration).updateSupermarketCategoryRelation(id, supermarketCategoryRelation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this sync.
     * @param {Sync} sync 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateSync(id: number, sync: Sync, options?: any) {
        return ApiApiFp(this.configuration).updateSync(id, sync, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this unit.
     * @param {Unit} unit 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateUnit(id: number, unit: Unit, options?: any) {
        return ApiApiFp(this.configuration).updateUnit(id, unit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this unit conversion.
     * @param {UnitConversion} unitConversion 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateUnitConversion(id: number, unitConversion: UnitConversion, options?: any) {
        return ApiApiFp(this.configuration).updateUnitConversion(id, unitConversion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user file.
     * @param {string} name 
     * @param {string} file 
     * @param {string} fileDownload 
     * @param {string} preview 
     * @param {number} fileSizeKb 
     * @param {number} [id2] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateUserFile(id: number, name: string, file: string, fileDownload: string, preview: string, fileSizeKb: number, id2?: number, options?: any) {
        return ApiApiFp(this.configuration).updateUserFile(id, name, file, fileDownload, preview, fileSizeKb, id2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this view log.
     * @param {ViewLog} viewLog 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateViewLog(id: number, viewLog: ViewLog, options?: any) {
        return ApiApiFp(this.configuration).updateViewLog(id, viewLog, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ApiImportOpenDataApi - axios parameter creator
 * @export
 */
export const ApiImportOpenDataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createImportOpenData: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api-import-open-data/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveImportOpenData: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api-import-open-data/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApiImportOpenDataApi - functional programming interface
 * @export
 */
export const ApiImportOpenDataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApiImportOpenDataApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createImportOpenData(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createImportOpenData(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveImportOpenData(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveImportOpenData(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApiImportOpenDataApi - factory interface
 * @export
 */
export const ApiImportOpenDataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApiImportOpenDataApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createImportOpenData(options?: any): AxiosPromise<void> {
            return localVarFp.createImportOpenData(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveImportOpenData(options?: any): AxiosPromise<void> {
            return localVarFp.retrieveImportOpenData(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApiImportOpenDataApi - object-oriented interface
 * @export
 * @class ApiImportOpenDataApi
 * @extends {BaseAPI}
 */
export class ApiImportOpenDataApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiImportOpenDataApi
     */
    public createImportOpenData(options?: any) {
        return ApiImportOpenDataApiFp(this.configuration).createImportOpenData(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiImportOpenDataApi
     */
    public retrieveImportOpenData(options?: any) {
        return ApiImportOpenDataApiFp(this.configuration).retrieveImportOpenData(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ApiTokenAuthApi - axios parameter creator
 * @export
 */
export const ApiTokenAuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} username 
         * @param {string} password 
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAuthToken: async (username: string, password: string, token: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('createAuthToken', 'username', username)
            // verify required parameter 'password' is not null or undefined
            assertParamExists('createAuthToken', 'password', password)
            // verify required parameter 'token' is not null or undefined
            assertParamExists('createAuthToken', 'token', token)
            const localVarPath = `/api-token-auth/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (username !== undefined) { 
                localVarFormParams.append('username', username as any);
            }
    
            if (password !== undefined) { 
                localVarFormParams.append('password', password as any);
            }
    
            if (token !== undefined) { 
                localVarFormParams.append('token', token as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApiTokenAuthApi - functional programming interface
 * @export
 */
export const ApiTokenAuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApiTokenAuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} username 
         * @param {string} password 
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAuthToken(username: string, password: string, token: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAuthToken(username, password, token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApiTokenAuthApi - factory interface
 * @export
 */
export const ApiTokenAuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApiTokenAuthApiFp(configuration)
    return {
        /**
         * 
         * @param {string} username 
         * @param {string} password 
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAuthToken(username: string, password: string, token: string, options?: any): AxiosPromise<AuthToken> {
            return localVarFp.createAuthToken(username, password, token, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApiTokenAuthApi - object-oriented interface
 * @export
 * @class ApiTokenAuthApi
 * @extends {BaseAPI}
 */
export class ApiTokenAuthApi extends BaseAPI {
    /**
     * 
     * @param {string} username 
     * @param {string} password 
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiTokenAuthApi
     */
    public createAuthToken(username: string, password: string, token: string, options?: any) {
        return ApiTokenAuthApiFp(this.configuration).createAuthToken(username, password, token, options).then((request) => request(this.axios, this.basePath));
    }
}


