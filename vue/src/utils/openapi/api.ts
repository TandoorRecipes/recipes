/* tslint:disable */
/* eslint-disable */
/**
 * Django Recipes
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AccessToken
 */
export interface AccessToken {
    /**
     * 
     * @type {number}
     * @memberof AccessToken
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof AccessToken
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof AccessToken
     */
    expires: string;
    /**
     * 
     * @type {string}
     * @memberof AccessToken
     */
    scope?: string;
    /**
     * 
     * @type {string}
     * @memberof AccessToken
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof AccessToken
     */
    updated?: string;
}
/**
 * 
 * @export
 * @interface AuthToken
 */
export interface AuthToken {
    /**
     * 
     * @type {string}
     * @memberof AuthToken
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof AuthToken
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof AuthToken
     */
    token?: string;
}
/**
 * 
 * @export
 * @interface Automation
 */
export interface Automation {
    /**
     * 
     * @type {number}
     * @memberof Automation
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Automation
     */
    type: AutomationTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Automation
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Automation
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Automation
     */
    param_1?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Automation
     */
    param_2?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Automation
     */
    param_3?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Automation
     */
    order?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Automation
     */
    disabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Automation
     */
    created_by?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum AutomationTypeEnum {
    FoodAlias = 'FOOD_ALIAS',
    UnitAlias = 'UNIT_ALIAS',
    KeywordAlias = 'KEYWORD_ALIAS',
    DescriptionReplace = 'DESCRIPTION_REPLACE',
    InstructionReplace = 'INSTRUCTION_REPLACE',
    NeverUnit = 'NEVER_UNIT',
    TransposeWords = 'TRANSPOSE_WORDS',
    FoodReplace = 'FOOD_REPLACE',
    UnitReplace = 'UNIT_REPLACE',
    NameReplace = 'NAME_REPLACE'
}

/**
 * 
 * @export
 * @interface BookmarkletImport
 */
export interface BookmarkletImport {
    /**
     * 
     * @type {number}
     * @memberof BookmarkletImport
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof BookmarkletImport
     */
    url?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookmarkletImport
     */
    html: string;
    /**
     * 
     * @type {string}
     * @memberof BookmarkletImport
     */
    created_by?: string;
    /**
     * 
     * @type {string}
     * @memberof BookmarkletImport
     */
    created_at?: string;
}
/**
 * 
 * @export
 * @interface BookmarkletImportList
 */
export interface BookmarkletImportList {
    /**
     * 
     * @type {number}
     * @memberof BookmarkletImportList
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof BookmarkletImportList
     */
    url?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookmarkletImportList
     */
    created_by?: string;
    /**
     * 
     * @type {string}
     * @memberof BookmarkletImportList
     */
    created_at?: string;
}
/**
 * 
 * @export
 * @interface CookLog
 */
export interface CookLog {
    /**
     * 
     * @type {number}
     * @memberof CookLog
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof CookLog
     */
    recipe: number;
    /**
     * 
     * @type {number}
     * @memberof CookLog
     */
    servings?: number;
    /**
     * 
     * @type {number}
     * @memberof CookLog
     */
    rating?: number | null;
    /**
     * 
     * @type {string}
     * @memberof CookLog
     */
    created_by?: string;
    /**
     * 
     * @type {string}
     * @memberof CookLog
     */
    created_at?: string;
}
/**
 * 
 * @export
 * @interface CustomFilter
 */
export interface CustomFilter {
    /**
     * 
     * @type {number}
     * @memberof CustomFilter
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof CustomFilter
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CustomFilter
     */
    search: string;
    /**
     * 
     * @type {Array<CustomFilterShared>}
     * @memberof CustomFilter
     */
    shared?: Array<CustomFilterShared>;
    /**
     * 
     * @type {string}
     * @memberof CustomFilter
     */
    created_by?: string;
}
/**
 * 
 * @export
 * @interface CustomFilterShared
 */
export interface CustomFilterShared {
    /**
     * 
     * @type {number}
     * @memberof CustomFilterShared
     */
    id?: number;
    /**
     * Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.
     * @type {string}
     * @memberof CustomFilterShared
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomFilterShared
     */
    first_name?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomFilterShared
     */
    last_name?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomFilterShared
     */
    display_name?: string;
}
/**
 * 
 * @export
 * @interface ExportLog
 */
export interface ExportLog {
    /**
     * 
     * @type {number}
     * @memberof ExportLog
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ExportLog
     */
    type: string;
    /**
     * 
     * @type {string}
     * @memberof ExportLog
     */
    msg?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ExportLog
     */
    running?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ExportLog
     */
    total_recipes?: number;
    /**
     * 
     * @type {number}
     * @memberof ExportLog
     */
    exported_recipes?: number;
    /**
     * 
     * @type {number}
     * @memberof ExportLog
     */
    cache_duration?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ExportLog
     */
    possibly_not_expired?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ExportLog
     */
    created_by?: string;
    /**
     * 
     * @type {string}
     * @memberof ExportLog
     */
    created_at?: string;
}
/**
 * 
 * @export
 * @interface Food
 */
export interface Food {
    /**
     * 
     * @type {number}
     * @memberof Food
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Food
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Food
     */
    plural_name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Food
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof Food
     */
    shopping?: string;
    /**
     * 
     * @type {FoodRecipe}
     * @memberof Food
     */
    recipe?: FoodRecipe | null;
    /**
     * 
     * @type {string}
     * @memberof Food
     */
    url?: string | null;
    /**
     * 
     * @type {Array<FoodProperties>}
     * @memberof Food
     */
    properties?: Array<FoodProperties> | null;
    /**
     * 
     * @type {string}
     * @memberof Food
     */
    properties_food_amount?: string;
    /**
     * 
     * @type {FoodPropertiesFoodUnit}
     * @memberof Food
     */
    properties_food_unit?: FoodPropertiesFoodUnit | null;
    /**
     * 
     * @type {number}
     * @memberof Food
     */
    fdc_id?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Food
     */
    food_onhand?: string | null;
    /**
     * 
     * @type {FoodSupermarketCategory}
     * @memberof Food
     */
    supermarket_category?: FoodSupermarketCategory | null;
    /**
     * 
     * @type {string}
     * @memberof Food
     */
    parent?: string;
    /**
     * 
     * @type {number}
     * @memberof Food
     */
    numchild?: number;
    /**
     * 
     * @type {Array<FoodInheritFields>}
     * @memberof Food
     */
    inherit_fields?: Array<FoodInheritFields> | null;
    /**
     * 
     * @type {string}
     * @memberof Food
     */
    full_name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Food
     */
    ignore_shopping?: boolean;
    /**
     * 
     * @type {Array<FoodSubstitute>}
     * @memberof Food
     */
    substitute?: Array<FoodSubstitute> | null;
    /**
     * 
     * @type {boolean}
     * @memberof Food
     */
    substitute_siblings?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Food
     */
    substitute_children?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Food
     */
    substitute_onhand?: string;
    /**
     * 
     * @type {Array<FoodInheritFields>}
     * @memberof Food
     */
    child_inherit_fields?: Array<FoodInheritFields> | null;
    /**
     * 
     * @type {string}
     * @memberof Food
     */
    open_data_slug?: string | null;
}
/**
 * 
 * @export
 * @interface FoodInheritField
 */
export interface FoodInheritField {
    /**
     * 
     * @type {number}
     * @memberof FoodInheritField
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof FoodInheritField
     */
    name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FoodInheritField
     */
    field?: string | null;
}
/**
 * 
 * @export
 * @interface FoodInheritFields
 */
export interface FoodInheritFields {
    /**
     * 
     * @type {number}
     * @memberof FoodInheritFields
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof FoodInheritFields
     */
    name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FoodInheritFields
     */
    field?: string | null;
}
/**
 * 
 * @export
 * @interface FoodProperties
 */
export interface FoodProperties {
    /**
     * 
     * @type {number}
     * @memberof FoodProperties
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof FoodProperties
     */
    property_amount: string | null;
    /**
     * 
     * @type {FoodPropertyType}
     * @memberof FoodProperties
     */
    property_type: FoodPropertyType;
}
/**
 * 
 * @export
 * @interface FoodPropertiesFoodUnit
 */
export interface FoodPropertiesFoodUnit {
    /**
     * 
     * @type {number}
     * @memberof FoodPropertiesFoodUnit
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof FoodPropertiesFoodUnit
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof FoodPropertiesFoodUnit
     */
    plural_name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FoodPropertiesFoodUnit
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FoodPropertiesFoodUnit
     */
    base_unit?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FoodPropertiesFoodUnit
     */
    open_data_slug?: string | null;
}
/**
 * 
 * @export
 * @interface FoodPropertyType
 */
export interface FoodPropertyType {
    /**
     * 
     * @type {number}
     * @memberof FoodPropertyType
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof FoodPropertyType
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof FoodPropertyType
     */
    unit?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FoodPropertyType
     */
    description?: string | null;
    /**
     * 
     * @type {number}
     * @memberof FoodPropertyType
     */
    order?: number;
    /**
     * 
     * @type {string}
     * @memberof FoodPropertyType
     */
    open_data_slug?: string | null;
    /**
     * 
     * @type {number}
     * @memberof FoodPropertyType
     */
    fdc_id?: number | null;
}
/**
 * 
 * @export
 * @interface FoodRecipe
 */
export interface FoodRecipe {
    /**
     * 
     * @type {number}
     * @memberof FoodRecipe
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof FoodRecipe
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof FoodRecipe
     */
    url?: string;
}
/**
 * 
 * @export
 * @interface FoodShoppingUpdate
 */
export interface FoodShoppingUpdate {
    /**
     * 
     * @type {number}
     * @memberof FoodShoppingUpdate
     */
    id?: number;
    /**
     * Amount of food to add to the shopping list
     * @type {number}
     * @memberof FoodShoppingUpdate
     */
    amount?: number | null;
    /**
     * ID of unit to use for the shopping list
     * @type {number}
     * @memberof FoodShoppingUpdate
     */
    unit?: number | null;
    /**
     * When set to true will delete all food from active shopping lists.
     * @type {string}
     * @memberof FoodShoppingUpdate
     */
    _delete: FoodShoppingUpdateDeleteEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum FoodShoppingUpdateDeleteEnum {
    True = 'true'
}

/**
 * 
 * @export
 * @interface FoodSubstitute
 */
export interface FoodSubstitute {
    /**
     * 
     * @type {number}
     * @memberof FoodSubstitute
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof FoodSubstitute
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof FoodSubstitute
     */
    plural_name?: string | null;
}
/**
 * 
 * @export
 * @interface FoodSupermarketCategory
 */
export interface FoodSupermarketCategory {
    /**
     * 
     * @type {number}
     * @memberof FoodSupermarketCategory
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof FoodSupermarketCategory
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof FoodSupermarketCategory
     */
    description?: string | null;
}
/**
 * 
 * @export
 * @interface Group
 */
export interface Group {
    /**
     * 
     * @type {number}
     * @memberof Group
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    name: string;
}
/**
 * 
 * @export
 * @interface ImportLog
 */
export interface ImportLog {
    /**
     * 
     * @type {number}
     * @memberof ImportLog
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ImportLog
     */
    type: string;
    /**
     * 
     * @type {string}
     * @memberof ImportLog
     */
    msg?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ImportLog
     */
    running?: boolean;
    /**
     * 
     * @type {ImportLogKeyword}
     * @memberof ImportLog
     */
    keyword?: ImportLogKeyword;
    /**
     * 
     * @type {number}
     * @memberof ImportLog
     */
    total_recipes?: number;
    /**
     * 
     * @type {number}
     * @memberof ImportLog
     */
    imported_recipes?: number;
    /**
     * 
     * @type {string}
     * @memberof ImportLog
     */
    created_by?: string;
    /**
     * 
     * @type {string}
     * @memberof ImportLog
     */
    created_at?: string;
}
/**
 * 
 * @export
 * @interface ImportLogKeyword
 */
export interface ImportLogKeyword {
    /**
     * 
     * @type {number}
     * @memberof ImportLogKeyword
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ImportLogKeyword
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ImportLogKeyword
     */
    label?: string;
    /**
     * 
     * @type {string}
     * @memberof ImportLogKeyword
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof ImportLogKeyword
     */
    parent?: string;
    /**
     * 
     * @type {number}
     * @memberof ImportLogKeyword
     */
    numchild?: number;
    /**
     * 
     * @type {string}
     * @memberof ImportLogKeyword
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof ImportLogKeyword
     */
    updated_at?: string;
    /**
     * 
     * @type {string}
     * @memberof ImportLogKeyword
     */
    full_name?: string;
}
/**
 * 
 * @export
 * @interface Ingredient
 */
export interface Ingredient {
    /**
     * 
     * @type {number}
     * @memberof Ingredient
     */
    id?: number;
    /**
     * 
     * @type {IngredientFood}
     * @memberof Ingredient
     */
    food: IngredientFood | null;
    /**
     * 
     * @type {FoodPropertiesFoodUnit}
     * @memberof Ingredient
     */
    unit: FoodPropertiesFoodUnit | null;
    /**
     * 
     * @type {string}
     * @memberof Ingredient
     */
    amount: string;
    /**
     * 
     * @type {string}
     * @memberof Ingredient
     */
    conversions?: string;
    /**
     * 
     * @type {string}
     * @memberof Ingredient
     */
    note?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Ingredient
     */
    order?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Ingredient
     */
    is_header?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Ingredient
     */
    no_amount?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Ingredient
     */
    original_text?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Ingredient
     */
    used_in_recipes?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Ingredient
     */
    always_use_plural_unit?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Ingredient
     */
    always_use_plural_food?: boolean;
}
/**
 * 
 * @export
 * @interface IngredientFood
 */
export interface IngredientFood {
    /**
     * 
     * @type {number}
     * @memberof IngredientFood
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof IngredientFood
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof IngredientFood
     */
    plural_name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IngredientFood
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof IngredientFood
     */
    shopping?: string;
    /**
     * 
     * @type {FoodRecipe}
     * @memberof IngredientFood
     */
    recipe?: FoodRecipe | null;
    /**
     * 
     * @type {string}
     * @memberof IngredientFood
     */
    url?: string | null;
    /**
     * 
     * @type {Array<FoodProperties>}
     * @memberof IngredientFood
     */
    properties?: Array<FoodProperties> | null;
    /**
     * 
     * @type {string}
     * @memberof IngredientFood
     */
    properties_food_amount?: string;
    /**
     * 
     * @type {FoodPropertiesFoodUnit}
     * @memberof IngredientFood
     */
    properties_food_unit?: FoodPropertiesFoodUnit | null;
    /**
     * 
     * @type {number}
     * @memberof IngredientFood
     */
    fdc_id?: number | null;
    /**
     * 
     * @type {string}
     * @memberof IngredientFood
     */
    food_onhand?: string | null;
    /**
     * 
     * @type {FoodSupermarketCategory}
     * @memberof IngredientFood
     */
    supermarket_category?: FoodSupermarketCategory | null;
    /**
     * 
     * @type {string}
     * @memberof IngredientFood
     */
    parent?: string;
    /**
     * 
     * @type {number}
     * @memberof IngredientFood
     */
    numchild?: number;
    /**
     * 
     * @type {Array<FoodInheritFields>}
     * @memberof IngredientFood
     */
    inherit_fields?: Array<FoodInheritFields> | null;
    /**
     * 
     * @type {string}
     * @memberof IngredientFood
     */
    full_name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof IngredientFood
     */
    ignore_shopping?: boolean;
    /**
     * 
     * @type {Array<FoodSubstitute>}
     * @memberof IngredientFood
     */
    substitute?: Array<FoodSubstitute> | null;
    /**
     * 
     * @type {boolean}
     * @memberof IngredientFood
     */
    substitute_siblings?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof IngredientFood
     */
    substitute_children?: boolean;
    /**
     * 
     * @type {string}
     * @memberof IngredientFood
     */
    substitute_onhand?: string;
    /**
     * 
     * @type {Array<FoodInheritFields>}
     * @memberof IngredientFood
     */
    child_inherit_fields?: Array<FoodInheritFields> | null;
    /**
     * 
     * @type {string}
     * @memberof IngredientFood
     */
    open_data_slug?: string | null;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Automation>}
     * @memberof InlineResponse200
     */
    results?: Array<Automation>;
}
/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2001
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2001
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2001
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<CookLog>}
     * @memberof InlineResponse2001
     */
    results?: Array<CookLog>;
}
/**
 * 
 * @export
 * @interface InlineResponse20010
 */
export interface InlineResponse20010 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20010
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20010
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20010
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<SupermarketCategoryRelation>}
     * @memberof InlineResponse20010
     */
    results?: Array<SupermarketCategoryRelation>;
}
/**
 * 
 * @export
 * @interface InlineResponse20011
 */
export interface InlineResponse20011 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20011
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20011
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20011
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<SyncLog>}
     * @memberof InlineResponse20011
     */
    results?: Array<SyncLog>;
}
/**
 * 
 * @export
 * @interface InlineResponse20012
 */
export interface InlineResponse20012 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20012
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20012
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20012
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Unit>}
     * @memberof InlineResponse20012
     */
    results?: Array<Unit>;
}
/**
 * 
 * @export
 * @interface InlineResponse20013
 */
export interface InlineResponse20013 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20013
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20013
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20013
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<UserSpace>}
     * @memberof InlineResponse20013
     */
    results?: Array<UserSpace>;
}
/**
 * 
 * @export
 * @interface InlineResponse20014
 */
export interface InlineResponse20014 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20014
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20014
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20014
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<ViewLog>}
     * @memberof InlineResponse20014
     */
    results?: Array<ViewLog>;
}
/**
 * 
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2002
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<CustomFilter>}
     * @memberof InlineResponse2002
     */
    results?: Array<CustomFilter>;
}
/**
 * 
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2003
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Food>}
     * @memberof InlineResponse2003
     */
    results?: Array<Food>;
}
/**
 * 
 * @export
 * @interface InlineResponse2004
 */
export interface InlineResponse2004 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2004
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<ImportLog>}
     * @memberof InlineResponse2004
     */
    results?: Array<ImportLog>;
}
/**
 * 
 * @export
 * @interface InlineResponse2005
 */
export interface InlineResponse2005 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2005
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<ExportLog>}
     * @memberof InlineResponse2005
     */
    results?: Array<ExportLog>;
}
/**
 * 
 * @export
 * @interface InlineResponse2006
 */
export interface InlineResponse2006 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Ingredient>}
     * @memberof InlineResponse2006
     */
    results?: Array<Ingredient>;
}
/**
 * 
 * @export
 * @interface InlineResponse2007
 */
export interface InlineResponse2007 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2007
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2007
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2007
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Keyword>}
     * @memberof InlineResponse2007
     */
    results?: Array<Keyword>;
}
/**
 * 
 * @export
 * @interface InlineResponse2008
 */
export interface InlineResponse2008 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2008
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2008
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2008
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<RecipeOverview>}
     * @memberof InlineResponse2008
     */
    results?: Array<RecipeOverview>;
}
/**
 * 
 * @export
 * @interface InlineResponse2009
 */
export interface InlineResponse2009 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2009
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2009
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2009
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Step>}
     * @memberof InlineResponse2009
     */
    results?: Array<Step>;
}
/**
 * 
 * @export
 * @interface InviteLink
 */
export interface InviteLink {
    /**
     * 
     * @type {number}
     * @memberof InviteLink
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof InviteLink
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof InviteLink
     */
    email?: string;
    /**
     * 
     * @type {InviteLinkGroup}
     * @memberof InviteLink
     */
    group: InviteLinkGroup;
    /**
     * 
     * @type {string}
     * @memberof InviteLink
     */
    valid_until?: string;
    /**
     * 
     * @type {number}
     * @memberof InviteLink
     */
    used_by?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof InviteLink
     */
    reusable?: boolean;
    /**
     * 
     * @type {string}
     * @memberof InviteLink
     */
    internal_note?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InviteLink
     */
    created_by?: string;
    /**
     * 
     * @type {string}
     * @memberof InviteLink
     */
    created_at?: string;
}
/**
 * 
 * @export
 * @interface InviteLinkGroup
 */
export interface InviteLinkGroup {
    /**
     * 
     * @type {number}
     * @memberof InviteLinkGroup
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof InviteLinkGroup
     */
    name: string;
}
/**
 * 
 * @export
 * @interface Keyword
 */
export interface Keyword {
    /**
     * 
     * @type {number}
     * @memberof Keyword
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Keyword
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Keyword
     */
    label?: string;
    /**
     * 
     * @type {string}
     * @memberof Keyword
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof Keyword
     */
    parent?: string;
    /**
     * 
     * @type {number}
     * @memberof Keyword
     */
    numchild?: number;
    /**
     * 
     * @type {string}
     * @memberof Keyword
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof Keyword
     */
    updated_at?: string;
    /**
     * 
     * @type {string}
     * @memberof Keyword
     */
    full_name?: string;
}
/**
 * 
 * @export
 * @interface MealPlan
 */
export interface MealPlan {
    /**
     * 
     * @type {number}
     * @memberof MealPlan
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof MealPlan
     */
    title?: string;
    /**
     * 
     * @type {MealPlanRecipe}
     * @memberof MealPlan
     */
    recipe?: MealPlanRecipe | null;
    /**
     * 
     * @type {string}
     * @memberof MealPlan
     */
    servings: string;
    /**
     * 
     * @type {string}
     * @memberof MealPlan
     */
    note?: string;
    /**
     * 
     * @type {string}
     * @memberof MealPlan
     */
    note_markdown?: string;
    /**
     * 
     * @type {string}
     * @memberof MealPlan
     */
    from_date: string;
    /**
     * 
     * @type {string}
     * @memberof MealPlan
     */
    to_date?: string;
    /**
     * 
     * @type {MealPlanMealType}
     * @memberof MealPlan
     */
    meal_type: MealPlanMealType;
    /**
     * 
     * @type {string}
     * @memberof MealPlan
     */
    created_by?: string;
    /**
     * 
     * @type {Array<CustomFilterShared>}
     * @memberof MealPlan
     */
    shared?: Array<CustomFilterShared> | null;
    /**
     * 
     * @type {string}
     * @memberof MealPlan
     */
    recipe_name?: string;
    /**
     * 
     * @type {string}
     * @memberof MealPlan
     */
    meal_type_name?: string;
    /**
     * 
     * @type {string}
     * @memberof MealPlan
     */
    shopping?: string;
}
/**
 * 
 * @export
 * @interface MealPlanMealType
 */
export interface MealPlanMealType {
    /**
     * 
     * @type {number}
     * @memberof MealPlanMealType
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof MealPlanMealType
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof MealPlanMealType
     */
    order?: number;
    /**
     * 
     * @type {string}
     * @memberof MealPlanMealType
     */
    color?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof MealPlanMealType
     */
    _default?: boolean;
    /**
     * 
     * @type {string}
     * @memberof MealPlanMealType
     */
    created_by?: string;
}
/**
 * 
 * @export
 * @interface MealPlanRecipe
 */
export interface MealPlanRecipe {
    /**
     * 
     * @type {number}
     * @memberof MealPlanRecipe
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof MealPlanRecipe
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof MealPlanRecipe
     */
    description?: string | null;
    /**
     * 
     * @type {any}
     * @memberof MealPlanRecipe
     */
    image?: any | null;
    /**
     * 
     * @type {Array<MealPlanRecipeKeywords>}
     * @memberof MealPlanRecipe
     */
    keywords: Array<MealPlanRecipeKeywords>;
    /**
     * 
     * @type {number}
     * @memberof MealPlanRecipe
     */
    working_time?: number;
    /**
     * 
     * @type {number}
     * @memberof MealPlanRecipe
     */
    waiting_time?: number;
    /**
     * 
     * @type {string}
     * @memberof MealPlanRecipe
     */
    created_by?: string;
    /**
     * 
     * @type {string}
     * @memberof MealPlanRecipe
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof MealPlanRecipe
     */
    updated_at?: string;
    /**
     * 
     * @type {boolean}
     * @memberof MealPlanRecipe
     */
    internal?: boolean;
    /**
     * 
     * @type {number}
     * @memberof MealPlanRecipe
     */
    servings?: number;
    /**
     * 
     * @type {string}
     * @memberof MealPlanRecipe
     */
    servings_text?: string;
    /**
     * 
     * @type {string}
     * @memberof MealPlanRecipe
     */
    rating?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MealPlanRecipe
     */
    last_cooked?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MealPlanRecipe
     */
    _new?: string;
    /**
     * 
     * @type {string}
     * @memberof MealPlanRecipe
     */
    recent?: string;
}
/**
 * 
 * @export
 * @interface MealPlanRecipeKeywords
 */
export interface MealPlanRecipeKeywords {
    /**
     * 
     * @type {number}
     * @memberof MealPlanRecipeKeywords
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof MealPlanRecipeKeywords
     */
    label?: string;
}
/**
 * 
 * @export
 * @interface MealType
 */
export interface MealType {
    /**
     * 
     * @type {number}
     * @memberof MealType
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof MealType
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof MealType
     */
    order?: number;
    /**
     * 
     * @type {string}
     * @memberof MealType
     */
    color?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof MealType
     */
    _default?: boolean;
    /**
     * 
     * @type {string}
     * @memberof MealType
     */
    created_by?: string;
}
/**
 * 
 * @export
 * @interface Property
 */
export interface Property {
    /**
     * 
     * @type {number}
     * @memberof Property
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Property
     */
    property_amount: string | null;
    /**
     * 
     * @type {FoodPropertyType}
     * @memberof Property
     */
    property_type: FoodPropertyType;
}
/**
 * 
 * @export
 * @interface PropertyType
 */
export interface PropertyType {
    /**
     * 
     * @type {number}
     * @memberof PropertyType
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PropertyType
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyType
     */
    unit?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PropertyType
     */
    description?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PropertyType
     */
    order?: number;
    /**
     * 
     * @type {string}
     * @memberof PropertyType
     */
    open_data_slug?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PropertyType
     */
    fdc_id?: number | null;
}
/**
 * 
 * @export
 * @interface Recipe
 */
export interface Recipe {
    /**
     * 
     * @type {number}
     * @memberof Recipe
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Recipe
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Recipe
     */
    description?: string | null;
    /**
     * 
     * @type {any}
     * @memberof Recipe
     */
    image?: any | null;
    /**
     * 
     * @type {Array<RecipeKeywords>}
     * @memberof Recipe
     */
    keywords?: Array<RecipeKeywords>;
    /**
     * 
     * @type {Array<RecipeSteps>}
     * @memberof Recipe
     */
    steps: Array<RecipeSteps>;
    /**
     * 
     * @type {number}
     * @memberof Recipe
     */
    working_time?: number;
    /**
     * 
     * @type {number}
     * @memberof Recipe
     */
    waiting_time?: number;
    /**
     * 
     * @type {string}
     * @memberof Recipe
     */
    created_by?: string;
    /**
     * 
     * @type {string}
     * @memberof Recipe
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof Recipe
     */
    updated_at?: string;
    /**
     * 
     * @type {string}
     * @memberof Recipe
     */
    source_url?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Recipe
     */
    internal?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Recipe
     */
    show_ingredient_overview?: boolean;
    /**
     * 
     * @type {RecipeNutrition}
     * @memberof Recipe
     */
    nutrition?: RecipeNutrition | null;
    /**
     * 
     * @type {Array<FoodProperties>}
     * @memberof Recipe
     */
    properties?: Array<FoodProperties>;
    /**
     * 
     * @type {string}
     * @memberof Recipe
     */
    food_properties?: string;
    /**
     * 
     * @type {number}
     * @memberof Recipe
     */
    servings?: number;
    /**
     * 
     * @type {string}
     * @memberof Recipe
     */
    file_path?: string;
    /**
     * 
     * @type {string}
     * @memberof Recipe
     */
    servings_text?: string;
    /**
     * 
     * @type {string}
     * @memberof Recipe
     */
    rating?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Recipe
     */
    last_cooked?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Recipe
     */
    _private?: boolean;
    /**
     * 
     * @type {Array<CustomFilterShared>}
     * @memberof Recipe
     */
    shared?: Array<CustomFilterShared>;
}
/**
 * 
 * @export
 * @interface RecipeBook
 */
export interface RecipeBook {
    /**
     * 
     * @type {number}
     * @memberof RecipeBook
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof RecipeBook
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeBook
     */
    description?: string;
    /**
     * 
     * @type {Array<CustomFilterShared>}
     * @memberof RecipeBook
     */
    shared: Array<CustomFilterShared>;
    /**
     * 
     * @type {string}
     * @memberof RecipeBook
     */
    created_by?: string;
    /**
     * 
     * @type {RecipeBookFilter}
     * @memberof RecipeBook
     */
    filter?: RecipeBookFilter | null;
    /**
     * 
     * @type {number}
     * @memberof RecipeBook
     */
    order?: number;
}
/**
 * 
 * @export
 * @interface RecipeBookEntry
 */
export interface RecipeBookEntry {
    /**
     * 
     * @type {number}
     * @memberof RecipeBookEntry
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof RecipeBookEntry
     */
    book: number;
    /**
     * 
     * @type {string}
     * @memberof RecipeBookEntry
     */
    book_content?: string;
    /**
     * 
     * @type {number}
     * @memberof RecipeBookEntry
     */
    recipe: number;
    /**
     * 
     * @type {string}
     * @memberof RecipeBookEntry
     */
    recipe_content?: string;
}
/**
 * 
 * @export
 * @interface RecipeBookFilter
 */
export interface RecipeBookFilter {
    /**
     * 
     * @type {number}
     * @memberof RecipeBookFilter
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof RecipeBookFilter
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeBookFilter
     */
    search: string;
    /**
     * 
     * @type {Array<CustomFilterShared>}
     * @memberof RecipeBookFilter
     */
    shared?: Array<CustomFilterShared>;
    /**
     * 
     * @type {string}
     * @memberof RecipeBookFilter
     */
    created_by?: string;
}
/**
 * 
 * @export
 * @interface RecipeFile
 */
export interface RecipeFile {
    /**
     * 
     * @type {number}
     * @memberof RecipeFile
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof RecipeFile
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeFile
     */
    file_download?: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeFile
     */
    preview?: string;
}
/**
 * 
 * @export
 * @interface RecipeImage
 */
export interface RecipeImage {
    /**
     * 
     * @type {any}
     * @memberof RecipeImage
     */
    image?: any | null;
    /**
     * 
     * @type {string}
     * @memberof RecipeImage
     */
    image_url?: string | null;
}
/**
 * 
 * @export
 * @interface RecipeIngredients
 */
export interface RecipeIngredients {
    /**
     * 
     * @type {number}
     * @memberof RecipeIngredients
     */
    id?: number;
    /**
     * 
     * @type {IngredientFood}
     * @memberof RecipeIngredients
     */
    food: IngredientFood | null;
    /**
     * 
     * @type {FoodPropertiesFoodUnit}
     * @memberof RecipeIngredients
     */
    unit: FoodPropertiesFoodUnit | null;
    /**
     * 
     * @type {string}
     * @memberof RecipeIngredients
     */
    amount: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeIngredients
     */
    conversions?: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeIngredients
     */
    note?: string | null;
    /**
     * 
     * @type {number}
     * @memberof RecipeIngredients
     */
    order?: number;
    /**
     * 
     * @type {boolean}
     * @memberof RecipeIngredients
     */
    is_header?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RecipeIngredients
     */
    no_amount?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RecipeIngredients
     */
    original_text?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RecipeIngredients
     */
    used_in_recipes?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RecipeIngredients
     */
    always_use_plural_unit?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RecipeIngredients
     */
    always_use_plural_food?: boolean;
}
/**
 * 
 * @export
 * @interface RecipeKeywords
 */
export interface RecipeKeywords {
    /**
     * 
     * @type {number}
     * @memberof RecipeKeywords
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof RecipeKeywords
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeKeywords
     */
    label?: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeKeywords
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeKeywords
     */
    parent?: string;
    /**
     * 
     * @type {number}
     * @memberof RecipeKeywords
     */
    numchild?: number;
    /**
     * 
     * @type {string}
     * @memberof RecipeKeywords
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeKeywords
     */
    updated_at?: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeKeywords
     */
    full_name?: string;
}
/**
 * 
 * @export
 * @interface RecipeNutrition
 */
export interface RecipeNutrition {
    /**
     * 
     * @type {number}
     * @memberof RecipeNutrition
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof RecipeNutrition
     */
    carbohydrates: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeNutrition
     */
    fats: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeNutrition
     */
    proteins: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeNutrition
     */
    calories: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeNutrition
     */
    source?: string | null;
}
/**
 * 
 * @export
 * @interface RecipeOverview
 */
export interface RecipeOverview {
    /**
     * 
     * @type {number}
     * @memberof RecipeOverview
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof RecipeOverview
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeOverview
     */
    description?: string | null;
    /**
     * 
     * @type {any}
     * @memberof RecipeOverview
     */
    image?: any | null;
    /**
     * 
     * @type {Array<MealPlanRecipeKeywords>}
     * @memberof RecipeOverview
     */
    keywords: Array<MealPlanRecipeKeywords>;
    /**
     * 
     * @type {number}
     * @memberof RecipeOverview
     */
    working_time?: number;
    /**
     * 
     * @type {number}
     * @memberof RecipeOverview
     */
    waiting_time?: number;
    /**
     * 
     * @type {string}
     * @memberof RecipeOverview
     */
    created_by?: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeOverview
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeOverview
     */
    updated_at?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RecipeOverview
     */
    internal?: boolean;
    /**
     * 
     * @type {number}
     * @memberof RecipeOverview
     */
    servings?: number;
    /**
     * 
     * @type {string}
     * @memberof RecipeOverview
     */
    servings_text?: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeOverview
     */
    rating?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RecipeOverview
     */
    last_cooked?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RecipeOverview
     */
    _new?: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeOverview
     */
    recent?: string;
}
/**
 * 
 * @export
 * @interface RecipeShoppingUpdate
 */
export interface RecipeShoppingUpdate {
    /**
     * 
     * @type {number}
     * @memberof RecipeShoppingUpdate
     */
    id?: number;
    /**
     * Existing shopping list to update
     * @type {number}
     * @memberof RecipeShoppingUpdate
     */
    list_recipe?: number | null;
    /**
     * List of ingredient IDs from the recipe to add, if not provided all ingredients will be added.
     * @type {number}
     * @memberof RecipeShoppingUpdate
     */
    ingredients?: number | null;
    /**
     * Providing a list_recipe ID and servings of 0 will delete that shopping list.
     * @type {number}
     * @memberof RecipeShoppingUpdate
     */
    servings?: number | null;
}
/**
 * 
 * @export
 * @interface RecipeSimple
 */
export interface RecipeSimple {
    /**
     * 
     * @type {number}
     * @memberof RecipeSimple
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof RecipeSimple
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeSimple
     */
    url?: string;
}
/**
 * 
 * @export
 * @interface RecipeSteps
 */
export interface RecipeSteps {
    /**
     * 
     * @type {number}
     * @memberof RecipeSteps
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof RecipeSteps
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeSteps
     */
    instruction?: string;
    /**
     * 
     * @type {Array<RecipeIngredients>}
     * @memberof RecipeSteps
     */
    ingredients: Array<RecipeIngredients>;
    /**
     * 
     * @type {string}
     * @memberof RecipeSteps
     */
    instructions_markdown?: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeSteps
     */
    ingredients_vue?: string;
    /**
     * 
     * @type {number}
     * @memberof RecipeSteps
     */
    time?: number;
    /**
     * 
     * @type {number}
     * @memberof RecipeSteps
     */
    order?: number;
    /**
     * 
     * @type {boolean}
     * @memberof RecipeSteps
     */
    show_as_header?: boolean;
    /**
     * 
     * @type {RecipeFile}
     * @memberof RecipeSteps
     */
    file?: RecipeFile | null;
    /**
     * 
     * @type {number}
     * @memberof RecipeSteps
     */
    step_recipe?: number | null;
    /**
     * 
     * @type {string}
     * @memberof RecipeSteps
     */
    step_recipe_data?: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeSteps
     */
    numrecipe?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RecipeSteps
     */
    show_ingredients_table?: boolean;
}
/**
 * 
 * @export
 * @interface ShoppingList
 */
export interface ShoppingList {
    /**
     * 
     * @type {number}
     * @memberof ShoppingList
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ShoppingList
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof ShoppingList
     */
    note?: string | null;
    /**
     * 
     * @type {Array<ShoppingListRecipes>}
     * @memberof ShoppingList
     */
    recipes: Array<ShoppingListRecipes> | null;
    /**
     * 
     * @type {Array<ShoppingListEntries>}
     * @memberof ShoppingList
     */
    entries: Array<ShoppingListEntries> | null;
    /**
     * 
     * @type {Array<CustomFilterShared>}
     * @memberof ShoppingList
     */
    shared: Array<CustomFilterShared>;
    /**
     * 
     * @type {boolean}
     * @memberof ShoppingList
     */
    finished?: boolean;
    /**
     * 
     * @type {ShoppingListSupermarket}
     * @memberof ShoppingList
     */
    supermarket: ShoppingListSupermarket | null;
    /**
     * 
     * @type {string}
     * @memberof ShoppingList
     */
    created_by?: string;
    /**
     * 
     * @type {string}
     * @memberof ShoppingList
     */
    created_at?: string;
}
/**
 * 
 * @export
 * @interface ShoppingListCreatedBy
 */
export interface ShoppingListCreatedBy {
    /**
     * 
     * @type {number}
     * @memberof ShoppingListCreatedBy
     */
    id?: number;
    /**
     * Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.
     * @type {string}
     * @memberof ShoppingListCreatedBy
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListCreatedBy
     */
    first_name?: string;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListCreatedBy
     */
    last_name?: string;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListCreatedBy
     */
    display_name?: string;
}
/**
 * 
 * @export
 * @interface ShoppingListEntries
 */
export interface ShoppingListEntries {
    /**
     * 
     * @type {number}
     * @memberof ShoppingListEntries
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ShoppingListEntries
     */
    list_recipe?: number | null;
    /**
     * 
     * @type {IngredientFood}
     * @memberof ShoppingListEntries
     */
    food: IngredientFood | null;
    /**
     * 
     * @type {FoodPropertiesFoodUnit}
     * @memberof ShoppingListEntries
     */
    unit?: FoodPropertiesFoodUnit | null;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListEntries
     */
    amount: string;
    /**
     * 
     * @type {number}
     * @memberof ShoppingListEntries
     */
    order?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ShoppingListEntries
     */
    checked?: boolean;
    /**
     * 
     * @type {ShoppingListRecipeMealplan}
     * @memberof ShoppingListEntries
     */
    recipe_mealplan?: ShoppingListRecipeMealplan;
    /**
     * 
     * @type {ShoppingListCreatedBy}
     * @memberof ShoppingListEntries
     */
    created_by?: ShoppingListCreatedBy;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListEntries
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListEntries
     */
    updated_at?: string;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListEntries
     */
    completed_at?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListEntries
     */
    delay_until?: string | null;
}
/**
 * 
 * @export
 * @interface ShoppingListEntry
 */
export interface ShoppingListEntry {
    /**
     * 
     * @type {number}
     * @memberof ShoppingListEntry
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ShoppingListEntry
     */
    list_recipe?: number | null;
    /**
     * 
     * @type {IngredientFood}
     * @memberof ShoppingListEntry
     */
    food: IngredientFood | null;
    /**
     * 
     * @type {FoodPropertiesFoodUnit}
     * @memberof ShoppingListEntry
     */
    unit?: FoodPropertiesFoodUnit | null;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListEntry
     */
    amount: string;
    /**
     * 
     * @type {number}
     * @memberof ShoppingListEntry
     */
    order?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ShoppingListEntry
     */
    checked?: boolean;
    /**
     * 
     * @type {ShoppingListRecipeMealplan}
     * @memberof ShoppingListEntry
     */
    recipe_mealplan?: ShoppingListRecipeMealplan;
    /**
     * 
     * @type {ShoppingListCreatedBy}
     * @memberof ShoppingListEntry
     */
    created_by?: ShoppingListCreatedBy;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListEntry
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListEntry
     */
    updated_at?: string;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListEntry
     */
    completed_at?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListEntry
     */
    delay_until?: string | null;
}
/**
 * 
 * @export
 * @interface ShoppingListEntryBulk
 */
export interface ShoppingListEntryBulk {
    /**
     * 
     * @type {Array<any>}
     * @memberof ShoppingListEntryBulk
     */
    ids: Array<any>;
    /**
     * 
     * @type {boolean}
     * @memberof ShoppingListEntryBulk
     */
    checked: boolean;
}
/**
 * 
 * @export
 * @interface ShoppingListRecipe
 */
export interface ShoppingListRecipe {
    /**
     * 
     * @type {number}
     * @memberof ShoppingListRecipe
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListRecipe
     */
    recipe_name?: string;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListRecipe
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof ShoppingListRecipe
     */
    recipe?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ShoppingListRecipe
     */
    mealplan?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListRecipe
     */
    servings: string;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListRecipe
     */
    mealplan_note?: string;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListRecipe
     */
    mealplan_from_date?: string;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListRecipe
     */
    mealplan_type?: string;
}
/**
 * 
 * @export
 * @interface ShoppingListRecipeMealplan
 */
export interface ShoppingListRecipeMealplan {
    /**
     * 
     * @type {number}
     * @memberof ShoppingListRecipeMealplan
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListRecipeMealplan
     */
    recipe_name?: string;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListRecipeMealplan
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof ShoppingListRecipeMealplan
     */
    recipe?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ShoppingListRecipeMealplan
     */
    mealplan?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListRecipeMealplan
     */
    servings: string;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListRecipeMealplan
     */
    mealplan_note?: string;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListRecipeMealplan
     */
    mealplan_from_date?: string;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListRecipeMealplan
     */
    mealplan_type?: string;
}
/**
 * 
 * @export
 * @interface ShoppingListRecipes
 */
export interface ShoppingListRecipes {
    /**
     * 
     * @type {number}
     * @memberof ShoppingListRecipes
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListRecipes
     */
    recipe_name?: string;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListRecipes
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof ShoppingListRecipes
     */
    recipe?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ShoppingListRecipes
     */
    mealplan?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListRecipes
     */
    servings: string;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListRecipes
     */
    mealplan_note?: string;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListRecipes
     */
    mealplan_from_date?: string;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListRecipes
     */
    mealplan_type?: string;
}
/**
 * 
 * @export
 * @interface ShoppingListSupermarket
 */
export interface ShoppingListSupermarket {
    /**
     * 
     * @type {number}
     * @memberof ShoppingListSupermarket
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListSupermarket
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListSupermarket
     */
    description?: string | null;
    /**
     * 
     * @type {Array<ShoppingListSupermarketCategoryToSupermarket>}
     * @memberof ShoppingListSupermarket
     */
    category_to_supermarket?: Array<ShoppingListSupermarketCategoryToSupermarket>;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListSupermarket
     */
    open_data_slug?: string | null;
}
/**
 * 
 * @export
 * @interface ShoppingListSupermarketCategory
 */
export interface ShoppingListSupermarketCategory {
    /**
     * 
     * @type {number}
     * @memberof ShoppingListSupermarketCategory
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListSupermarketCategory
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListSupermarketCategory
     */
    description?: string | null;
}
/**
 * 
 * @export
 * @interface ShoppingListSupermarketCategoryToSupermarket
 */
export interface ShoppingListSupermarketCategoryToSupermarket {
    /**
     * 
     * @type {number}
     * @memberof ShoppingListSupermarketCategoryToSupermarket
     */
    id?: number;
    /**
     * 
     * @type {ShoppingListSupermarketCategory}
     * @memberof ShoppingListSupermarketCategoryToSupermarket
     */
    category: ShoppingListSupermarketCategory;
    /**
     * 
     * @type {number}
     * @memberof ShoppingListSupermarketCategoryToSupermarket
     */
    supermarket: number;
    /**
     * 
     * @type {number}
     * @memberof ShoppingListSupermarketCategoryToSupermarket
     */
    order?: number;
}
/**
 * 
 * @export
 * @interface Space
 */
export interface Space {
    /**
     * 
     * @type {number}
     * @memberof Space
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Space
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Space
     */
    created_by?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Space
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof Space
     */
    message?: string;
    /**
     * 
     * @type {number}
     * @memberof Space
     */
    max_recipes?: number;
    /**
     * Maximum file storage for space in MB. 0 for unlimited, -1 to disable file upload.
     * @type {number}
     * @memberof Space
     */
    max_file_storage_mb?: number;
    /**
     * 
     * @type {number}
     * @memberof Space
     */
    max_users?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Space
     */
    allow_sharing?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Space
     */
    demo?: boolean;
    /**
     * 
     * @type {Array<FoodInheritFields>}
     * @memberof Space
     */
    food_inherit: Array<FoodInheritFields>;
    /**
     * 
     * @type {string}
     * @memberof Space
     */
    user_count?: string;
    /**
     * 
     * @type {string}
     * @memberof Space
     */
    recipe_count?: string;
    /**
     * 
     * @type {string}
     * @memberof Space
     */
    file_size_mb?: string;
    /**
     * 
     * @type {RecipeFile}
     * @memberof Space
     */
    image?: RecipeFile | null;
    /**
     * 
     * @type {RecipeFile}
     * @memberof Space
     */
    nav_logo?: RecipeFile | null;
    /**
     * 
     * @type {string}
     * @memberof Space
     */
    space_theme?: SpaceSpaceThemeEnum;
    /**
     * 
     * @type {RecipeFile}
     * @memberof Space
     */
    custom_space_theme?: RecipeFile | null;
    /**
     * 
     * @type {string}
     * @memberof Space
     */
    nav_bg_color?: string;
    /**
     * 
     * @type {string}
     * @memberof Space
     */
    nav_text_color?: SpaceNavTextColorEnum;
    /**
     * 
     * @type {RecipeFile}
     * @memberof Space
     */
    logo_color_32?: RecipeFile | null;
    /**
     * 
     * @type {RecipeFile}
     * @memberof Space
     */
    logo_color_128?: RecipeFile | null;
    /**
     * 
     * @type {RecipeFile}
     * @memberof Space
     */
    logo_color_144?: RecipeFile | null;
    /**
     * 
     * @type {RecipeFile}
     * @memberof Space
     */
    logo_color_180?: RecipeFile | null;
    /**
     * 
     * @type {RecipeFile}
     * @memberof Space
     */
    logo_color_192?: RecipeFile | null;
    /**
     * 
     * @type {RecipeFile}
     * @memberof Space
     */
    logo_color_512?: RecipeFile | null;
    /**
     * 
     * @type {RecipeFile}
     * @memberof Space
     */
    logo_color_svg?: RecipeFile | null;
}

/**
    * @export
    * @enum {string}
    */
export enum SpaceSpaceThemeEnum {
    Blank = 'BLANK',
    Tandoor = 'TANDOOR',
    Bootstrap = 'BOOTSTRAP',
    Darkly = 'DARKLY',
    Flatly = 'FLATLY',
    Superhero = 'SUPERHERO',
    TandoorDark = 'TANDOOR_DARK'
}
/**
    * @export
    * @enum {string}
    */
export enum SpaceNavTextColorEnum {
    Blank = 'BLANK',
    Light = 'LIGHT',
    Dark = 'DARK'
}

/**
 * 
 * @export
 * @interface Step
 */
export interface Step {
    /**
     * 
     * @type {number}
     * @memberof Step
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Step
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Step
     */
    instruction?: string;
    /**
     * 
     * @type {Array<RecipeIngredients>}
     * @memberof Step
     */
    ingredients: Array<RecipeIngredients>;
    /**
     * 
     * @type {string}
     * @memberof Step
     */
    instructions_markdown?: string;
    /**
     * 
     * @type {string}
     * @memberof Step
     */
    ingredients_vue?: string;
    /**
     * 
     * @type {number}
     * @memberof Step
     */
    time?: number;
    /**
     * 
     * @type {number}
     * @memberof Step
     */
    order?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Step
     */
    show_as_header?: boolean;
    /**
     * 
     * @type {RecipeFile}
     * @memberof Step
     */
    file?: RecipeFile | null;
    /**
     * 
     * @type {number}
     * @memberof Step
     */
    step_recipe?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Step
     */
    step_recipe_data?: string;
    /**
     * 
     * @type {string}
     * @memberof Step
     */
    numrecipe?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Step
     */
    show_ingredients_table?: boolean;
}
/**
 * 
 * @export
 * @interface Storage
 */
export interface Storage {
    /**
     * 
     * @type {number}
     * @memberof Storage
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Storage
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Storage
     */
    method?: StorageMethodEnum;
    /**
     * 
     * @type {string}
     * @memberof Storage
     */
    username?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Storage
     */
    password?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Storage
     */
    token?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Storage
     */
    created_by?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum StorageMethodEnum {
    Db = 'DB',
    Nextcloud = 'NEXTCLOUD',
    Local = 'LOCAL'
}

/**
 * 
 * @export
 * @interface Supermarket
 */
export interface Supermarket {
    /**
     * 
     * @type {number}
     * @memberof Supermarket
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Supermarket
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Supermarket
     */
    description?: string | null;
    /**
     * 
     * @type {Array<ShoppingListSupermarketCategoryToSupermarket>}
     * @memberof Supermarket
     */
    category_to_supermarket?: Array<ShoppingListSupermarketCategoryToSupermarket>;
    /**
     * 
     * @type {string}
     * @memberof Supermarket
     */
    open_data_slug?: string | null;
}
/**
 * 
 * @export
 * @interface SupermarketCategory
 */
export interface SupermarketCategory {
    /**
     * 
     * @type {number}
     * @memberof SupermarketCategory
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof SupermarketCategory
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof SupermarketCategory
     */
    description?: string | null;
}
/**
 * 
 * @export
 * @interface SupermarketCategoryRelation
 */
export interface SupermarketCategoryRelation {
    /**
     * 
     * @type {number}
     * @memberof SupermarketCategoryRelation
     */
    id?: number;
    /**
     * 
     * @type {ShoppingListSupermarketCategory}
     * @memberof SupermarketCategoryRelation
     */
    category: ShoppingListSupermarketCategory;
    /**
     * 
     * @type {number}
     * @memberof SupermarketCategoryRelation
     */
    supermarket: number;
    /**
     * 
     * @type {number}
     * @memberof SupermarketCategoryRelation
     */
    order?: number;
}
/**
 * 
 * @export
 * @interface Sync
 */
export interface Sync {
    /**
     * 
     * @type {number}
     * @memberof Sync
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof Sync
     */
    storage: number;
    /**
     * 
     * @type {string}
     * @memberof Sync
     */
    path?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Sync
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Sync
     */
    last_checked?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Sync
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof Sync
     */
    updated_at?: string;
}
/**
 * 
 * @export
 * @interface SyncLog
 */
export interface SyncLog {
    /**
     * 
     * @type {number}
     * @memberof SyncLog
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof SyncLog
     */
    sync: number;
    /**
     * 
     * @type {string}
     * @memberof SyncLog
     */
    status: string;
    /**
     * 
     * @type {string}
     * @memberof SyncLog
     */
    msg?: string;
    /**
     * 
     * @type {string}
     * @memberof SyncLog
     */
    created_at?: string;
}
/**
 * 
 * @export
 * @interface Unit
 */
export interface Unit {
    /**
     * 
     * @type {number}
     * @memberof Unit
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Unit
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Unit
     */
    plural_name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Unit
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Unit
     */
    base_unit?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Unit
     */
    open_data_slug?: string | null;
}
/**
 * 
 * @export
 * @interface UnitConversion
 */
export interface UnitConversion {
    /**
     * 
     * @type {number}
     * @memberof UnitConversion
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof UnitConversion
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof UnitConversion
     */
    base_amount: string;
    /**
     * 
     * @type {UnitConversionBaseUnit}
     * @memberof UnitConversion
     */
    base_unit: UnitConversionBaseUnit;
    /**
     * 
     * @type {string}
     * @memberof UnitConversion
     */
    converted_amount: string;
    /**
     * 
     * @type {UnitConversionBaseUnit}
     * @memberof UnitConversion
     */
    converted_unit: UnitConversionBaseUnit;
    /**
     * 
     * @type {IngredientFood}
     * @memberof UnitConversion
     */
    food?: IngredientFood | null;
    /**
     * 
     * @type {string}
     * @memberof UnitConversion
     */
    open_data_slug?: string | null;
}
/**
 * 
 * @export
 * @interface UnitConversionBaseUnit
 */
export interface UnitConversionBaseUnit {
    /**
     * 
     * @type {number}
     * @memberof UnitConversionBaseUnit
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof UnitConversionBaseUnit
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof UnitConversionBaseUnit
     */
    plural_name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UnitConversionBaseUnit
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UnitConversionBaseUnit
     */
    base_unit?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UnitConversionBaseUnit
     */
    open_data_slug?: string | null;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    id?: number;
    /**
     * Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.
     * @type {string}
     * @memberof User
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    first_name?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    last_name?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    display_name?: string;
}
/**
 * 
 * @export
 * @interface UserFile
 */
export interface UserFile {
    /**
     * 
     * @type {number}
     * @memberof UserFile
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof UserFile
     */
    name: string;
    /**
     * 
     * @type {any}
     * @memberof UserFile
     */
    file: any;
    /**
     * 
     * @type {string}
     * @memberof UserFile
     */
    file_download?: string;
    /**
     * 
     * @type {string}
     * @memberof UserFile
     */
    preview?: string;
    /**
     * 
     * @type {number}
     * @memberof UserFile
     */
    file_size_kb?: number;
}
/**
 * 
 * @export
 * @interface UserPreference
 */
export interface UserPreference {
    /**
     * 
     * @type {number}
     * @memberof UserPreference
     */
    user: number;
    /**
     * 
     * @type {RecipeFile}
     * @memberof UserPreference
     */
    image?: RecipeFile | null;
    /**
     * 
     * @type {string}
     * @memberof UserPreference
     */
    theme?: UserPreferenceThemeEnum;
    /**
     * 
     * @type {string}
     * @memberof UserPreference
     */
    nav_bg_color?: string;
    /**
     * 
     * @type {string}
     * @memberof UserPreference
     */
    nav_text_color?: UserPreferenceNavTextColorEnum;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreference
     */
    nav_show_logo?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserPreference
     */
    default_unit?: string;
    /**
     * 
     * @type {string}
     * @memberof UserPreference
     */
    default_page?: UserPreferenceDefaultPageEnum;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreference
     */
    use_fractions?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreference
     */
    use_kj?: boolean;
    /**
     * 
     * @type {Array<CustomFilterShared>}
     * @memberof UserPreference
     */
    plan_share?: Array<CustomFilterShared> | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreference
     */
    nav_sticky?: boolean;
    /**
     * 
     * @type {number}
     * @memberof UserPreference
     */
    ingredient_decimals?: number;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreference
     */
    comments?: boolean;
    /**
     * 
     * @type {number}
     * @memberof UserPreference
     */
    shopping_auto_sync?: number;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreference
     */
    mealplan_autoadd_shopping?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserPreference
     */
    food_inherit_default?: string;
    /**
     * 
     * @type {string}
     * @memberof UserPreference
     */
    default_delay?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreference
     */
    mealplan_autoinclude_related?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreference
     */
    mealplan_autoexclude_onhand?: boolean;
    /**
     * 
     * @type {Array<CustomFilterShared>}
     * @memberof UserPreference
     */
    shopping_share?: Array<CustomFilterShared> | null;
    /**
     * 
     * @type {number}
     * @memberof UserPreference
     */
    shopping_recent_days?: number;
    /**
     * 
     * @type {string}
     * @memberof UserPreference
     */
    csv_delim?: string;
    /**
     * 
     * @type {string}
     * @memberof UserPreference
     */
    csv_prefix?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreference
     */
    filter_to_supermarket?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreference
     */
    shopping_add_onhand?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreference
     */
    left_handed?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreference
     */
    show_step_ingredients?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserPreference
     */
    food_children_exist?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum UserPreferenceThemeEnum {
    Tandoor = 'TANDOOR',
    Bootstrap = 'BOOTSTRAP',
    Darkly = 'DARKLY',
    Flatly = 'FLATLY',
    Superhero = 'SUPERHERO',
    TandoorDark = 'TANDOOR_DARK'
}
/**
    * @export
    * @enum {string}
    */
export enum UserPreferenceNavTextColorEnum {
    Light = 'LIGHT',
    Dark = 'DARK'
}
/**
    * @export
    * @enum {string}
    */
export enum UserPreferenceDefaultPageEnum {
    Search = 'SEARCH',
    Plan = 'PLAN',
    Books = 'BOOKS'
}

/**
 * 
 * @export
 * @interface UserSpace
 */
export interface UserSpace {
    /**
     * 
     * @type {number}
     * @memberof UserSpace
     */
    id?: number;
    /**
     * 
     * @type {ShoppingListCreatedBy}
     * @memberof UserSpace
     */
    user?: ShoppingListCreatedBy;
    /**
     * 
     * @type {string}
     * @memberof UserSpace
     */
    space?: string;
    /**
     * 
     * @type {Array<InviteLinkGroup>}
     * @memberof UserSpace
     */
    groups: Array<InviteLinkGroup>;
    /**
     * 
     * @type {boolean}
     * @memberof UserSpace
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserSpace
     */
    internal_note?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserSpace
     */
    invite_link?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserSpace
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSpace
     */
    updated_at?: string;
}
/**
 * 
 * @export
 * @interface ViewLog
 */
export interface ViewLog {
    /**
     * 
     * @type {number}
     * @memberof ViewLog
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ViewLog
     */
    recipe: number;
    /**
     * 
     * @type {string}
     * @memberof ViewLog
     */
    created_by?: string;
    /**
     * 
     * @type {string}
     * @memberof ViewLog
     */
    created_at?: string;
}

/**
 * ApiApi - axios parameter creator
 * @export
 */
export const ApiApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ShoppingListEntryBulk} [shoppingListEntryBulk] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkShoppingListEntry: async (shoppingListEntryBulk?: ShoppingListEntryBulk, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/shopping-list-entry/bulk/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shoppingListEntryBulk, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AccessToken} [accessToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccessToken: async (accessToken?: AccessToken, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/access-token/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accessToken, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAutoPlanViewSet: async (body?: any, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auto-plan/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Automation} [automation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAutomation: async (automation?: Automation, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/automation/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(automation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {BookmarkletImport} [bookmarkletImport] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBookmarkletImport: async (bookmarkletImport?: BookmarkletImport, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/bookmarklet-import/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bookmarkletImport, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CookLog} [cookLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCookLog: async (cookLog?: CookLog, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/cook-log/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cookLog, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CustomFilter} [customFilter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomFilter: async (customFilter?: CustomFilter, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/custom-filter/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customFilter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ExportLog} [exportLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExportLog: async (exportLog?: ExportLog, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/export-log/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(exportLog, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Food} [food] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFood: async (food?: Food, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/food/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(food, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ImportLog} [importLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createImportLog: async (importLog?: ImportLog, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/import-log/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(importLog, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Ingredient} [ingredient] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIngredient: async (ingredient?: Ingredient, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/ingredient/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ingredient, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {InviteLink} [inviteLink] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInviteLink: async (inviteLink?: InviteLink, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/invite-link/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inviteLink, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Keyword} [keyword] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKeyword: async (keyword?: Keyword, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/keyword/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(keyword, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {MealPlan} [mealPlan] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMealPlan: async (mealPlan?: MealPlan, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/meal-plan/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mealPlan, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {MealType} [mealType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMealType: async (mealType?: MealType, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/meal-type/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mealType, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Property} [property] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProperty: async (property?: Property, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/food-property/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(property, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PropertyType} [propertyType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyType: async (propertyType?: PropertyType, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/food-property-type/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(propertyType, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Recipe} [recipe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecipe: async (recipe?: Recipe, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/recipe/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recipe, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RecipeBook} [recipeBook] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecipeBook: async (recipeBook?: RecipeBook, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/recipe-book/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recipeBook, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RecipeBookEntry} [recipeBookEntry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecipeBookEntry: async (recipeBookEntry?: RecipeBookEntry, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/recipe-book-entry/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recipeBookEntry, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * function to retrieve a recipe from a given url or source string :param request: standard request with additional post parameters         - url: url to use for importing recipe         - data: if no url is given recipe is imported from provided source data         - (optional) bookmarklet: id of bookmarklet import to use, overrides URL and data attributes :return: JsonResponse containing the parsed json and images
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecipeUrlImport: async (body?: any, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/recipe-from-source/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ShoppingList} [shoppingList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShoppingList: async (shoppingList?: ShoppingList, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/shopping-list/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shoppingList, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ShoppingListEntry} [shoppingListEntry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShoppingListEntry: async (shoppingListEntry?: ShoppingListEntry, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/shopping-list-entry/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shoppingListEntry, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ShoppingListRecipe} [shoppingListRecipe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShoppingListRecipe: async (shoppingListRecipe?: ShoppingListRecipe, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/shopping-list-recipe/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shoppingListRecipe, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Step} [step] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStep: async (step?: Step, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/step/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(step, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Storage} [storage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStorage: async (storage?: Storage, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/storage/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storage, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Supermarket} [supermarket] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSupermarket: async (supermarket?: Supermarket, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/supermarket/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(supermarket, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SupermarketCategory} [supermarketCategory] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSupermarketCategory: async (supermarketCategory?: SupermarketCategory, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/supermarket-category/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(supermarketCategory, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SupermarketCategoryRelation} [supermarketCategoryRelation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSupermarketCategoryRelation: async (supermarketCategoryRelation?: SupermarketCategoryRelation, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/supermarket-category-relation/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(supermarketCategoryRelation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Sync} [sync] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSync: async (sync?: Sync, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sync/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sync, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Unit} [unit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUnit: async (unit?: Unit, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/unit/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(unit, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UnitConversion} [unitConversion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUnitConversion: async (unitConversion?: UnitConversion, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/unit-conversion/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(unitConversion, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {any} file 
         * @param {number} [id] 
         * @param {string} [fileDownload] 
         * @param {string} [preview] 
         * @param {number} [fileSizeKb] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserFile: async (name: string, file: any, id?: number, fileDownload?: string, preview?: string, fileSizeKb?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('createUserFile', 'name', name)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('createUserFile', 'file', file)
            const localVarPath = `/api/user-file/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (id !== undefined) { 
                localVarFormParams.append('id', id as any);
            }
    
            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (fileDownload !== undefined) { 
                localVarFormParams.append('file_download', fileDownload as any);
            }
    
            if (preview !== undefined) { 
                localVarFormParams.append('preview', preview as any);
            }
    
            if (fileSizeKb !== undefined) { 
                localVarFormParams.append('file_size_kb', fileSizeKb as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ViewLog} [viewLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createViewLog: async (viewLog?: ViewLog, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/view-log/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(viewLog, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * function to handle files passed by application importer
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createimportFiles: async (body?: any, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/import/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this access token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyAccessToken: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyAccessToken', 'id', id)
            const localVarPath = `/api/access-token/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this automation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyAutomation: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyAutomation', 'id', id)
            const localVarPath = `/api/automation/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this bookmarklet import.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyBookmarkletImport: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyBookmarkletImport', 'id', id)
            const localVarPath = `/api/bookmarklet-import/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this cook log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyCookLog: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyCookLog', 'id', id)
            const localVarPath = `/api/cook-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this custom filter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyCustomFilter: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyCustomFilter', 'id', id)
            const localVarPath = `/api/custom-filter/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this export log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyExportLog: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyExportLog', 'id', id)
            const localVarPath = `/api/export-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this food.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyFood: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyFood', 'id', id)
            const localVarPath = `/api/food/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this import log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyImportLog: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyImportLog', 'id', id)
            const localVarPath = `/api/import-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this ingredient.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyIngredient: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyIngredient', 'id', id)
            const localVarPath = `/api/ingredient/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this invite link.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyInviteLink: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyInviteLink', 'id', id)
            const localVarPath = `/api/invite-link/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this keyword.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyKeyword: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyKeyword', 'id', id)
            const localVarPath = `/api/keyword/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this meal plan.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyMealPlan: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyMealPlan', 'id', id)
            const localVarPath = `/api/meal-plan/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {string} id A unique integer value identifying this meal type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyMealType: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyMealType', 'id', id)
            const localVarPath = `/api/meal-type/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this property.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyProperty: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyProperty', 'id', id)
            const localVarPath = `/api/food-property/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this property type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyPropertyType: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyPropertyType', 'id', id)
            const localVarPath = `/api/food-property-type/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyRecipe: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyRecipe', 'id', id)
            const localVarPath = `/api/recipe/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this recipe book.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyRecipeBook: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyRecipeBook', 'id', id)
            const localVarPath = `/api/recipe-book/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this recipe book entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyRecipeBookEntry: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyRecipeBookEntry', 'id', id)
            const localVarPath = `/api/recipe-book-entry/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this shopping list.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyShoppingList: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyShoppingList', 'id', id)
            const localVarPath = `/api/shopping-list/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this shopping list entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyShoppingListEntry: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyShoppingListEntry', 'id', id)
            const localVarPath = `/api/shopping-list-entry/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this shopping list recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyShoppingListRecipe: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyShoppingListRecipe', 'id', id)
            const localVarPath = `/api/shopping-list-recipe/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this step.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyStep: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyStep', 'id', id)
            const localVarPath = `/api/step/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this storage.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyStorage: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyStorage', 'id', id)
            const localVarPath = `/api/storage/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this supermarket.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroySupermarket: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroySupermarket', 'id', id)
            const localVarPath = `/api/supermarket/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this supermarket category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroySupermarketCategory: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroySupermarketCategory', 'id', id)
            const localVarPath = `/api/supermarket-category/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this supermarket category relation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroySupermarketCategoryRelation: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroySupermarketCategoryRelation', 'id', id)
            const localVarPath = `/api/supermarket-category-relation/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this sync.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroySync: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroySync', 'id', id)
            const localVarPath = `/api/sync/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this unit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyUnit: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyUnit', 'id', id)
            const localVarPath = `/api/unit/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this unit conversion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyUnitConversion: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyUnitConversion', 'id', id)
            const localVarPath = `/api/unit-conversion/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this user file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyUserFile: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyUserFile', 'id', id)
            const localVarPath = `/api/user-file/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this user space.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyUserSpace: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyUserSpace', 'id', id)
            const localVarPath = `/api/user-space/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this view log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyViewLog: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyViewLog', 'id', id)
            const localVarPath = `/api/view-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * updates the food with all possible data from the FDC Api if properties with a fdc_id already exist they will be overridden, if existing properties don\'t have a fdc_id they won\'t be changed
         * @param {string} id A unique integer value identifying this food.
         * @param {Food} [food] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fdcFood: async (id: string, food?: Food, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('fdcFood', 'id', id)
            const localVarPath = `/api/food/{id}/fdc/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(food, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this recipe.
         * @param {any} [image] 
         * @param {string} [imageUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageRecipe: async (id: string, image?: any, imageUrl?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imageRecipe', 'id', id)
            const localVarPath = `/api/recipe/{id}/image/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
            if (imageUrl !== undefined) { 
                localVarFormParams.append('image_url', imageUrl as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccessTokens: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/access-token/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * optional parameters  - **automation_type**: Return the Automations matching the automation type.  Multiple values allowed.  *Automation Types:* - FS: Food Alias - UA: Unit Alias - KA: Keyword Alias - DR: Description Replace - IR: Instruction Replace - NU: Never Unit - TW: Transpose Words - FR: Food Replace - UR: Unit Replace - NR: Name Replace
         * @param {string} [automationType] Return the Automations matching the automation type.  Multiple values allowed.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAutomations: async (automationType?: string, page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/automation/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (automationType !== undefined) {
                localVarQueryParameter['automation_type'] = automationType;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBookmarkletImports: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/bookmarklet-import/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCookLogs: async (page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/cook-log/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCustomFilters: async (page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/custom-filter/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExportLogs: async (page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/export-log/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFoodInheritFields: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/food-inherit-field/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [query] Query string matched against food name.
         * @param {number} [root] Return first level children of food with ID [int].  Integer 0 will return root foods.
         * @param {number} [tree] Return all self and children of food with ID [int].
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFoods: async (query?: string, root?: number, tree?: number, page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/food/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (root !== undefined) {
                localVarQueryParameter['root'] = root;
            }

            if (tree !== undefined) {
                localVarQueryParameter['tree'] = tree;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroups: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/group/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listImportLogs: async (page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/import-log/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIngredients: async (page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/ingredient/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInviteLinks: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/invite-link/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [query] Query string matched against keyword name.
         * @param {number} [root] Return first level children of keyword with ID [int].  Integer 0 will return root keywords.
         * @param {number} [tree] Return all self and children of keyword with ID [int].
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listKeywords: async (query?: string, root?: number, tree?: number, page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/keyword/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (root !== undefined) {
                localVarQueryParameter['root'] = root;
            }

            if (tree !== undefined) {
                localVarQueryParameter['tree'] = tree;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * optional parameters  - **from_date**: filter from (inclusive) a certain date onward - **to_date**: filter upward to (inclusive) certain date - **meal_type**: filter meal plans based on meal_type ID
         * @param {string} [fromDate] Filter meal plans from date (inclusive) in the format of YYYY-MM-DD.
         * @param {string} [toDate] Filter meal plans to date (inclusive) in the format of YYYY-MM-DD.
         * @param {number} [mealType] Filter meal plans with MealType ID. For multiple repeat parameter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMealPlans: async (fromDate?: string, toDate?: string, mealType?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/meal-plan/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fromDate !== undefined) {
                localVarQueryParameter['from_date'] = fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['to_date'] = toDate;
            }

            if (mealType !== undefined) {
                localVarQueryParameter['meal_type'] = mealType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMealTypes: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/meal-type/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPropertyTypes: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/food-property-type/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPropertys: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/food-property/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * optional parameters  - **recipe**: id of recipe - only return books for that recipe - **book**: id of book - only return recipes in that book
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRecipeBookEntrys: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/recipe-book-entry/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRecipeBooks: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/recipe-book/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [query] Query string matched (fuzzy) against recipe name. In the future also fulltext search.
         * @param {number} [keywords] ID of keyword a recipe should have. For multiple repeat parameter. Equivalent to keywords_or
         * @param {number} [keywordsOr] Keyword IDs, repeat for multiple. Return recipes with any of the keywords
         * @param {number} [keywordsAnd] Keyword IDs, repeat for multiple. Return recipes with all of the keywords.
         * @param {number} [keywordsOrNot] Keyword IDs, repeat for multiple. Exclude recipes with any of the keywords.
         * @param {number} [keywordsAndNot] Keyword IDs, repeat for multiple. Exclude recipes with all of the keywords.
         * @param {number} [foods] ID of food a recipe should have. For multiple repeat parameter.
         * @param {number} [foodsOr] Food IDs, repeat for multiple. Return recipes with any of the foods
         * @param {number} [foodsAnd] Food IDs, repeat for multiple. Return recipes with all of the foods.
         * @param {number} [foodsOrNot] Food IDs, repeat for multiple. Exclude recipes with any of the foods.
         * @param {number} [foodsAndNot] Food IDs, repeat for multiple. Exclude recipes with all of the foods.
         * @param {number} [units] ID of unit a recipe should have.
         * @param {number} [rating] Rating a recipe should have or greater. [0 - 5] Negative value filters rating less than.
         * @param {string} [books] ID of book a recipe should be in. For multiple repeat parameter.
         * @param {number} [booksOr] Book IDs, repeat for multiple. Return recipes with any of the books
         * @param {number} [booksAnd] Book IDs, repeat for multiple. Return recipes with all of the books.
         * @param {number} [booksOrNot] Book IDs, repeat for multiple. Exclude recipes with any of the books.
         * @param {number} [booksAndNot] Book IDs, repeat for multiple. Exclude recipes with all of the books.
         * @param {string} [internal] If only internal recipes should be returned. [true/&lt;b&gt;false&lt;/b&gt;]
         * @param {string} [random] Returns the results in randomized order. [true/&lt;b&gt;false&lt;/b&gt;]
         * @param {string} [_new] Returns new results first in search results. [true/&lt;b&gt;false&lt;/b&gt;]
         * @param {number} [timescooked] Filter recipes cooked X times or more.  Negative values returns cooked less than X times
         * @param {string} [cookedon] Filter recipes last cooked on or after YYYY-MM-DD. Prepending - filters on or before date.
         * @param {string} [createdon] Filter recipes created on or after YYYY-MM-DD. Prepending - filters on or before date.
         * @param {string} [updatedon] Filter recipes updated on or after YYYY-MM-DD. Prepending - filters on or before date.
         * @param {string} [viewedon] Filter recipes lasts viewed on or after YYYY-MM-DD. Prepending - filters on or before date.
         * @param {string} [makenow] Filter recipes that can be made with OnHand food. [true/&lt;b&gt;false&lt;/b&gt;]
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRecipes: async (query?: string, keywords?: number, keywordsOr?: number, keywordsAnd?: number, keywordsOrNot?: number, keywordsAndNot?: number, foods?: number, foodsOr?: number, foodsAnd?: number, foodsOrNot?: number, foodsAndNot?: number, units?: number, rating?: number, books?: string, booksOr?: number, booksAnd?: number, booksOrNot?: number, booksAndNot?: number, internal?: string, random?: string, _new?: string, timescooked?: number, cookedon?: string, createdon?: string, updatedon?: string, viewedon?: string, makenow?: string, page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/recipe/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (keywords !== undefined) {
                localVarQueryParameter['keywords'] = keywords;
            }

            if (keywordsOr !== undefined) {
                localVarQueryParameter['keywords_or'] = keywordsOr;
            }

            if (keywordsAnd !== undefined) {
                localVarQueryParameter['keywords_and'] = keywordsAnd;
            }

            if (keywordsOrNot !== undefined) {
                localVarQueryParameter['keywords_or_not'] = keywordsOrNot;
            }

            if (keywordsAndNot !== undefined) {
                localVarQueryParameter['keywords_and_not'] = keywordsAndNot;
            }

            if (foods !== undefined) {
                localVarQueryParameter['foods'] = foods;
            }

            if (foodsOr !== undefined) {
                localVarQueryParameter['foods_or'] = foodsOr;
            }

            if (foodsAnd !== undefined) {
                localVarQueryParameter['foods_and'] = foodsAnd;
            }

            if (foodsOrNot !== undefined) {
                localVarQueryParameter['foods_or_not'] = foodsOrNot;
            }

            if (foodsAndNot !== undefined) {
                localVarQueryParameter['foods_and_not'] = foodsAndNot;
            }

            if (units !== undefined) {
                localVarQueryParameter['units'] = units;
            }

            if (rating !== undefined) {
                localVarQueryParameter['rating'] = rating;
            }

            if (books !== undefined) {
                localVarQueryParameter['books'] = books;
            }

            if (booksOr !== undefined) {
                localVarQueryParameter['books_or'] = booksOr;
            }

            if (booksAnd !== undefined) {
                localVarQueryParameter['books_and'] = booksAnd;
            }

            if (booksOrNot !== undefined) {
                localVarQueryParameter['books_or_not'] = booksOrNot;
            }

            if (booksAndNot !== undefined) {
                localVarQueryParameter['books_and_not'] = booksAndNot;
            }

            if (internal !== undefined) {
                localVarQueryParameter['internal'] = internal;
            }

            if (random !== undefined) {
                localVarQueryParameter['random'] = random;
            }

            if (_new !== undefined) {
                localVarQueryParameter['new'] = _new;
            }

            if (timescooked !== undefined) {
                localVarQueryParameter['timescooked'] = timescooked;
            }

            if (cookedon !== undefined) {
                localVarQueryParameter['cookedon'] = cookedon;
            }

            if (createdon !== undefined) {
                localVarQueryParameter['createdon'] = createdon;
            }

            if (updatedon !== undefined) {
                localVarQueryParameter['updatedon'] = updatedon;
            }

            if (viewedon !== undefined) {
                localVarQueryParameter['viewedon'] = viewedon;
            }

            if (makenow !== undefined) {
                localVarQueryParameter['makenow'] = makenow;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [id] Returns the shopping list entry with a primary key of id.  Multiple values allowed.
         * @param {string} [checked] Filter shopping list entries on checked.  [true, false, both, &lt;b&gt;recent&lt;/b&gt;]&lt;br&gt;                  - recent includes unchecked items and recently completed items.
         * @param {number} [supermarket] Returns the shopping list entries sorted by supermarket category order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listShoppingListEntrys: async (id?: number, checked?: string, supermarket?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/shopping-list-entry/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (checked !== undefined) {
                localVarQueryParameter['checked'] = checked;
            }

            if (supermarket !== undefined) {
                localVarQueryParameter['supermarket'] = supermarket;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listShoppingListRecipes: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/shopping-list-recipe/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listShoppingLists: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/shopping-list/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSpaces: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/space/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [recipe] ID of recipe a step is part of. For multiple repeat parameter.
         * @param {string} [query] Query string matched (fuzzy) against object name.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSteps: async (recipe?: number, query?: string, page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/step/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (recipe !== undefined) {
                localVarQueryParameter['recipe'] = recipe;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listStorages: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/storage/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSupermarketCategoryRelations: async (page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/supermarket-category-relation/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [query] Query string matched against supermarket-category name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSupermarketCategorys: async (query?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/supermarket-category/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [query] Query string matched against supermarket name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSupermarkets: async (query?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/supermarket/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSyncLogs: async (page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sync-log/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSyncs: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sync/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [foodId] ID of food to filter for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUnitConversions: async (foodId?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/unit-conversion/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (foodId !== undefined) {
                localVarQueryParameter['food_id'] = foodId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [query] Query string matched against unit name.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUnits: async (query?: string, page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/unit/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [query] Query string matched against user-file name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserFiles: async (query?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user-file/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserPreferences: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user-preference/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserSpaces: async (page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user-space/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * optional parameters  - **filter_list**: array of user id\'s to get names for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listViewLogs: async (page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/view-log/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * function to reset inheritance from api, see food method for docs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listresetFoodInheritances: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/reset-food-inheritance/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this food.
         * @param {string} target 
         * @param {Food} [food] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeFood: async (id: string, target: string, food?: Food, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('mergeFood', 'id', id)
            // verify required parameter 'target' is not null or undefined
            assertParamExists('mergeFood', 'target', target)
            const localVarPath = `/api/food/{id}/merge/{target}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"target"}}`, encodeURIComponent(String(target)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(food, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this keyword.
         * @param {string} target 
         * @param {Keyword} [keyword] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeKeyword: async (id: string, target: string, keyword?: Keyword, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('mergeKeyword', 'id', id)
            // verify required parameter 'target' is not null or undefined
            assertParamExists('mergeKeyword', 'target', target)
            const localVarPath = `/api/keyword/{id}/merge/{target}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"target"}}`, encodeURIComponent(String(target)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(keyword, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this supermarket category.
         * @param {string} target 
         * @param {SupermarketCategory} [supermarketCategory] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeSupermarketCategory: async (id: string, target: string, supermarketCategory?: SupermarketCategory, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('mergeSupermarketCategory', 'id', id)
            // verify required parameter 'target' is not null or undefined
            assertParamExists('mergeSupermarketCategory', 'target', target)
            const localVarPath = `/api/supermarket-category/{id}/merge/{target}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"target"}}`, encodeURIComponent(String(target)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(supermarketCategory, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this unit.
         * @param {string} target 
         * @param {Unit} [unit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeUnit: async (id: string, target: string, unit?: Unit, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('mergeUnit', 'id', id)
            // verify required parameter 'target' is not null or undefined
            assertParamExists('mergeUnit', 'target', target)
            const localVarPath = `/api/unit/{id}/merge/{target}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"target"}}`, encodeURIComponent(String(target)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(unit, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this food.
         * @param {string} parent 
         * @param {Food} [food] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveFood: async (id: string, parent: string, food?: Food, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('moveFood', 'id', id)
            // verify required parameter 'parent' is not null or undefined
            assertParamExists('moveFood', 'parent', parent)
            const localVarPath = `/api/food/{id}/move/{parent}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent"}}`, encodeURIComponent(String(parent)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(food, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this keyword.
         * @param {string} parent 
         * @param {Keyword} [keyword] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveKeyword: async (id: string, parent: string, keyword?: Keyword, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('moveKeyword', 'id', id)
            // verify required parameter 'parent' is not null or undefined
            assertParamExists('moveKeyword', 'parent', parent)
            const localVarPath = `/api/keyword/{id}/move/{parent}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent"}}`, encodeURIComponent(String(parent)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(keyword, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this access token.
         * @param {AccessToken} [accessToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateAccessToken: async (id: string, accessToken?: AccessToken, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateAccessToken', 'id', id)
            const localVarPath = `/api/access-token/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accessToken, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this automation.
         * @param {Automation} [automation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateAutomation: async (id: string, automation?: Automation, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateAutomation', 'id', id)
            const localVarPath = `/api/automation/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(automation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this bookmarklet import.
         * @param {BookmarkletImport} [bookmarkletImport] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateBookmarkletImport: async (id: string, bookmarkletImport?: BookmarkletImport, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateBookmarkletImport', 'id', id)
            const localVarPath = `/api/bookmarklet-import/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bookmarkletImport, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this cook log.
         * @param {CookLog} [cookLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateCookLog: async (id: string, cookLog?: CookLog, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateCookLog', 'id', id)
            const localVarPath = `/api/cook-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cookLog, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this custom filter.
         * @param {CustomFilter} [customFilter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateCustomFilter: async (id: string, customFilter?: CustomFilter, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateCustomFilter', 'id', id)
            const localVarPath = `/api/custom-filter/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customFilter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this export log.
         * @param {ExportLog} [exportLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateExportLog: async (id: string, exportLog?: ExportLog, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateExportLog', 'id', id)
            const localVarPath = `/api/export-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(exportLog, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this food.
         * @param {Food} [food] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateFood: async (id: string, food?: Food, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateFood', 'id', id)
            const localVarPath = `/api/food/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(food, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this import log.
         * @param {ImportLog} [importLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateImportLog: async (id: string, importLog?: ImportLog, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateImportLog', 'id', id)
            const localVarPath = `/api/import-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(importLog, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this ingredient.
         * @param {Ingredient} [ingredient] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateIngredient: async (id: string, ingredient?: Ingredient, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateIngredient', 'id', id)
            const localVarPath = `/api/ingredient/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ingredient, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this invite link.
         * @param {InviteLink} [inviteLink] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateInviteLink: async (id: string, inviteLink?: InviteLink, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateInviteLink', 'id', id)
            const localVarPath = `/api/invite-link/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inviteLink, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this keyword.
         * @param {Keyword} [keyword] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateKeyword: async (id: string, keyword?: Keyword, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateKeyword', 'id', id)
            const localVarPath = `/api/keyword/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(keyword, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this meal plan.
         * @param {MealPlan} [mealPlan] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateMealPlan: async (id: string, mealPlan?: MealPlan, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateMealPlan', 'id', id)
            const localVarPath = `/api/meal-plan/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mealPlan, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {string} id A unique integer value identifying this meal type.
         * @param {MealType} [mealType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateMealType: async (id: string, mealType?: MealType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateMealType', 'id', id)
            const localVarPath = `/api/meal-type/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mealType, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this property.
         * @param {Property} [property] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateProperty: async (id: string, property?: Property, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateProperty', 'id', id)
            const localVarPath = `/api/food-property/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(property, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this property type.
         * @param {PropertyType} [propertyType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdatePropertyType: async (id: string, propertyType?: PropertyType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdatePropertyType', 'id', id)
            const localVarPath = `/api/food-property-type/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(propertyType, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this recipe.
         * @param {Recipe} [recipe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateRecipe: async (id: string, recipe?: Recipe, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateRecipe', 'id', id)
            const localVarPath = `/api/recipe/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recipe, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this recipe book.
         * @param {RecipeBook} [recipeBook] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateRecipeBook: async (id: string, recipeBook?: RecipeBook, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateRecipeBook', 'id', id)
            const localVarPath = `/api/recipe-book/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recipeBook, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this recipe book entry.
         * @param {RecipeBookEntry} [recipeBookEntry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateRecipeBookEntry: async (id: string, recipeBookEntry?: RecipeBookEntry, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateRecipeBookEntry', 'id', id)
            const localVarPath = `/api/recipe-book-entry/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recipeBookEntry, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this shopping list.
         * @param {ShoppingList} [shoppingList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateShoppingList: async (id: string, shoppingList?: ShoppingList, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateShoppingList', 'id', id)
            const localVarPath = `/api/shopping-list/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shoppingList, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this shopping list entry.
         * @param {ShoppingListEntry} [shoppingListEntry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateShoppingListEntry: async (id: string, shoppingListEntry?: ShoppingListEntry, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateShoppingListEntry', 'id', id)
            const localVarPath = `/api/shopping-list-entry/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shoppingListEntry, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this shopping list recipe.
         * @param {ShoppingListRecipe} [shoppingListRecipe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateShoppingListRecipe: async (id: string, shoppingListRecipe?: ShoppingListRecipe, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateShoppingListRecipe', 'id', id)
            const localVarPath = `/api/shopping-list-recipe/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shoppingListRecipe, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this space.
         * @param {Space} [space] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateSpace: async (id: string, space?: Space, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateSpace', 'id', id)
            const localVarPath = `/api/space/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(space, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this step.
         * @param {Step} [step] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateStep: async (id: string, step?: Step, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateStep', 'id', id)
            const localVarPath = `/api/step/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(step, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this storage.
         * @param {Storage} [storage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateStorage: async (id: string, storage?: Storage, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateStorage', 'id', id)
            const localVarPath = `/api/storage/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storage, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this supermarket.
         * @param {Supermarket} [supermarket] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateSupermarket: async (id: string, supermarket?: Supermarket, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateSupermarket', 'id', id)
            const localVarPath = `/api/supermarket/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(supermarket, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this supermarket category.
         * @param {SupermarketCategory} [supermarketCategory] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateSupermarketCategory: async (id: string, supermarketCategory?: SupermarketCategory, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateSupermarketCategory', 'id', id)
            const localVarPath = `/api/supermarket-category/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(supermarketCategory, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this supermarket category relation.
         * @param {SupermarketCategoryRelation} [supermarketCategoryRelation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateSupermarketCategoryRelation: async (id: string, supermarketCategoryRelation?: SupermarketCategoryRelation, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateSupermarketCategoryRelation', 'id', id)
            const localVarPath = `/api/supermarket-category-relation/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(supermarketCategoryRelation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this sync.
         * @param {Sync} [sync] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateSync: async (id: string, sync?: Sync, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateSync', 'id', id)
            const localVarPath = `/api/sync/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sync, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this unit.
         * @param {Unit} [unit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateUnit: async (id: string, unit?: Unit, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateUnit', 'id', id)
            const localVarPath = `/api/unit/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(unit, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this unit conversion.
         * @param {UnitConversion} [unitConversion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateUnitConversion: async (id: string, unitConversion?: UnitConversion, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateUnitConversion', 'id', id)
            const localVarPath = `/api/unit-conversion/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(unitConversion, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this user.
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateUser: async (id: string, user?: User, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateUser', 'id', id)
            const localVarPath = `/api/user/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this user file.
         * @param {string} name 
         * @param {any} file 
         * @param {number} [id2] 
         * @param {string} [fileDownload] 
         * @param {string} [preview] 
         * @param {number} [fileSizeKb] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateUserFile: async (id: string, name: string, file: any, id2?: number, fileDownload?: string, preview?: string, fileSizeKb?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateUserFile', 'id', id)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('partialUpdateUserFile', 'name', name)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('partialUpdateUserFile', 'file', file)
            const localVarPath = `/api/user-file/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (id2 !== undefined) { 
                localVarFormParams.append('id', id2 as any);
            }
    
            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (fileDownload !== undefined) { 
                localVarFormParams.append('file_download', fileDownload as any);
            }
    
            if (preview !== undefined) { 
                localVarFormParams.append('preview', preview as any);
            }
    
            if (fileSizeKb !== undefined) { 
                localVarFormParams.append('file_size_kb', fileSizeKb as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} user A unique value identifying this user preference.
         * @param {UserPreference} [userPreference] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateUserPreference: async (user: string, userPreference?: UserPreference, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('partialUpdateUserPreference', 'user', user)
            const localVarPath = `/api/user-preference/{user}/`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userPreference, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this user space.
         * @param {UserSpace} [userSpace] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateUserSpace: async (id: string, userSpace?: UserSpace, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateUserSpace', 'id', id)
            const localVarPath = `/api/user-space/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userSpace, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this view log.
         * @param {ViewLog} [viewLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateViewLog: async (id: string, viewLog?: ViewLog, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateViewLog', 'id', id)
            const localVarPath = `/api/view-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(viewLog, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        relatedRecipe: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('relatedRecipe', 'id', id)
            const localVarPath = `/api/recipe/{id}/related/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this access token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAccessToken: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveAccessToken', 'id', id)
            const localVarPath = `/api/access-token/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this automation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAutomation: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveAutomation', 'id', id)
            const localVarPath = `/api/automation/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this bookmarklet import.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveBookmarkletImport: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveBookmarkletImport', 'id', id)
            const localVarPath = `/api/bookmarklet-import/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this cook log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveCookLog: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveCookLog', 'id', id)
            const localVarPath = `/api/cook-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this custom filter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveCustomFilter: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveCustomFilter', 'id', id)
            const localVarPath = `/api/custom-filter/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this export log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveExportLog: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveExportLog', 'id', id)
            const localVarPath = `/api/export-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this food.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveFood: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveFood', 'id', id)
            const localVarPath = `/api/food/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this food inherit field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveFoodInheritField: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveFoodInheritField', 'id', id)
            const localVarPath = `/api/food-inherit-field/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveGroup: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveGroup', 'id', id)
            const localVarPath = `/api/group/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this import log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveImportLog: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveImportLog', 'id', id)
            const localVarPath = `/api/import-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this ingredient.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveIngredient: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveIngredient', 'id', id)
            const localVarPath = `/api/ingredient/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this invite link.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveInviteLink: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveInviteLink', 'id', id)
            const localVarPath = `/api/invite-link/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this keyword.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveKeyword: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveKeyword', 'id', id)
            const localVarPath = `/api/keyword/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this meal plan.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveMealPlan: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveMealPlan', 'id', id)
            const localVarPath = `/api/meal-plan/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {string} id A unique integer value identifying this meal type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveMealType: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveMealType', 'id', id)
            const localVarPath = `/api/meal-type/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this property.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveProperty: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveProperty', 'id', id)
            const localVarPath = `/api/food-property/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this property type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrievePropertyType: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrievePropertyType', 'id', id)
            const localVarPath = `/api/food-property-type/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRecipe: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveRecipe', 'id', id)
            const localVarPath = `/api/recipe/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this recipe book.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRecipeBook: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveRecipeBook', 'id', id)
            const localVarPath = `/api/recipe-book/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this recipe book entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRecipeBookEntry: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveRecipeBookEntry', 'id', id)
            const localVarPath = `/api/recipe-book-entry/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this shopping list.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveShoppingList: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveShoppingList', 'id', id)
            const localVarPath = `/api/shopping-list/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this shopping list entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveShoppingListEntry: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveShoppingListEntry', 'id', id)
            const localVarPath = `/api/shopping-list-entry/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this shopping list recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveShoppingListRecipe: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveShoppingListRecipe', 'id', id)
            const localVarPath = `/api/shopping-list-recipe/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this space.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSpace: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveSpace', 'id', id)
            const localVarPath = `/api/space/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this step.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveStep: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveStep', 'id', id)
            const localVarPath = `/api/step/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this storage.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveStorage: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveStorage', 'id', id)
            const localVarPath = `/api/storage/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this supermarket.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSupermarket: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveSupermarket', 'id', id)
            const localVarPath = `/api/supermarket/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this supermarket category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSupermarketCategory: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveSupermarketCategory', 'id', id)
            const localVarPath = `/api/supermarket-category/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this supermarket category relation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSupermarketCategoryRelation: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveSupermarketCategoryRelation', 'id', id)
            const localVarPath = `/api/supermarket-category-relation/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this sync.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSync: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveSync', 'id', id)
            const localVarPath = `/api/sync/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this sync log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSyncLog: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveSyncLog', 'id', id)
            const localVarPath = `/api/sync-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this unit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUnit: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveUnit', 'id', id)
            const localVarPath = `/api/unit/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this unit conversion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUnitConversion: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveUnitConversion', 'id', id)
            const localVarPath = `/api/unit-conversion/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUser: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveUser', 'id', id)
            const localVarPath = `/api/user/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this user file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUserFile: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveUserFile', 'id', id)
            const localVarPath = `/api/user-file/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} user A unique value identifying this user preference.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUserPreference: async (user: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('retrieveUserPreference', 'user', user)
            const localVarPath = `/api/user-preference/{user}/`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this user space.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUserSpace: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveUserSpace', 'id', id)
            const localVarPath = `/api/user-space/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this view log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveViewLog: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveViewLog', 'id', id)
            const localVarPath = `/api/view-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * function to download a user file securely (wrapping as zip to prevent any context based XSS problems) temporary solution until a real file manager is implemented
         * @param {string} fileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrievedownloadFile: async (fileId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('retrievedownloadFile', 'fileId', fileId)
            const localVarPath = `/api/download-file/{file_id}/`
                .replace(`{${"file_id"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveshareLink: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveshareLink', 'id', id)
            const localVarPath = `/api/share-link/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * api endpoint to switch space function
         * @param {string} spaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveswitchActiveSpace: async (spaceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'spaceId' is not null or undefined
            assertParamExists('retrieveswitchActiveSpace', 'spaceId', spaceId)
            const localVarPath = `/api/switch-active-space/{space_id}/`
                .replace(`{${"space_id"}}`, encodeURIComponent(String(spaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this food.
         * @param {FoodShoppingUpdate} [foodShoppingUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shoppingFood: async (id: string, foodShoppingUpdate?: FoodShoppingUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('shoppingFood', 'id', id)
            const localVarPath = `/api/food/{id}/shopping/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(foodShoppingUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this recipe.
         * @param {RecipeShoppingUpdate} [recipeShoppingUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shoppingRecipe: async (id: string, recipeShoppingUpdate?: RecipeShoppingUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('shoppingRecipe', 'id', id)
            const localVarPath = `/api/recipe/{id}/shopping/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recipeShoppingUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this access token.
         * @param {AccessToken} [accessToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccessToken: async (id: string, accessToken?: AccessToken, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateAccessToken', 'id', id)
            const localVarPath = `/api/access-token/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accessToken, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this automation.
         * @param {Automation} [automation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAutomation: async (id: string, automation?: Automation, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateAutomation', 'id', id)
            const localVarPath = `/api/automation/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(automation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this bookmarklet import.
         * @param {BookmarkletImport} [bookmarkletImport] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBookmarkletImport: async (id: string, bookmarkletImport?: BookmarkletImport, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateBookmarkletImport', 'id', id)
            const localVarPath = `/api/bookmarklet-import/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bookmarkletImport, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this cook log.
         * @param {CookLog} [cookLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCookLog: async (id: string, cookLog?: CookLog, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateCookLog', 'id', id)
            const localVarPath = `/api/cook-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cookLog, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this custom filter.
         * @param {CustomFilter} [customFilter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomFilter: async (id: string, customFilter?: CustomFilter, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateCustomFilter', 'id', id)
            const localVarPath = `/api/custom-filter/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customFilter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this export log.
         * @param {ExportLog} [exportLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExportLog: async (id: string, exportLog?: ExportLog, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateExportLog', 'id', id)
            const localVarPath = `/api/export-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(exportLog, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this food.
         * @param {Food} [food] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFood: async (id: string, food?: Food, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateFood', 'id', id)
            const localVarPath = `/api/food/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(food, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this import log.
         * @param {ImportLog} [importLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateImportLog: async (id: string, importLog?: ImportLog, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateImportLog', 'id', id)
            const localVarPath = `/api/import-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(importLog, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this ingredient.
         * @param {Ingredient} [ingredient] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIngredient: async (id: string, ingredient?: Ingredient, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateIngredient', 'id', id)
            const localVarPath = `/api/ingredient/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ingredient, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this invite link.
         * @param {InviteLink} [inviteLink] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInviteLink: async (id: string, inviteLink?: InviteLink, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateInviteLink', 'id', id)
            const localVarPath = `/api/invite-link/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inviteLink, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this keyword.
         * @param {Keyword} [keyword] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKeyword: async (id: string, keyword?: Keyword, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateKeyword', 'id', id)
            const localVarPath = `/api/keyword/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(keyword, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this meal plan.
         * @param {MealPlan} [mealPlan] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMealPlan: async (id: string, mealPlan?: MealPlan, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateMealPlan', 'id', id)
            const localVarPath = `/api/meal-plan/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mealPlan, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {string} id A unique integer value identifying this meal type.
         * @param {MealType} [mealType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMealType: async (id: string, mealType?: MealType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateMealType', 'id', id)
            const localVarPath = `/api/meal-type/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mealType, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this property.
         * @param {Property} [property] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProperty: async (id: string, property?: Property, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateProperty', 'id', id)
            const localVarPath = `/api/food-property/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(property, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this property type.
         * @param {PropertyType} [propertyType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePropertyType: async (id: string, propertyType?: PropertyType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePropertyType', 'id', id)
            const localVarPath = `/api/food-property-type/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(propertyType, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this recipe.
         * @param {Recipe} [recipe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecipe: async (id: string, recipe?: Recipe, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateRecipe', 'id', id)
            const localVarPath = `/api/recipe/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recipe, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this recipe book.
         * @param {RecipeBook} [recipeBook] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecipeBook: async (id: string, recipeBook?: RecipeBook, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateRecipeBook', 'id', id)
            const localVarPath = `/api/recipe-book/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recipeBook, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this recipe book entry.
         * @param {RecipeBookEntry} [recipeBookEntry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecipeBookEntry: async (id: string, recipeBookEntry?: RecipeBookEntry, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateRecipeBookEntry', 'id', id)
            const localVarPath = `/api/recipe-book-entry/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recipeBookEntry, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this shopping list.
         * @param {ShoppingList} [shoppingList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShoppingList: async (id: string, shoppingList?: ShoppingList, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateShoppingList', 'id', id)
            const localVarPath = `/api/shopping-list/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shoppingList, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this shopping list entry.
         * @param {ShoppingListEntry} [shoppingListEntry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShoppingListEntry: async (id: string, shoppingListEntry?: ShoppingListEntry, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateShoppingListEntry', 'id', id)
            const localVarPath = `/api/shopping-list-entry/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shoppingListEntry, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this shopping list recipe.
         * @param {ShoppingListRecipe} [shoppingListRecipe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShoppingListRecipe: async (id: string, shoppingListRecipe?: ShoppingListRecipe, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateShoppingListRecipe', 'id', id)
            const localVarPath = `/api/shopping-list-recipe/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shoppingListRecipe, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this step.
         * @param {Step} [step] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStep: async (id: string, step?: Step, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateStep', 'id', id)
            const localVarPath = `/api/step/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(step, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this storage.
         * @param {Storage} [storage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStorage: async (id: string, storage?: Storage, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateStorage', 'id', id)
            const localVarPath = `/api/storage/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storage, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this supermarket.
         * @param {Supermarket} [supermarket] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSupermarket: async (id: string, supermarket?: Supermarket, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSupermarket', 'id', id)
            const localVarPath = `/api/supermarket/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(supermarket, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this supermarket category.
         * @param {SupermarketCategory} [supermarketCategory] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSupermarketCategory: async (id: string, supermarketCategory?: SupermarketCategory, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSupermarketCategory', 'id', id)
            const localVarPath = `/api/supermarket-category/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(supermarketCategory, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this supermarket category relation.
         * @param {SupermarketCategoryRelation} [supermarketCategoryRelation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSupermarketCategoryRelation: async (id: string, supermarketCategoryRelation?: SupermarketCategoryRelation, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSupermarketCategoryRelation', 'id', id)
            const localVarPath = `/api/supermarket-category-relation/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(supermarketCategoryRelation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this sync.
         * @param {Sync} [sync] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSync: async (id: string, sync?: Sync, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSync', 'id', id)
            const localVarPath = `/api/sync/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sync, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this unit.
         * @param {Unit} [unit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUnit: async (id: string, unit?: Unit, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUnit', 'id', id)
            const localVarPath = `/api/unit/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(unit, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this unit conversion.
         * @param {UnitConversion} [unitConversion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUnitConversion: async (id: string, unitConversion?: UnitConversion, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUnitConversion', 'id', id)
            const localVarPath = `/api/unit-conversion/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(unitConversion, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this user file.
         * @param {string} name 
         * @param {any} file 
         * @param {number} [id2] 
         * @param {string} [fileDownload] 
         * @param {string} [preview] 
         * @param {number} [fileSizeKb] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserFile: async (id: string, name: string, file: any, id2?: number, fileDownload?: string, preview?: string, fileSizeKb?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUserFile', 'id', id)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('updateUserFile', 'name', name)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('updateUserFile', 'file', file)
            const localVarPath = `/api/user-file/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (id2 !== undefined) { 
                localVarFormParams.append('id', id2 as any);
            }
    
            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (fileDownload !== undefined) { 
                localVarFormParams.append('file_download', fileDownload as any);
            }
    
            if (preview !== undefined) { 
                localVarFormParams.append('preview', preview as any);
            }
    
            if (fileSizeKb !== undefined) { 
                localVarFormParams.append('file_size_kb', fileSizeKb as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this view log.
         * @param {ViewLog} [viewLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateViewLog: async (id: string, viewLog?: ViewLog, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateViewLog', 'id', id)
            const localVarPath = `/api/view-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(viewLog, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApiApi - functional programming interface
 * @export
 */
export const ApiApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApiApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ShoppingListEntryBulk} [shoppingListEntryBulk] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkShoppingListEntry(shoppingListEntryBulk?: ShoppingListEntryBulk, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShoppingListEntryBulk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkShoppingListEntry(shoppingListEntryBulk, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {AccessToken} [accessToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAccessToken(accessToken?: AccessToken, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAccessToken(accessToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAutoPlanViewSet(body?: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAutoPlanViewSet(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Automation} [automation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAutomation(automation?: Automation, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Automation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAutomation(automation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {BookmarkletImport} [bookmarkletImport] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBookmarkletImport(bookmarkletImport?: BookmarkletImport, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BookmarkletImport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBookmarkletImport(bookmarkletImport, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CookLog} [cookLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCookLog(cookLog?: CookLog, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CookLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCookLog(cookLog, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CustomFilter} [customFilter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCustomFilter(customFilter?: CustomFilter, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomFilter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCustomFilter(customFilter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ExportLog} [exportLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createExportLog(exportLog?: ExportLog, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExportLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createExportLog(exportLog, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Food} [food] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFood(food?: Food, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Food>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFood(food, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ImportLog} [importLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createImportLog(importLog?: ImportLog, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createImportLog(importLog, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Ingredient} [ingredient] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createIngredient(ingredient?: Ingredient, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ingredient>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createIngredient(ingredient, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {InviteLink} [inviteLink] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInviteLink(inviteLink?: InviteLink, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InviteLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createInviteLink(inviteLink, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Keyword} [keyword] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createKeyword(keyword?: Keyword, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Keyword>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createKeyword(keyword, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {MealPlan} [mealPlan] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMealPlan(mealPlan?: MealPlan, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MealPlan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMealPlan(mealPlan, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {MealType} [mealType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMealType(mealType?: MealType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MealType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMealType(mealType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Property} [property] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProperty(property?: Property, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Property>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProperty(property, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {PropertyType} [propertyType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPropertyType(propertyType?: PropertyType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PropertyType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPropertyType(propertyType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Recipe} [recipe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRecipe(recipe?: Recipe, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Recipe>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRecipe(recipe, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {RecipeBook} [recipeBook] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRecipeBook(recipeBook?: RecipeBook, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecipeBook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRecipeBook(recipeBook, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {RecipeBookEntry} [recipeBookEntry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRecipeBookEntry(recipeBookEntry?: RecipeBookEntry, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecipeBookEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRecipeBookEntry(recipeBookEntry, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * function to retrieve a recipe from a given url or source string :param request: standard request with additional post parameters         - url: url to use for importing recipe         - data: if no url is given recipe is imported from provided source data         - (optional) bookmarklet: id of bookmarklet import to use, overrides URL and data attributes :return: JsonResponse containing the parsed json and images
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRecipeUrlImport(body?: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRecipeUrlImport(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ShoppingList} [shoppingList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createShoppingList(shoppingList?: ShoppingList, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShoppingList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createShoppingList(shoppingList, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ShoppingListEntry} [shoppingListEntry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createShoppingListEntry(shoppingListEntry?: ShoppingListEntry, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShoppingListEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createShoppingListEntry(shoppingListEntry, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ShoppingListRecipe} [shoppingListRecipe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createShoppingListRecipe(shoppingListRecipe?: ShoppingListRecipe, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShoppingListRecipe>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createShoppingListRecipe(shoppingListRecipe, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Step} [step] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createStep(step?: Step, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Step>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createStep(step, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Storage} [storage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createStorage(storage?: Storage, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Storage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createStorage(storage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Supermarket} [supermarket] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSupermarket(supermarket?: Supermarket, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Supermarket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSupermarket(supermarket, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SupermarketCategory} [supermarketCategory] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSupermarketCategory(supermarketCategory?: SupermarketCategory, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupermarketCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSupermarketCategory(supermarketCategory, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SupermarketCategoryRelation} [supermarketCategoryRelation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSupermarketCategoryRelation(supermarketCategoryRelation?: SupermarketCategoryRelation, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupermarketCategoryRelation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSupermarketCategoryRelation(supermarketCategoryRelation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Sync} [sync] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSync(sync?: Sync, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sync>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSync(sync, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Unit} [unit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUnit(unit?: Unit, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Unit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUnit(unit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {UnitConversion} [unitConversion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUnitConversion(unitConversion?: UnitConversion, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitConversion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUnitConversion(unitConversion, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} name 
         * @param {any} file 
         * @param {number} [id] 
         * @param {string} [fileDownload] 
         * @param {string} [preview] 
         * @param {number} [fileSizeKb] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserFile(name: string, file: any, id?: number, fileDownload?: string, preview?: string, fileSizeKb?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserFile(name, file, id, fileDownload, preview, fileSizeKb, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ViewLog} [viewLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createViewLog(viewLog?: ViewLog, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ViewLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createViewLog(viewLog, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * function to handle files passed by application importer
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createimportFiles(body?: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createimportFiles(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this access token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyAccessToken(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyAccessToken(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this automation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyAutomation(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyAutomation(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this bookmarklet import.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyBookmarkletImport(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyBookmarkletImport(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this cook log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyCookLog(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyCookLog(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this custom filter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyCustomFilter(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyCustomFilter(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this export log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyExportLog(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyExportLog(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this food.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyFood(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyFood(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this import log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyImportLog(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyImportLog(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this ingredient.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyIngredient(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyIngredient(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this invite link.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyInviteLink(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyInviteLink(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this keyword.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyKeyword(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyKeyword(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this meal plan.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyMealPlan(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyMealPlan(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {string} id A unique integer value identifying this meal type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyMealType(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyMealType(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this property.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyProperty(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyProperty(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this property type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyPropertyType(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyPropertyType(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyRecipe(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyRecipe(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this recipe book.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyRecipeBook(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyRecipeBook(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this recipe book entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyRecipeBookEntry(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyRecipeBookEntry(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this shopping list.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyShoppingList(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyShoppingList(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this shopping list entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyShoppingListEntry(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyShoppingListEntry(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this shopping list recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyShoppingListRecipe(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyShoppingListRecipe(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this step.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyStep(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyStep(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this storage.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyStorage(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyStorage(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this supermarket.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroySupermarket(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroySupermarket(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this supermarket category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroySupermarketCategory(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroySupermarketCategory(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this supermarket category relation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroySupermarketCategoryRelation(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroySupermarketCategoryRelation(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this sync.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroySync(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroySync(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this unit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyUnit(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyUnit(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this unit conversion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyUnitConversion(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyUnitConversion(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this user file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyUserFile(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyUserFile(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this user space.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyUserSpace(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyUserSpace(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this view log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyViewLog(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyViewLog(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * updates the food with all possible data from the FDC Api if properties with a fdc_id already exist they will be overridden, if existing properties don\'t have a fdc_id they won\'t be changed
         * @param {string} id A unique integer value identifying this food.
         * @param {Food} [food] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fdcFood(id: string, food?: Food, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Food>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fdcFood(id, food, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this recipe.
         * @param {any} [image] 
         * @param {string} [imageUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageRecipe(id: string, image?: any, imageUrl?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecipeImage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageRecipe(id, image, imageUrl, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAccessTokens(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccessToken>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAccessTokens(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * optional parameters  - **automation_type**: Return the Automations matching the automation type.  Multiple values allowed.  *Automation Types:* - FS: Food Alias - UA: Unit Alias - KA: Keyword Alias - DR: Description Replace - IR: Instruction Replace - NU: Never Unit - TW: Transpose Words - FR: Food Replace - UR: Unit Replace - NR: Name Replace
         * @param {string} [automationType] Return the Automations matching the automation type.  Multiple values allowed.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAutomations(automationType?: string, page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAutomations(automationType, page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBookmarkletImports(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BookmarkletImportList>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBookmarkletImports(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCookLogs(page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCookLogs(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCustomFilters(page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCustomFilters(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listExportLogs(page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2005>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listExportLogs(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFoodInheritFields(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FoodInheritField>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFoodInheritFields(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [query] Query string matched against food name.
         * @param {number} [root] Return first level children of food with ID [int].  Integer 0 will return root foods.
         * @param {number} [tree] Return all self and children of food with ID [int].
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFoods(query?: string, root?: number, tree?: number, page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFoods(query, root, tree, page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGroups(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Group>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGroups(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listImportLogs(page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listImportLogs(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listIngredients(page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2006>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listIngredients(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listInviteLinks(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InviteLink>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listInviteLinks(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [query] Query string matched against keyword name.
         * @param {number} [root] Return first level children of keyword with ID [int].  Integer 0 will return root keywords.
         * @param {number} [tree] Return all self and children of keyword with ID [int].
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listKeywords(query?: string, root?: number, tree?: number, page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2007>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listKeywords(query, root, tree, page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * optional parameters  - **from_date**: filter from (inclusive) a certain date onward - **to_date**: filter upward to (inclusive) certain date - **meal_type**: filter meal plans based on meal_type ID
         * @param {string} [fromDate] Filter meal plans from date (inclusive) in the format of YYYY-MM-DD.
         * @param {string} [toDate] Filter meal plans to date (inclusive) in the format of YYYY-MM-DD.
         * @param {number} [mealType] Filter meal plans with MealType ID. For multiple repeat parameter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMealPlans(fromDate?: string, toDate?: string, mealType?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MealPlan>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMealPlans(fromDate, toDate, mealType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMealTypes(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MealType>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMealTypes(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPropertyTypes(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PropertyType>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPropertyTypes(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPropertys(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Property>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPropertys(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * optional parameters  - **recipe**: id of recipe - only return books for that recipe - **book**: id of book - only return recipes in that book
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRecipeBookEntrys(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RecipeBookEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRecipeBookEntrys(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRecipeBooks(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RecipeBook>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRecipeBooks(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [query] Query string matched (fuzzy) against recipe name. In the future also fulltext search.
         * @param {number} [keywords] ID of keyword a recipe should have. For multiple repeat parameter. Equivalent to keywords_or
         * @param {number} [keywordsOr] Keyword IDs, repeat for multiple. Return recipes with any of the keywords
         * @param {number} [keywordsAnd] Keyword IDs, repeat for multiple. Return recipes with all of the keywords.
         * @param {number} [keywordsOrNot] Keyword IDs, repeat for multiple. Exclude recipes with any of the keywords.
         * @param {number} [keywordsAndNot] Keyword IDs, repeat for multiple. Exclude recipes with all of the keywords.
         * @param {number} [foods] ID of food a recipe should have. For multiple repeat parameter.
         * @param {number} [foodsOr] Food IDs, repeat for multiple. Return recipes with any of the foods
         * @param {number} [foodsAnd] Food IDs, repeat for multiple. Return recipes with all of the foods.
         * @param {number} [foodsOrNot] Food IDs, repeat for multiple. Exclude recipes with any of the foods.
         * @param {number} [foodsAndNot] Food IDs, repeat for multiple. Exclude recipes with all of the foods.
         * @param {number} [units] ID of unit a recipe should have.
         * @param {number} [rating] Rating a recipe should have or greater. [0 - 5] Negative value filters rating less than.
         * @param {string} [books] ID of book a recipe should be in. For multiple repeat parameter.
         * @param {number} [booksOr] Book IDs, repeat for multiple. Return recipes with any of the books
         * @param {number} [booksAnd] Book IDs, repeat for multiple. Return recipes with all of the books.
         * @param {number} [booksOrNot] Book IDs, repeat for multiple. Exclude recipes with any of the books.
         * @param {number} [booksAndNot] Book IDs, repeat for multiple. Exclude recipes with all of the books.
         * @param {string} [internal] If only internal recipes should be returned. [true/&lt;b&gt;false&lt;/b&gt;]
         * @param {string} [random] Returns the results in randomized order. [true/&lt;b&gt;false&lt;/b&gt;]
         * @param {string} [_new] Returns new results first in search results. [true/&lt;b&gt;false&lt;/b&gt;]
         * @param {number} [timescooked] Filter recipes cooked X times or more.  Negative values returns cooked less than X times
         * @param {string} [cookedon] Filter recipes last cooked on or after YYYY-MM-DD. Prepending - filters on or before date.
         * @param {string} [createdon] Filter recipes created on or after YYYY-MM-DD. Prepending - filters on or before date.
         * @param {string} [updatedon] Filter recipes updated on or after YYYY-MM-DD. Prepending - filters on or before date.
         * @param {string} [viewedon] Filter recipes lasts viewed on or after YYYY-MM-DD. Prepending - filters on or before date.
         * @param {string} [makenow] Filter recipes that can be made with OnHand food. [true/&lt;b&gt;false&lt;/b&gt;]
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRecipes(query?: string, keywords?: number, keywordsOr?: number, keywordsAnd?: number, keywordsOrNot?: number, keywordsAndNot?: number, foods?: number, foodsOr?: number, foodsAnd?: number, foodsOrNot?: number, foodsAndNot?: number, units?: number, rating?: number, books?: string, booksOr?: number, booksAnd?: number, booksOrNot?: number, booksAndNot?: number, internal?: string, random?: string, _new?: string, timescooked?: number, cookedon?: string, createdon?: string, updatedon?: string, viewedon?: string, makenow?: string, page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2008>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRecipes(query, keywords, keywordsOr, keywordsAnd, keywordsOrNot, keywordsAndNot, foods, foodsOr, foodsAnd, foodsOrNot, foodsAndNot, units, rating, books, booksOr, booksAnd, booksOrNot, booksAndNot, internal, random, _new, timescooked, cookedon, createdon, updatedon, viewedon, makenow, page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [id] Returns the shopping list entry with a primary key of id.  Multiple values allowed.
         * @param {string} [checked] Filter shopping list entries on checked.  [true, false, both, &lt;b&gt;recent&lt;/b&gt;]&lt;br&gt;                  - recent includes unchecked items and recently completed items.
         * @param {number} [supermarket] Returns the shopping list entries sorted by supermarket category order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listShoppingListEntrys(id?: number, checked?: string, supermarket?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ShoppingListEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listShoppingListEntrys(id, checked, supermarket, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listShoppingListRecipes(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ShoppingListRecipe>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listShoppingListRecipes(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listShoppingLists(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ShoppingList>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listShoppingLists(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSpaces(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Space>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSpaces(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [recipe] ID of recipe a step is part of. For multiple repeat parameter.
         * @param {string} [query] Query string matched (fuzzy) against object name.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSteps(recipe?: number, query?: string, page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2009>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSteps(recipe, query, page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listStorages(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Storage>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listStorages(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSupermarketCategoryRelations(page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20010>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSupermarketCategoryRelations(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [query] Query string matched against supermarket-category name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSupermarketCategorys(query?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SupermarketCategory>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSupermarketCategorys(query, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [query] Query string matched against supermarket name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSupermarkets(query?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Supermarket>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSupermarkets(query, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSyncLogs(page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20011>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSyncLogs(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSyncs(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Sync>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSyncs(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [foodId] ID of food to filter for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUnitConversions(foodId?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UnitConversion>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUnitConversions(foodId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [query] Query string matched against unit name.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUnits(query?: string, page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20012>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUnits(query, page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [query] Query string matched against user-file name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserFiles(query?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserFile>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserFiles(query, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserPreferences(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserPreference>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserPreferences(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserSpaces(page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20013>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserSpaces(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * optional parameters  - **filter_list**: array of user id\'s to get names for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUsers(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUsers(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listViewLogs(page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20014>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listViewLogs(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * function to reset inheritance from api, see food method for docs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listresetFoodInheritances(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<any>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listresetFoodInheritances(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this food.
         * @param {string} target 
         * @param {Food} [food] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mergeFood(id: string, target: string, food?: Food, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Food>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mergeFood(id, target, food, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this keyword.
         * @param {string} target 
         * @param {Keyword} [keyword] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mergeKeyword(id: string, target: string, keyword?: Keyword, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Keyword>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mergeKeyword(id, target, keyword, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this supermarket category.
         * @param {string} target 
         * @param {SupermarketCategory} [supermarketCategory] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mergeSupermarketCategory(id: string, target: string, supermarketCategory?: SupermarketCategory, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupermarketCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mergeSupermarketCategory(id, target, supermarketCategory, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this unit.
         * @param {string} target 
         * @param {Unit} [unit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mergeUnit(id: string, target: string, unit?: Unit, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Unit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mergeUnit(id, target, unit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this food.
         * @param {string} parent 
         * @param {Food} [food] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moveFood(id: string, parent: string, food?: Food, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Food>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moveFood(id, parent, food, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this keyword.
         * @param {string} parent 
         * @param {Keyword} [keyword] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moveKeyword(id: string, parent: string, keyword?: Keyword, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Keyword>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moveKeyword(id, parent, keyword, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this access token.
         * @param {AccessToken} [accessToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateAccessToken(id: string, accessToken?: AccessToken, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateAccessToken(id, accessToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this automation.
         * @param {Automation} [automation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateAutomation(id: string, automation?: Automation, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Automation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateAutomation(id, automation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this bookmarklet import.
         * @param {BookmarkletImport} [bookmarkletImport] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateBookmarkletImport(id: string, bookmarkletImport?: BookmarkletImport, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BookmarkletImport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateBookmarkletImport(id, bookmarkletImport, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this cook log.
         * @param {CookLog} [cookLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateCookLog(id: string, cookLog?: CookLog, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CookLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateCookLog(id, cookLog, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this custom filter.
         * @param {CustomFilter} [customFilter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateCustomFilter(id: string, customFilter?: CustomFilter, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomFilter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateCustomFilter(id, customFilter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this export log.
         * @param {ExportLog} [exportLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateExportLog(id: string, exportLog?: ExportLog, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExportLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateExportLog(id, exportLog, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this food.
         * @param {Food} [food] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateFood(id: string, food?: Food, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Food>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateFood(id, food, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this import log.
         * @param {ImportLog} [importLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateImportLog(id: string, importLog?: ImportLog, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateImportLog(id, importLog, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this ingredient.
         * @param {Ingredient} [ingredient] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateIngredient(id: string, ingredient?: Ingredient, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ingredient>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateIngredient(id, ingredient, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this invite link.
         * @param {InviteLink} [inviteLink] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateInviteLink(id: string, inviteLink?: InviteLink, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InviteLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateInviteLink(id, inviteLink, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this keyword.
         * @param {Keyword} [keyword] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateKeyword(id: string, keyword?: Keyword, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Keyword>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateKeyword(id, keyword, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this meal plan.
         * @param {MealPlan} [mealPlan] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateMealPlan(id: string, mealPlan?: MealPlan, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MealPlan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateMealPlan(id, mealPlan, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {string} id A unique integer value identifying this meal type.
         * @param {MealType} [mealType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateMealType(id: string, mealType?: MealType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MealType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateMealType(id, mealType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this property.
         * @param {Property} [property] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateProperty(id: string, property?: Property, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Property>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateProperty(id, property, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this property type.
         * @param {PropertyType} [propertyType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdatePropertyType(id: string, propertyType?: PropertyType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PropertyType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdatePropertyType(id, propertyType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this recipe.
         * @param {Recipe} [recipe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateRecipe(id: string, recipe?: Recipe, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Recipe>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateRecipe(id, recipe, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this recipe book.
         * @param {RecipeBook} [recipeBook] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateRecipeBook(id: string, recipeBook?: RecipeBook, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecipeBook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateRecipeBook(id, recipeBook, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this recipe book entry.
         * @param {RecipeBookEntry} [recipeBookEntry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateRecipeBookEntry(id: string, recipeBookEntry?: RecipeBookEntry, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecipeBookEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateRecipeBookEntry(id, recipeBookEntry, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this shopping list.
         * @param {ShoppingList} [shoppingList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateShoppingList(id: string, shoppingList?: ShoppingList, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShoppingList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateShoppingList(id, shoppingList, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this shopping list entry.
         * @param {ShoppingListEntry} [shoppingListEntry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateShoppingListEntry(id: string, shoppingListEntry?: ShoppingListEntry, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShoppingListEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateShoppingListEntry(id, shoppingListEntry, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this shopping list recipe.
         * @param {ShoppingListRecipe} [shoppingListRecipe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateShoppingListRecipe(id: string, shoppingListRecipe?: ShoppingListRecipe, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShoppingListRecipe>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateShoppingListRecipe(id, shoppingListRecipe, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this space.
         * @param {Space} [space] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateSpace(id: string, space?: Space, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Space>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateSpace(id, space, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this step.
         * @param {Step} [step] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateStep(id: string, step?: Step, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Step>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateStep(id, step, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this storage.
         * @param {Storage} [storage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateStorage(id: string, storage?: Storage, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Storage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateStorage(id, storage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this supermarket.
         * @param {Supermarket} [supermarket] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateSupermarket(id: string, supermarket?: Supermarket, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Supermarket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateSupermarket(id, supermarket, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this supermarket category.
         * @param {SupermarketCategory} [supermarketCategory] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateSupermarketCategory(id: string, supermarketCategory?: SupermarketCategory, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupermarketCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateSupermarketCategory(id, supermarketCategory, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this supermarket category relation.
         * @param {SupermarketCategoryRelation} [supermarketCategoryRelation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateSupermarketCategoryRelation(id: string, supermarketCategoryRelation?: SupermarketCategoryRelation, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupermarketCategoryRelation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateSupermarketCategoryRelation(id, supermarketCategoryRelation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this sync.
         * @param {Sync} [sync] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateSync(id: string, sync?: Sync, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sync>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateSync(id, sync, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this unit.
         * @param {Unit} [unit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateUnit(id: string, unit?: Unit, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Unit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateUnit(id, unit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this unit conversion.
         * @param {UnitConversion} [unitConversion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateUnitConversion(id: string, unitConversion?: UnitConversion, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitConversion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateUnitConversion(id, unitConversion, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this user.
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateUser(id: string, user?: User, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateUser(id, user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this user file.
         * @param {string} name 
         * @param {any} file 
         * @param {number} [id2] 
         * @param {string} [fileDownload] 
         * @param {string} [preview] 
         * @param {number} [fileSizeKb] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateUserFile(id: string, name: string, file: any, id2?: number, fileDownload?: string, preview?: string, fileSizeKb?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateUserFile(id, name, file, id2, fileDownload, preview, fileSizeKb, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} user A unique value identifying this user preference.
         * @param {UserPreference} [userPreference] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateUserPreference(user: string, userPreference?: UserPreference, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPreference>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateUserPreference(user, userPreference, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this user space.
         * @param {UserSpace} [userSpace] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateUserSpace(id: string, userSpace?: UserSpace, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSpace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateUserSpace(id, userSpace, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this view log.
         * @param {ViewLog} [viewLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateViewLog(id: string, viewLog?: ViewLog, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ViewLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateViewLog(id, viewLog, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async relatedRecipe(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecipeSimple>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.relatedRecipe(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this access token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveAccessToken(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveAccessToken(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this automation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveAutomation(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Automation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveAutomation(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this bookmarklet import.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveBookmarkletImport(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BookmarkletImport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveBookmarkletImport(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this cook log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveCookLog(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CookLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveCookLog(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this custom filter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveCustomFilter(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomFilter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveCustomFilter(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this export log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveExportLog(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExportLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveExportLog(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this food.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveFood(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Food>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveFood(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this food inherit field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveFoodInheritField(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FoodInheritField>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveFoodInheritField(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveGroup(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveGroup(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this import log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveImportLog(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveImportLog(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this ingredient.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveIngredient(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ingredient>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveIngredient(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this invite link.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveInviteLink(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InviteLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveInviteLink(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this keyword.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveKeyword(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Keyword>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveKeyword(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this meal plan.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveMealPlan(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MealPlan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveMealPlan(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {string} id A unique integer value identifying this meal type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveMealType(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MealType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveMealType(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this property.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveProperty(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Property>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveProperty(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this property type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrievePropertyType(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PropertyType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrievePropertyType(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveRecipe(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Recipe>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveRecipe(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this recipe book.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveRecipeBook(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecipeBook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveRecipeBook(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this recipe book entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveRecipeBookEntry(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecipeBookEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveRecipeBookEntry(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this shopping list.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveShoppingList(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShoppingList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveShoppingList(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this shopping list entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveShoppingListEntry(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShoppingListEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveShoppingListEntry(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this shopping list recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveShoppingListRecipe(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShoppingListRecipe>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveShoppingListRecipe(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this space.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveSpace(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Space>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveSpace(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this step.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveStep(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Step>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveStep(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this storage.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveStorage(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Storage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveStorage(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this supermarket.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveSupermarket(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Supermarket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveSupermarket(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this supermarket category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveSupermarketCategory(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupermarketCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveSupermarketCategory(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this supermarket category relation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveSupermarketCategoryRelation(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupermarketCategoryRelation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveSupermarketCategoryRelation(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this sync.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveSync(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sync>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveSync(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this sync log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveSyncLog(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SyncLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveSyncLog(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this unit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveUnit(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Unit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveUnit(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this unit conversion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveUnitConversion(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitConversion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveUnitConversion(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveUser(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveUser(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this user file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveUserFile(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveUserFile(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} user A unique value identifying this user preference.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveUserPreference(user: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPreference>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveUserPreference(user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this user space.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveUserSpace(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSpace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveUserSpace(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this view log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveViewLog(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ViewLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveViewLog(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * function to download a user file securely (wrapping as zip to prevent any context based XSS problems) temporary solution until a real file manager is implemented
         * @param {string} fileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrievedownloadFile(fileId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrievedownloadFile(fileId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveshareLink(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveshareLink(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * api endpoint to switch space function
         * @param {string} spaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveswitchActiveSpace(spaceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveswitchActiveSpace(spaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this food.
         * @param {FoodShoppingUpdate} [foodShoppingUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shoppingFood(id: string, foodShoppingUpdate?: FoodShoppingUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FoodShoppingUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shoppingFood(id, foodShoppingUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this recipe.
         * @param {RecipeShoppingUpdate} [recipeShoppingUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shoppingRecipe(id: string, recipeShoppingUpdate?: RecipeShoppingUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecipeShoppingUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shoppingRecipe(id, recipeShoppingUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this access token.
         * @param {AccessToken} [accessToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAccessToken(id: string, accessToken?: AccessToken, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAccessToken(id, accessToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this automation.
         * @param {Automation} [automation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAutomation(id: string, automation?: Automation, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Automation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAutomation(id, automation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this bookmarklet import.
         * @param {BookmarkletImport} [bookmarkletImport] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBookmarkletImport(id: string, bookmarkletImport?: BookmarkletImport, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BookmarkletImport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBookmarkletImport(id, bookmarkletImport, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this cook log.
         * @param {CookLog} [cookLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCookLog(id: string, cookLog?: CookLog, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CookLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCookLog(id, cookLog, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this custom filter.
         * @param {CustomFilter} [customFilter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCustomFilter(id: string, customFilter?: CustomFilter, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomFilter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCustomFilter(id, customFilter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this export log.
         * @param {ExportLog} [exportLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateExportLog(id: string, exportLog?: ExportLog, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExportLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateExportLog(id, exportLog, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this food.
         * @param {Food} [food] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFood(id: string, food?: Food, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Food>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFood(id, food, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this import log.
         * @param {ImportLog} [importLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateImportLog(id: string, importLog?: ImportLog, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateImportLog(id, importLog, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this ingredient.
         * @param {Ingredient} [ingredient] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateIngredient(id: string, ingredient?: Ingredient, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ingredient>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateIngredient(id, ingredient, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this invite link.
         * @param {InviteLink} [inviteLink] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateInviteLink(id: string, inviteLink?: InviteLink, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InviteLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateInviteLink(id, inviteLink, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this keyword.
         * @param {Keyword} [keyword] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateKeyword(id: string, keyword?: Keyword, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Keyword>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateKeyword(id, keyword, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this meal plan.
         * @param {MealPlan} [mealPlan] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMealPlan(id: string, mealPlan?: MealPlan, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MealPlan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMealPlan(id, mealPlan, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {string} id A unique integer value identifying this meal type.
         * @param {MealType} [mealType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMealType(id: string, mealType?: MealType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MealType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMealType(id, mealType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this property.
         * @param {Property} [property] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProperty(id: string, property?: Property, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Property>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProperty(id, property, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this property type.
         * @param {PropertyType} [propertyType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePropertyType(id: string, propertyType?: PropertyType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PropertyType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePropertyType(id, propertyType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this recipe.
         * @param {Recipe} [recipe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRecipe(id: string, recipe?: Recipe, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Recipe>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRecipe(id, recipe, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this recipe book.
         * @param {RecipeBook} [recipeBook] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRecipeBook(id: string, recipeBook?: RecipeBook, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecipeBook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRecipeBook(id, recipeBook, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this recipe book entry.
         * @param {RecipeBookEntry} [recipeBookEntry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRecipeBookEntry(id: string, recipeBookEntry?: RecipeBookEntry, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecipeBookEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRecipeBookEntry(id, recipeBookEntry, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this shopping list.
         * @param {ShoppingList} [shoppingList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateShoppingList(id: string, shoppingList?: ShoppingList, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShoppingList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateShoppingList(id, shoppingList, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this shopping list entry.
         * @param {ShoppingListEntry} [shoppingListEntry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateShoppingListEntry(id: string, shoppingListEntry?: ShoppingListEntry, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShoppingListEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateShoppingListEntry(id, shoppingListEntry, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this shopping list recipe.
         * @param {ShoppingListRecipe} [shoppingListRecipe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateShoppingListRecipe(id: string, shoppingListRecipe?: ShoppingListRecipe, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShoppingListRecipe>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateShoppingListRecipe(id, shoppingListRecipe, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this step.
         * @param {Step} [step] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateStep(id: string, step?: Step, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Step>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateStep(id, step, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this storage.
         * @param {Storage} [storage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateStorage(id: string, storage?: Storage, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Storage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateStorage(id, storage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this supermarket.
         * @param {Supermarket} [supermarket] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSupermarket(id: string, supermarket?: Supermarket, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Supermarket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSupermarket(id, supermarket, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this supermarket category.
         * @param {SupermarketCategory} [supermarketCategory] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSupermarketCategory(id: string, supermarketCategory?: SupermarketCategory, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupermarketCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSupermarketCategory(id, supermarketCategory, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this supermarket category relation.
         * @param {SupermarketCategoryRelation} [supermarketCategoryRelation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSupermarketCategoryRelation(id: string, supermarketCategoryRelation?: SupermarketCategoryRelation, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupermarketCategoryRelation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSupermarketCategoryRelation(id, supermarketCategoryRelation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this sync.
         * @param {Sync} [sync] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSync(id: string, sync?: Sync, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sync>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSync(id, sync, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this unit.
         * @param {Unit} [unit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUnit(id: string, unit?: Unit, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Unit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUnit(id, unit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this unit conversion.
         * @param {UnitConversion} [unitConversion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUnitConversion(id: string, unitConversion?: UnitConversion, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitConversion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUnitConversion(id, unitConversion, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this user file.
         * @param {string} name 
         * @param {any} file 
         * @param {number} [id2] 
         * @param {string} [fileDownload] 
         * @param {string} [preview] 
         * @param {number} [fileSizeKb] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserFile(id: string, name: string, file: any, id2?: number, fileDownload?: string, preview?: string, fileSizeKb?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserFile(id, name, file, id2, fileDownload, preview, fileSizeKb, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this view log.
         * @param {ViewLog} [viewLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateViewLog(id: string, viewLog?: ViewLog, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ViewLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateViewLog(id, viewLog, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApiApi - factory interface
 * @export
 */
export const ApiApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApiApiFp(configuration)
    return {
        /**
         * 
         * @param {ShoppingListEntryBulk} [shoppingListEntryBulk] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkShoppingListEntry(shoppingListEntryBulk?: ShoppingListEntryBulk, options?: any): AxiosPromise<ShoppingListEntryBulk> {
            return localVarFp.bulkShoppingListEntry(shoppingListEntryBulk, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AccessToken} [accessToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccessToken(accessToken?: AccessToken, options?: any): AxiosPromise<AccessToken> {
            return localVarFp.createAccessToken(accessToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAutoPlanViewSet(body?: any, options?: any): AxiosPromise<any> {
            return localVarFp.createAutoPlanViewSet(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Automation} [automation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAutomation(automation?: Automation, options?: any): AxiosPromise<Automation> {
            return localVarFp.createAutomation(automation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {BookmarkletImport} [bookmarkletImport] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBookmarkletImport(bookmarkletImport?: BookmarkletImport, options?: any): AxiosPromise<BookmarkletImport> {
            return localVarFp.createBookmarkletImport(bookmarkletImport, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CookLog} [cookLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCookLog(cookLog?: CookLog, options?: any): AxiosPromise<CookLog> {
            return localVarFp.createCookLog(cookLog, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CustomFilter} [customFilter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomFilter(customFilter?: CustomFilter, options?: any): AxiosPromise<CustomFilter> {
            return localVarFp.createCustomFilter(customFilter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ExportLog} [exportLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExportLog(exportLog?: ExportLog, options?: any): AxiosPromise<ExportLog> {
            return localVarFp.createExportLog(exportLog, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Food} [food] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFood(food?: Food, options?: any): AxiosPromise<Food> {
            return localVarFp.createFood(food, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ImportLog} [importLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createImportLog(importLog?: ImportLog, options?: any): AxiosPromise<ImportLog> {
            return localVarFp.createImportLog(importLog, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Ingredient} [ingredient] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIngredient(ingredient?: Ingredient, options?: any): AxiosPromise<Ingredient> {
            return localVarFp.createIngredient(ingredient, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {InviteLink} [inviteLink] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInviteLink(inviteLink?: InviteLink, options?: any): AxiosPromise<InviteLink> {
            return localVarFp.createInviteLink(inviteLink, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Keyword} [keyword] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKeyword(keyword?: Keyword, options?: any): AxiosPromise<Keyword> {
            return localVarFp.createKeyword(keyword, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {MealPlan} [mealPlan] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMealPlan(mealPlan?: MealPlan, options?: any): AxiosPromise<MealPlan> {
            return localVarFp.createMealPlan(mealPlan, options).then((request) => request(axios, basePath));
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {MealType} [mealType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMealType(mealType?: MealType, options?: any): AxiosPromise<MealType> {
            return localVarFp.createMealType(mealType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Property} [property] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProperty(property?: Property, options?: any): AxiosPromise<Property> {
            return localVarFp.createProperty(property, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PropertyType} [propertyType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyType(propertyType?: PropertyType, options?: any): AxiosPromise<PropertyType> {
            return localVarFp.createPropertyType(propertyType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Recipe} [recipe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecipe(recipe?: Recipe, options?: any): AxiosPromise<Recipe> {
            return localVarFp.createRecipe(recipe, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RecipeBook} [recipeBook] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecipeBook(recipeBook?: RecipeBook, options?: any): AxiosPromise<RecipeBook> {
            return localVarFp.createRecipeBook(recipeBook, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RecipeBookEntry} [recipeBookEntry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecipeBookEntry(recipeBookEntry?: RecipeBookEntry, options?: any): AxiosPromise<RecipeBookEntry> {
            return localVarFp.createRecipeBookEntry(recipeBookEntry, options).then((request) => request(axios, basePath));
        },
        /**
         * function to retrieve a recipe from a given url or source string :param request: standard request with additional post parameters         - url: url to use for importing recipe         - data: if no url is given recipe is imported from provided source data         - (optional) bookmarklet: id of bookmarklet import to use, overrides URL and data attributes :return: JsonResponse containing the parsed json and images
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecipeUrlImport(body?: any, options?: any): AxiosPromise<any> {
            return localVarFp.createRecipeUrlImport(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ShoppingList} [shoppingList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShoppingList(shoppingList?: ShoppingList, options?: any): AxiosPromise<ShoppingList> {
            return localVarFp.createShoppingList(shoppingList, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ShoppingListEntry} [shoppingListEntry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShoppingListEntry(shoppingListEntry?: ShoppingListEntry, options?: any): AxiosPromise<ShoppingListEntry> {
            return localVarFp.createShoppingListEntry(shoppingListEntry, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ShoppingListRecipe} [shoppingListRecipe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShoppingListRecipe(shoppingListRecipe?: ShoppingListRecipe, options?: any): AxiosPromise<ShoppingListRecipe> {
            return localVarFp.createShoppingListRecipe(shoppingListRecipe, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Step} [step] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStep(step?: Step, options?: any): AxiosPromise<Step> {
            return localVarFp.createStep(step, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Storage} [storage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStorage(storage?: Storage, options?: any): AxiosPromise<Storage> {
            return localVarFp.createStorage(storage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Supermarket} [supermarket] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSupermarket(supermarket?: Supermarket, options?: any): AxiosPromise<Supermarket> {
            return localVarFp.createSupermarket(supermarket, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SupermarketCategory} [supermarketCategory] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSupermarketCategory(supermarketCategory?: SupermarketCategory, options?: any): AxiosPromise<SupermarketCategory> {
            return localVarFp.createSupermarketCategory(supermarketCategory, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SupermarketCategoryRelation} [supermarketCategoryRelation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSupermarketCategoryRelation(supermarketCategoryRelation?: SupermarketCategoryRelation, options?: any): AxiosPromise<SupermarketCategoryRelation> {
            return localVarFp.createSupermarketCategoryRelation(supermarketCategoryRelation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Sync} [sync] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSync(sync?: Sync, options?: any): AxiosPromise<Sync> {
            return localVarFp.createSync(sync, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Unit} [unit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUnit(unit?: Unit, options?: any): AxiosPromise<Unit> {
            return localVarFp.createUnit(unit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UnitConversion} [unitConversion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUnitConversion(unitConversion?: UnitConversion, options?: any): AxiosPromise<UnitConversion> {
            return localVarFp.createUnitConversion(unitConversion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} name 
         * @param {any} file 
         * @param {number} [id] 
         * @param {string} [fileDownload] 
         * @param {string} [preview] 
         * @param {number} [fileSizeKb] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserFile(name: string, file: any, id?: number, fileDownload?: string, preview?: string, fileSizeKb?: number, options?: any): AxiosPromise<UserFile> {
            return localVarFp.createUserFile(name, file, id, fileDownload, preview, fileSizeKb, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ViewLog} [viewLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createViewLog(viewLog?: ViewLog, options?: any): AxiosPromise<ViewLog> {
            return localVarFp.createViewLog(viewLog, options).then((request) => request(axios, basePath));
        },
        /**
         * function to handle files passed by application importer
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createimportFiles(body?: any, options?: any): AxiosPromise<any> {
            return localVarFp.createimportFiles(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this access token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyAccessToken(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.destroyAccessToken(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this automation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyAutomation(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.destroyAutomation(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this bookmarklet import.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyBookmarkletImport(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.destroyBookmarkletImport(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this cook log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyCookLog(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.destroyCookLog(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this custom filter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyCustomFilter(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.destroyCustomFilter(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this export log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyExportLog(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.destroyExportLog(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this food.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyFood(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.destroyFood(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this import log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyImportLog(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.destroyImportLog(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this ingredient.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyIngredient(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.destroyIngredient(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this invite link.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyInviteLink(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.destroyInviteLink(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this keyword.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyKeyword(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.destroyKeyword(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this meal plan.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyMealPlan(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.destroyMealPlan(id, options).then((request) => request(axios, basePath));
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {string} id A unique integer value identifying this meal type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyMealType(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.destroyMealType(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this property.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyProperty(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.destroyProperty(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this property type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyPropertyType(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.destroyPropertyType(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyRecipe(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.destroyRecipe(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this recipe book.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyRecipeBook(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.destroyRecipeBook(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this recipe book entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyRecipeBookEntry(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.destroyRecipeBookEntry(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this shopping list.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyShoppingList(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.destroyShoppingList(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this shopping list entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyShoppingListEntry(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.destroyShoppingListEntry(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this shopping list recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyShoppingListRecipe(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.destroyShoppingListRecipe(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this step.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyStep(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.destroyStep(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this storage.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyStorage(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.destroyStorage(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this supermarket.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroySupermarket(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.destroySupermarket(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this supermarket category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroySupermarketCategory(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.destroySupermarketCategory(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this supermarket category relation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroySupermarketCategoryRelation(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.destroySupermarketCategoryRelation(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this sync.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroySync(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.destroySync(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this unit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyUnit(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.destroyUnit(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this unit conversion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyUnitConversion(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.destroyUnitConversion(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this user file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyUserFile(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.destroyUserFile(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this user space.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyUserSpace(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.destroyUserSpace(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this view log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyViewLog(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.destroyViewLog(id, options).then((request) => request(axios, basePath));
        },
        /**
         * updates the food with all possible data from the FDC Api if properties with a fdc_id already exist they will be overridden, if existing properties don\'t have a fdc_id they won\'t be changed
         * @param {string} id A unique integer value identifying this food.
         * @param {Food} [food] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fdcFood(id: string, food?: Food, options?: any): AxiosPromise<Food> {
            return localVarFp.fdcFood(id, food, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this recipe.
         * @param {any} [image] 
         * @param {string} [imageUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageRecipe(id: string, image?: any, imageUrl?: string, options?: any): AxiosPromise<RecipeImage> {
            return localVarFp.imageRecipe(id, image, imageUrl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccessTokens(options?: any): AxiosPromise<Array<AccessToken>> {
            return localVarFp.listAccessTokens(options).then((request) => request(axios, basePath));
        },
        /**
         * optional parameters  - **automation_type**: Return the Automations matching the automation type.  Multiple values allowed.  *Automation Types:* - FS: Food Alias - UA: Unit Alias - KA: Keyword Alias - DR: Description Replace - IR: Instruction Replace - NU: Never Unit - TW: Transpose Words - FR: Food Replace - UR: Unit Replace - NR: Name Replace
         * @param {string} [automationType] Return the Automations matching the automation type.  Multiple values allowed.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAutomations(automationType?: string, page?: number, pageSize?: number, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.listAutomations(automationType, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBookmarkletImports(options?: any): AxiosPromise<Array<BookmarkletImportList>> {
            return localVarFp.listBookmarkletImports(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCookLogs(page?: number, pageSize?: number, options?: any): AxiosPromise<InlineResponse2001> {
            return localVarFp.listCookLogs(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCustomFilters(page?: number, pageSize?: number, options?: any): AxiosPromise<InlineResponse2002> {
            return localVarFp.listCustomFilters(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExportLogs(page?: number, pageSize?: number, options?: any): AxiosPromise<InlineResponse2005> {
            return localVarFp.listExportLogs(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFoodInheritFields(options?: any): AxiosPromise<Array<FoodInheritField>> {
            return localVarFp.listFoodInheritFields(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [query] Query string matched against food name.
         * @param {number} [root] Return first level children of food with ID [int].  Integer 0 will return root foods.
         * @param {number} [tree] Return all self and children of food with ID [int].
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFoods(query?: string, root?: number, tree?: number, page?: number, pageSize?: number, options?: any): AxiosPromise<InlineResponse2003> {
            return localVarFp.listFoods(query, root, tree, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroups(options?: any): AxiosPromise<Array<Group>> {
            return localVarFp.listGroups(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listImportLogs(page?: number, pageSize?: number, options?: any): AxiosPromise<InlineResponse2004> {
            return localVarFp.listImportLogs(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIngredients(page?: number, pageSize?: number, options?: any): AxiosPromise<InlineResponse2006> {
            return localVarFp.listIngredients(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInviteLinks(options?: any): AxiosPromise<Array<InviteLink>> {
            return localVarFp.listInviteLinks(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [query] Query string matched against keyword name.
         * @param {number} [root] Return first level children of keyword with ID [int].  Integer 0 will return root keywords.
         * @param {number} [tree] Return all self and children of keyword with ID [int].
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listKeywords(query?: string, root?: number, tree?: number, page?: number, pageSize?: number, options?: any): AxiosPromise<InlineResponse2007> {
            return localVarFp.listKeywords(query, root, tree, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * optional parameters  - **from_date**: filter from (inclusive) a certain date onward - **to_date**: filter upward to (inclusive) certain date - **meal_type**: filter meal plans based on meal_type ID
         * @param {string} [fromDate] Filter meal plans from date (inclusive) in the format of YYYY-MM-DD.
         * @param {string} [toDate] Filter meal plans to date (inclusive) in the format of YYYY-MM-DD.
         * @param {number} [mealType] Filter meal plans with MealType ID. For multiple repeat parameter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMealPlans(fromDate?: string, toDate?: string, mealType?: number, options?: any): AxiosPromise<Array<MealPlan>> {
            return localVarFp.listMealPlans(fromDate, toDate, mealType, options).then((request) => request(axios, basePath));
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMealTypes(options?: any): AxiosPromise<Array<MealType>> {
            return localVarFp.listMealTypes(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPropertyTypes(options?: any): AxiosPromise<Array<PropertyType>> {
            return localVarFp.listPropertyTypes(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPropertys(options?: any): AxiosPromise<Array<Property>> {
            return localVarFp.listPropertys(options).then((request) => request(axios, basePath));
        },
        /**
         * optional parameters  - **recipe**: id of recipe - only return books for that recipe - **book**: id of book - only return recipes in that book
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRecipeBookEntrys(options?: any): AxiosPromise<Array<RecipeBookEntry>> {
            return localVarFp.listRecipeBookEntrys(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRecipeBooks(options?: any): AxiosPromise<Array<RecipeBook>> {
            return localVarFp.listRecipeBooks(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [query] Query string matched (fuzzy) against recipe name. In the future also fulltext search.
         * @param {number} [keywords] ID of keyword a recipe should have. For multiple repeat parameter. Equivalent to keywords_or
         * @param {number} [keywordsOr] Keyword IDs, repeat for multiple. Return recipes with any of the keywords
         * @param {number} [keywordsAnd] Keyword IDs, repeat for multiple. Return recipes with all of the keywords.
         * @param {number} [keywordsOrNot] Keyword IDs, repeat for multiple. Exclude recipes with any of the keywords.
         * @param {number} [keywordsAndNot] Keyword IDs, repeat for multiple. Exclude recipes with all of the keywords.
         * @param {number} [foods] ID of food a recipe should have. For multiple repeat parameter.
         * @param {number} [foodsOr] Food IDs, repeat for multiple. Return recipes with any of the foods
         * @param {number} [foodsAnd] Food IDs, repeat for multiple. Return recipes with all of the foods.
         * @param {number} [foodsOrNot] Food IDs, repeat for multiple. Exclude recipes with any of the foods.
         * @param {number} [foodsAndNot] Food IDs, repeat for multiple. Exclude recipes with all of the foods.
         * @param {number} [units] ID of unit a recipe should have.
         * @param {number} [rating] Rating a recipe should have or greater. [0 - 5] Negative value filters rating less than.
         * @param {string} [books] ID of book a recipe should be in. For multiple repeat parameter.
         * @param {number} [booksOr] Book IDs, repeat for multiple. Return recipes with any of the books
         * @param {number} [booksAnd] Book IDs, repeat for multiple. Return recipes with all of the books.
         * @param {number} [booksOrNot] Book IDs, repeat for multiple. Exclude recipes with any of the books.
         * @param {number} [booksAndNot] Book IDs, repeat for multiple. Exclude recipes with all of the books.
         * @param {string} [internal] If only internal recipes should be returned. [true/&lt;b&gt;false&lt;/b&gt;]
         * @param {string} [random] Returns the results in randomized order. [true/&lt;b&gt;false&lt;/b&gt;]
         * @param {string} [_new] Returns new results first in search results. [true/&lt;b&gt;false&lt;/b&gt;]
         * @param {number} [timescooked] Filter recipes cooked X times or more.  Negative values returns cooked less than X times
         * @param {string} [cookedon] Filter recipes last cooked on or after YYYY-MM-DD. Prepending - filters on or before date.
         * @param {string} [createdon] Filter recipes created on or after YYYY-MM-DD. Prepending - filters on or before date.
         * @param {string} [updatedon] Filter recipes updated on or after YYYY-MM-DD. Prepending - filters on or before date.
         * @param {string} [viewedon] Filter recipes lasts viewed on or after YYYY-MM-DD. Prepending - filters on or before date.
         * @param {string} [makenow] Filter recipes that can be made with OnHand food. [true/&lt;b&gt;false&lt;/b&gt;]
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRecipes(query?: string, keywords?: number, keywordsOr?: number, keywordsAnd?: number, keywordsOrNot?: number, keywordsAndNot?: number, foods?: number, foodsOr?: number, foodsAnd?: number, foodsOrNot?: number, foodsAndNot?: number, units?: number, rating?: number, books?: string, booksOr?: number, booksAnd?: number, booksOrNot?: number, booksAndNot?: number, internal?: string, random?: string, _new?: string, timescooked?: number, cookedon?: string, createdon?: string, updatedon?: string, viewedon?: string, makenow?: string, page?: number, pageSize?: number, options?: any): AxiosPromise<InlineResponse2008> {
            return localVarFp.listRecipes(query, keywords, keywordsOr, keywordsAnd, keywordsOrNot, keywordsAndNot, foods, foodsOr, foodsAnd, foodsOrNot, foodsAndNot, units, rating, books, booksOr, booksAnd, booksOrNot, booksAndNot, internal, random, _new, timescooked, cookedon, createdon, updatedon, viewedon, makenow, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [id] Returns the shopping list entry with a primary key of id.  Multiple values allowed.
         * @param {string} [checked] Filter shopping list entries on checked.  [true, false, both, &lt;b&gt;recent&lt;/b&gt;]&lt;br&gt;                  - recent includes unchecked items and recently completed items.
         * @param {number} [supermarket] Returns the shopping list entries sorted by supermarket category order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listShoppingListEntrys(id?: number, checked?: string, supermarket?: number, options?: any): AxiosPromise<Array<ShoppingListEntry>> {
            return localVarFp.listShoppingListEntrys(id, checked, supermarket, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listShoppingListRecipes(options?: any): AxiosPromise<Array<ShoppingListRecipe>> {
            return localVarFp.listShoppingListRecipes(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listShoppingLists(options?: any): AxiosPromise<Array<ShoppingList>> {
            return localVarFp.listShoppingLists(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSpaces(options?: any): AxiosPromise<Array<Space>> {
            return localVarFp.listSpaces(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [recipe] ID of recipe a step is part of. For multiple repeat parameter.
         * @param {string} [query] Query string matched (fuzzy) against object name.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSteps(recipe?: number, query?: string, page?: number, pageSize?: number, options?: any): AxiosPromise<InlineResponse2009> {
            return localVarFp.listSteps(recipe, query, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listStorages(options?: any): AxiosPromise<Array<Storage>> {
            return localVarFp.listStorages(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSupermarketCategoryRelations(page?: number, pageSize?: number, options?: any): AxiosPromise<InlineResponse20010> {
            return localVarFp.listSupermarketCategoryRelations(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [query] Query string matched against supermarket-category name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSupermarketCategorys(query?: string, options?: any): AxiosPromise<Array<SupermarketCategory>> {
            return localVarFp.listSupermarketCategorys(query, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [query] Query string matched against supermarket name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSupermarkets(query?: string, options?: any): AxiosPromise<Array<Supermarket>> {
            return localVarFp.listSupermarkets(query, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSyncLogs(page?: number, pageSize?: number, options?: any): AxiosPromise<InlineResponse20011> {
            return localVarFp.listSyncLogs(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSyncs(options?: any): AxiosPromise<Array<Sync>> {
            return localVarFp.listSyncs(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [foodId] ID of food to filter for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUnitConversions(foodId?: number, options?: any): AxiosPromise<Array<UnitConversion>> {
            return localVarFp.listUnitConversions(foodId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [query] Query string matched against unit name.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUnits(query?: string, page?: number, pageSize?: number, options?: any): AxiosPromise<InlineResponse20012> {
            return localVarFp.listUnits(query, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [query] Query string matched against user-file name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserFiles(query?: string, options?: any): AxiosPromise<Array<UserFile>> {
            return localVarFp.listUserFiles(query, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserPreferences(options?: any): AxiosPromise<Array<UserPreference>> {
            return localVarFp.listUserPreferences(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserSpaces(page?: number, pageSize?: number, options?: any): AxiosPromise<InlineResponse20013> {
            return localVarFp.listUserSpaces(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * optional parameters  - **filter_list**: array of user id\'s to get names for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(options?: any): AxiosPromise<Array<User>> {
            return localVarFp.listUsers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listViewLogs(page?: number, pageSize?: number, options?: any): AxiosPromise<InlineResponse20014> {
            return localVarFp.listViewLogs(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * function to reset inheritance from api, see food method for docs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listresetFoodInheritances(options?: any): AxiosPromise<Array<any>> {
            return localVarFp.listresetFoodInheritances(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this food.
         * @param {string} target 
         * @param {Food} [food] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeFood(id: string, target: string, food?: Food, options?: any): AxiosPromise<Food> {
            return localVarFp.mergeFood(id, target, food, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this keyword.
         * @param {string} target 
         * @param {Keyword} [keyword] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeKeyword(id: string, target: string, keyword?: Keyword, options?: any): AxiosPromise<Keyword> {
            return localVarFp.mergeKeyword(id, target, keyword, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this supermarket category.
         * @param {string} target 
         * @param {SupermarketCategory} [supermarketCategory] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeSupermarketCategory(id: string, target: string, supermarketCategory?: SupermarketCategory, options?: any): AxiosPromise<SupermarketCategory> {
            return localVarFp.mergeSupermarketCategory(id, target, supermarketCategory, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this unit.
         * @param {string} target 
         * @param {Unit} [unit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeUnit(id: string, target: string, unit?: Unit, options?: any): AxiosPromise<Unit> {
            return localVarFp.mergeUnit(id, target, unit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this food.
         * @param {string} parent 
         * @param {Food} [food] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveFood(id: string, parent: string, food?: Food, options?: any): AxiosPromise<Food> {
            return localVarFp.moveFood(id, parent, food, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this keyword.
         * @param {string} parent 
         * @param {Keyword} [keyword] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveKeyword(id: string, parent: string, keyword?: Keyword, options?: any): AxiosPromise<Keyword> {
            return localVarFp.moveKeyword(id, parent, keyword, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this access token.
         * @param {AccessToken} [accessToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateAccessToken(id: string, accessToken?: AccessToken, options?: any): AxiosPromise<AccessToken> {
            return localVarFp.partialUpdateAccessToken(id, accessToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this automation.
         * @param {Automation} [automation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateAutomation(id: string, automation?: Automation, options?: any): AxiosPromise<Automation> {
            return localVarFp.partialUpdateAutomation(id, automation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this bookmarklet import.
         * @param {BookmarkletImport} [bookmarkletImport] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateBookmarkletImport(id: string, bookmarkletImport?: BookmarkletImport, options?: any): AxiosPromise<BookmarkletImport> {
            return localVarFp.partialUpdateBookmarkletImport(id, bookmarkletImport, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this cook log.
         * @param {CookLog} [cookLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateCookLog(id: string, cookLog?: CookLog, options?: any): AxiosPromise<CookLog> {
            return localVarFp.partialUpdateCookLog(id, cookLog, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this custom filter.
         * @param {CustomFilter} [customFilter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateCustomFilter(id: string, customFilter?: CustomFilter, options?: any): AxiosPromise<CustomFilter> {
            return localVarFp.partialUpdateCustomFilter(id, customFilter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this export log.
         * @param {ExportLog} [exportLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateExportLog(id: string, exportLog?: ExportLog, options?: any): AxiosPromise<ExportLog> {
            return localVarFp.partialUpdateExportLog(id, exportLog, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this food.
         * @param {Food} [food] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateFood(id: string, food?: Food, options?: any): AxiosPromise<Food> {
            return localVarFp.partialUpdateFood(id, food, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this import log.
         * @param {ImportLog} [importLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateImportLog(id: string, importLog?: ImportLog, options?: any): AxiosPromise<ImportLog> {
            return localVarFp.partialUpdateImportLog(id, importLog, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this ingredient.
         * @param {Ingredient} [ingredient] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateIngredient(id: string, ingredient?: Ingredient, options?: any): AxiosPromise<Ingredient> {
            return localVarFp.partialUpdateIngredient(id, ingredient, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this invite link.
         * @param {InviteLink} [inviteLink] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateInviteLink(id: string, inviteLink?: InviteLink, options?: any): AxiosPromise<InviteLink> {
            return localVarFp.partialUpdateInviteLink(id, inviteLink, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this keyword.
         * @param {Keyword} [keyword] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateKeyword(id: string, keyword?: Keyword, options?: any): AxiosPromise<Keyword> {
            return localVarFp.partialUpdateKeyword(id, keyword, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this meal plan.
         * @param {MealPlan} [mealPlan] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateMealPlan(id: string, mealPlan?: MealPlan, options?: any): AxiosPromise<MealPlan> {
            return localVarFp.partialUpdateMealPlan(id, mealPlan, options).then((request) => request(axios, basePath));
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {string} id A unique integer value identifying this meal type.
         * @param {MealType} [mealType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateMealType(id: string, mealType?: MealType, options?: any): AxiosPromise<MealType> {
            return localVarFp.partialUpdateMealType(id, mealType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this property.
         * @param {Property} [property] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateProperty(id: string, property?: Property, options?: any): AxiosPromise<Property> {
            return localVarFp.partialUpdateProperty(id, property, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this property type.
         * @param {PropertyType} [propertyType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdatePropertyType(id: string, propertyType?: PropertyType, options?: any): AxiosPromise<PropertyType> {
            return localVarFp.partialUpdatePropertyType(id, propertyType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this recipe.
         * @param {Recipe} [recipe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateRecipe(id: string, recipe?: Recipe, options?: any): AxiosPromise<Recipe> {
            return localVarFp.partialUpdateRecipe(id, recipe, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this recipe book.
         * @param {RecipeBook} [recipeBook] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateRecipeBook(id: string, recipeBook?: RecipeBook, options?: any): AxiosPromise<RecipeBook> {
            return localVarFp.partialUpdateRecipeBook(id, recipeBook, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this recipe book entry.
         * @param {RecipeBookEntry} [recipeBookEntry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateRecipeBookEntry(id: string, recipeBookEntry?: RecipeBookEntry, options?: any): AxiosPromise<RecipeBookEntry> {
            return localVarFp.partialUpdateRecipeBookEntry(id, recipeBookEntry, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this shopping list.
         * @param {ShoppingList} [shoppingList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateShoppingList(id: string, shoppingList?: ShoppingList, options?: any): AxiosPromise<ShoppingList> {
            return localVarFp.partialUpdateShoppingList(id, shoppingList, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this shopping list entry.
         * @param {ShoppingListEntry} [shoppingListEntry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateShoppingListEntry(id: string, shoppingListEntry?: ShoppingListEntry, options?: any): AxiosPromise<ShoppingListEntry> {
            return localVarFp.partialUpdateShoppingListEntry(id, shoppingListEntry, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this shopping list recipe.
         * @param {ShoppingListRecipe} [shoppingListRecipe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateShoppingListRecipe(id: string, shoppingListRecipe?: ShoppingListRecipe, options?: any): AxiosPromise<ShoppingListRecipe> {
            return localVarFp.partialUpdateShoppingListRecipe(id, shoppingListRecipe, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this space.
         * @param {Space} [space] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateSpace(id: string, space?: Space, options?: any): AxiosPromise<Space> {
            return localVarFp.partialUpdateSpace(id, space, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this step.
         * @param {Step} [step] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateStep(id: string, step?: Step, options?: any): AxiosPromise<Step> {
            return localVarFp.partialUpdateStep(id, step, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this storage.
         * @param {Storage} [storage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateStorage(id: string, storage?: Storage, options?: any): AxiosPromise<Storage> {
            return localVarFp.partialUpdateStorage(id, storage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this supermarket.
         * @param {Supermarket} [supermarket] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateSupermarket(id: string, supermarket?: Supermarket, options?: any): AxiosPromise<Supermarket> {
            return localVarFp.partialUpdateSupermarket(id, supermarket, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this supermarket category.
         * @param {SupermarketCategory} [supermarketCategory] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateSupermarketCategory(id: string, supermarketCategory?: SupermarketCategory, options?: any): AxiosPromise<SupermarketCategory> {
            return localVarFp.partialUpdateSupermarketCategory(id, supermarketCategory, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this supermarket category relation.
         * @param {SupermarketCategoryRelation} [supermarketCategoryRelation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateSupermarketCategoryRelation(id: string, supermarketCategoryRelation?: SupermarketCategoryRelation, options?: any): AxiosPromise<SupermarketCategoryRelation> {
            return localVarFp.partialUpdateSupermarketCategoryRelation(id, supermarketCategoryRelation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this sync.
         * @param {Sync} [sync] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateSync(id: string, sync?: Sync, options?: any): AxiosPromise<Sync> {
            return localVarFp.partialUpdateSync(id, sync, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this unit.
         * @param {Unit} [unit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateUnit(id: string, unit?: Unit, options?: any): AxiosPromise<Unit> {
            return localVarFp.partialUpdateUnit(id, unit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this unit conversion.
         * @param {UnitConversion} [unitConversion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateUnitConversion(id: string, unitConversion?: UnitConversion, options?: any): AxiosPromise<UnitConversion> {
            return localVarFp.partialUpdateUnitConversion(id, unitConversion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this user.
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateUser(id: string, user?: User, options?: any): AxiosPromise<User> {
            return localVarFp.partialUpdateUser(id, user, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this user file.
         * @param {string} name 
         * @param {any} file 
         * @param {number} [id2] 
         * @param {string} [fileDownload] 
         * @param {string} [preview] 
         * @param {number} [fileSizeKb] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateUserFile(id: string, name: string, file: any, id2?: number, fileDownload?: string, preview?: string, fileSizeKb?: number, options?: any): AxiosPromise<UserFile> {
            return localVarFp.partialUpdateUserFile(id, name, file, id2, fileDownload, preview, fileSizeKb, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} user A unique value identifying this user preference.
         * @param {UserPreference} [userPreference] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateUserPreference(user: string, userPreference?: UserPreference, options?: any): AxiosPromise<UserPreference> {
            return localVarFp.partialUpdateUserPreference(user, userPreference, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this user space.
         * @param {UserSpace} [userSpace] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateUserSpace(id: string, userSpace?: UserSpace, options?: any): AxiosPromise<UserSpace> {
            return localVarFp.partialUpdateUserSpace(id, userSpace, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this view log.
         * @param {ViewLog} [viewLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateViewLog(id: string, viewLog?: ViewLog, options?: any): AxiosPromise<ViewLog> {
            return localVarFp.partialUpdateViewLog(id, viewLog, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        relatedRecipe(id: string, options?: any): AxiosPromise<RecipeSimple> {
            return localVarFp.relatedRecipe(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this access token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAccessToken(id: string, options?: any): AxiosPromise<AccessToken> {
            return localVarFp.retrieveAccessToken(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this automation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAutomation(id: string, options?: any): AxiosPromise<Automation> {
            return localVarFp.retrieveAutomation(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this bookmarklet import.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveBookmarkletImport(id: string, options?: any): AxiosPromise<BookmarkletImport> {
            return localVarFp.retrieveBookmarkletImport(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this cook log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveCookLog(id: string, options?: any): AxiosPromise<CookLog> {
            return localVarFp.retrieveCookLog(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this custom filter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveCustomFilter(id: string, options?: any): AxiosPromise<CustomFilter> {
            return localVarFp.retrieveCustomFilter(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this export log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveExportLog(id: string, options?: any): AxiosPromise<ExportLog> {
            return localVarFp.retrieveExportLog(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this food.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveFood(id: string, options?: any): AxiosPromise<Food> {
            return localVarFp.retrieveFood(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this food inherit field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveFoodInheritField(id: string, options?: any): AxiosPromise<FoodInheritField> {
            return localVarFp.retrieveFoodInheritField(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveGroup(id: string, options?: any): AxiosPromise<Group> {
            return localVarFp.retrieveGroup(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this import log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveImportLog(id: string, options?: any): AxiosPromise<ImportLog> {
            return localVarFp.retrieveImportLog(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this ingredient.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveIngredient(id: string, options?: any): AxiosPromise<Ingredient> {
            return localVarFp.retrieveIngredient(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this invite link.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveInviteLink(id: string, options?: any): AxiosPromise<InviteLink> {
            return localVarFp.retrieveInviteLink(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this keyword.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveKeyword(id: string, options?: any): AxiosPromise<Keyword> {
            return localVarFp.retrieveKeyword(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this meal plan.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveMealPlan(id: string, options?: any): AxiosPromise<MealPlan> {
            return localVarFp.retrieveMealPlan(id, options).then((request) => request(axios, basePath));
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {string} id A unique integer value identifying this meal type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveMealType(id: string, options?: any): AxiosPromise<MealType> {
            return localVarFp.retrieveMealType(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this property.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveProperty(id: string, options?: any): AxiosPromise<Property> {
            return localVarFp.retrieveProperty(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this property type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrievePropertyType(id: string, options?: any): AxiosPromise<PropertyType> {
            return localVarFp.retrievePropertyType(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRecipe(id: string, options?: any): AxiosPromise<Recipe> {
            return localVarFp.retrieveRecipe(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this recipe book.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRecipeBook(id: string, options?: any): AxiosPromise<RecipeBook> {
            return localVarFp.retrieveRecipeBook(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this recipe book entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRecipeBookEntry(id: string, options?: any): AxiosPromise<RecipeBookEntry> {
            return localVarFp.retrieveRecipeBookEntry(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this shopping list.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveShoppingList(id: string, options?: any): AxiosPromise<ShoppingList> {
            return localVarFp.retrieveShoppingList(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this shopping list entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveShoppingListEntry(id: string, options?: any): AxiosPromise<ShoppingListEntry> {
            return localVarFp.retrieveShoppingListEntry(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this shopping list recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveShoppingListRecipe(id: string, options?: any): AxiosPromise<ShoppingListRecipe> {
            return localVarFp.retrieveShoppingListRecipe(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this space.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSpace(id: string, options?: any): AxiosPromise<Space> {
            return localVarFp.retrieveSpace(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this step.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveStep(id: string, options?: any): AxiosPromise<Step> {
            return localVarFp.retrieveStep(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this storage.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveStorage(id: string, options?: any): AxiosPromise<Storage> {
            return localVarFp.retrieveStorage(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this supermarket.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSupermarket(id: string, options?: any): AxiosPromise<Supermarket> {
            return localVarFp.retrieveSupermarket(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this supermarket category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSupermarketCategory(id: string, options?: any): AxiosPromise<SupermarketCategory> {
            return localVarFp.retrieveSupermarketCategory(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this supermarket category relation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSupermarketCategoryRelation(id: string, options?: any): AxiosPromise<SupermarketCategoryRelation> {
            return localVarFp.retrieveSupermarketCategoryRelation(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this sync.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSync(id: string, options?: any): AxiosPromise<Sync> {
            return localVarFp.retrieveSync(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this sync log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSyncLog(id: string, options?: any): AxiosPromise<SyncLog> {
            return localVarFp.retrieveSyncLog(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this unit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUnit(id: string, options?: any): AxiosPromise<Unit> {
            return localVarFp.retrieveUnit(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this unit conversion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUnitConversion(id: string, options?: any): AxiosPromise<UnitConversion> {
            return localVarFp.retrieveUnitConversion(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUser(id: string, options?: any): AxiosPromise<User> {
            return localVarFp.retrieveUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this user file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUserFile(id: string, options?: any): AxiosPromise<UserFile> {
            return localVarFp.retrieveUserFile(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} user A unique value identifying this user preference.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUserPreference(user: string, options?: any): AxiosPromise<UserPreference> {
            return localVarFp.retrieveUserPreference(user, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this user space.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUserSpace(id: string, options?: any): AxiosPromise<UserSpace> {
            return localVarFp.retrieveUserSpace(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this view log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveViewLog(id: string, options?: any): AxiosPromise<ViewLog> {
            return localVarFp.retrieveViewLog(id, options).then((request) => request(axios, basePath));
        },
        /**
         * function to download a user file securely (wrapping as zip to prevent any context based XSS problems) temporary solution until a real file manager is implemented
         * @param {string} fileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrievedownloadFile(fileId: string, options?: any): AxiosPromise<any> {
            return localVarFp.retrievedownloadFile(fileId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveshareLink(id: string, options?: any): AxiosPromise<any> {
            return localVarFp.retrieveshareLink(id, options).then((request) => request(axios, basePath));
        },
        /**
         * api endpoint to switch space function
         * @param {string} spaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveswitchActiveSpace(spaceId: string, options?: any): AxiosPromise<any> {
            return localVarFp.retrieveswitchActiveSpace(spaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this food.
         * @param {FoodShoppingUpdate} [foodShoppingUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shoppingFood(id: string, foodShoppingUpdate?: FoodShoppingUpdate, options?: any): AxiosPromise<FoodShoppingUpdate> {
            return localVarFp.shoppingFood(id, foodShoppingUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this recipe.
         * @param {RecipeShoppingUpdate} [recipeShoppingUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shoppingRecipe(id: string, recipeShoppingUpdate?: RecipeShoppingUpdate, options?: any): AxiosPromise<RecipeShoppingUpdate> {
            return localVarFp.shoppingRecipe(id, recipeShoppingUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this access token.
         * @param {AccessToken} [accessToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccessToken(id: string, accessToken?: AccessToken, options?: any): AxiosPromise<AccessToken> {
            return localVarFp.updateAccessToken(id, accessToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this automation.
         * @param {Automation} [automation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAutomation(id: string, automation?: Automation, options?: any): AxiosPromise<Automation> {
            return localVarFp.updateAutomation(id, automation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this bookmarklet import.
         * @param {BookmarkletImport} [bookmarkletImport] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBookmarkletImport(id: string, bookmarkletImport?: BookmarkletImport, options?: any): AxiosPromise<BookmarkletImport> {
            return localVarFp.updateBookmarkletImport(id, bookmarkletImport, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this cook log.
         * @param {CookLog} [cookLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCookLog(id: string, cookLog?: CookLog, options?: any): AxiosPromise<CookLog> {
            return localVarFp.updateCookLog(id, cookLog, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this custom filter.
         * @param {CustomFilter} [customFilter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomFilter(id: string, customFilter?: CustomFilter, options?: any): AxiosPromise<CustomFilter> {
            return localVarFp.updateCustomFilter(id, customFilter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this export log.
         * @param {ExportLog} [exportLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExportLog(id: string, exportLog?: ExportLog, options?: any): AxiosPromise<ExportLog> {
            return localVarFp.updateExportLog(id, exportLog, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this food.
         * @param {Food} [food] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFood(id: string, food?: Food, options?: any): AxiosPromise<Food> {
            return localVarFp.updateFood(id, food, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this import log.
         * @param {ImportLog} [importLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateImportLog(id: string, importLog?: ImportLog, options?: any): AxiosPromise<ImportLog> {
            return localVarFp.updateImportLog(id, importLog, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this ingredient.
         * @param {Ingredient} [ingredient] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIngredient(id: string, ingredient?: Ingredient, options?: any): AxiosPromise<Ingredient> {
            return localVarFp.updateIngredient(id, ingredient, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this invite link.
         * @param {InviteLink} [inviteLink] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInviteLink(id: string, inviteLink?: InviteLink, options?: any): AxiosPromise<InviteLink> {
            return localVarFp.updateInviteLink(id, inviteLink, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this keyword.
         * @param {Keyword} [keyword] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKeyword(id: string, keyword?: Keyword, options?: any): AxiosPromise<Keyword> {
            return localVarFp.updateKeyword(id, keyword, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this meal plan.
         * @param {MealPlan} [mealPlan] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMealPlan(id: string, mealPlan?: MealPlan, options?: any): AxiosPromise<MealPlan> {
            return localVarFp.updateMealPlan(id, mealPlan, options).then((request) => request(axios, basePath));
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {string} id A unique integer value identifying this meal type.
         * @param {MealType} [mealType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMealType(id: string, mealType?: MealType, options?: any): AxiosPromise<MealType> {
            return localVarFp.updateMealType(id, mealType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this property.
         * @param {Property} [property] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProperty(id: string, property?: Property, options?: any): AxiosPromise<Property> {
            return localVarFp.updateProperty(id, property, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this property type.
         * @param {PropertyType} [propertyType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePropertyType(id: string, propertyType?: PropertyType, options?: any): AxiosPromise<PropertyType> {
            return localVarFp.updatePropertyType(id, propertyType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this recipe.
         * @param {Recipe} [recipe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecipe(id: string, recipe?: Recipe, options?: any): AxiosPromise<Recipe> {
            return localVarFp.updateRecipe(id, recipe, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this recipe book.
         * @param {RecipeBook} [recipeBook] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecipeBook(id: string, recipeBook?: RecipeBook, options?: any): AxiosPromise<RecipeBook> {
            return localVarFp.updateRecipeBook(id, recipeBook, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this recipe book entry.
         * @param {RecipeBookEntry} [recipeBookEntry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecipeBookEntry(id: string, recipeBookEntry?: RecipeBookEntry, options?: any): AxiosPromise<RecipeBookEntry> {
            return localVarFp.updateRecipeBookEntry(id, recipeBookEntry, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this shopping list.
         * @param {ShoppingList} [shoppingList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShoppingList(id: string, shoppingList?: ShoppingList, options?: any): AxiosPromise<ShoppingList> {
            return localVarFp.updateShoppingList(id, shoppingList, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this shopping list entry.
         * @param {ShoppingListEntry} [shoppingListEntry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShoppingListEntry(id: string, shoppingListEntry?: ShoppingListEntry, options?: any): AxiosPromise<ShoppingListEntry> {
            return localVarFp.updateShoppingListEntry(id, shoppingListEntry, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this shopping list recipe.
         * @param {ShoppingListRecipe} [shoppingListRecipe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShoppingListRecipe(id: string, shoppingListRecipe?: ShoppingListRecipe, options?: any): AxiosPromise<ShoppingListRecipe> {
            return localVarFp.updateShoppingListRecipe(id, shoppingListRecipe, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this step.
         * @param {Step} [step] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStep(id: string, step?: Step, options?: any): AxiosPromise<Step> {
            return localVarFp.updateStep(id, step, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this storage.
         * @param {Storage} [storage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStorage(id: string, storage?: Storage, options?: any): AxiosPromise<Storage> {
            return localVarFp.updateStorage(id, storage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this supermarket.
         * @param {Supermarket} [supermarket] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSupermarket(id: string, supermarket?: Supermarket, options?: any): AxiosPromise<Supermarket> {
            return localVarFp.updateSupermarket(id, supermarket, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this supermarket category.
         * @param {SupermarketCategory} [supermarketCategory] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSupermarketCategory(id: string, supermarketCategory?: SupermarketCategory, options?: any): AxiosPromise<SupermarketCategory> {
            return localVarFp.updateSupermarketCategory(id, supermarketCategory, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this supermarket category relation.
         * @param {SupermarketCategoryRelation} [supermarketCategoryRelation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSupermarketCategoryRelation(id: string, supermarketCategoryRelation?: SupermarketCategoryRelation, options?: any): AxiosPromise<SupermarketCategoryRelation> {
            return localVarFp.updateSupermarketCategoryRelation(id, supermarketCategoryRelation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this sync.
         * @param {Sync} [sync] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSync(id: string, sync?: Sync, options?: any): AxiosPromise<Sync> {
            return localVarFp.updateSync(id, sync, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this unit.
         * @param {Unit} [unit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUnit(id: string, unit?: Unit, options?: any): AxiosPromise<Unit> {
            return localVarFp.updateUnit(id, unit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this unit conversion.
         * @param {UnitConversion} [unitConversion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUnitConversion(id: string, unitConversion?: UnitConversion, options?: any): AxiosPromise<UnitConversion> {
            return localVarFp.updateUnitConversion(id, unitConversion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this user file.
         * @param {string} name 
         * @param {any} file 
         * @param {number} [id2] 
         * @param {string} [fileDownload] 
         * @param {string} [preview] 
         * @param {number} [fileSizeKb] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserFile(id: string, name: string, file: any, id2?: number, fileDownload?: string, preview?: string, fileSizeKb?: number, options?: any): AxiosPromise<UserFile> {
            return localVarFp.updateUserFile(id, name, file, id2, fileDownload, preview, fileSizeKb, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id A unique integer value identifying this view log.
         * @param {ViewLog} [viewLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateViewLog(id: string, viewLog?: ViewLog, options?: any): AxiosPromise<ViewLog> {
            return localVarFp.updateViewLog(id, viewLog, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApiApi - object-oriented interface
 * @export
 * @class ApiApi
 * @extends {BaseAPI}
 */
export class ApiApi extends BaseAPI {
    /**
     * 
     * @param {ShoppingListEntryBulk} [shoppingListEntryBulk] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public bulkShoppingListEntry(shoppingListEntryBulk?: ShoppingListEntryBulk, options?: any) {
        return ApiApiFp(this.configuration).bulkShoppingListEntry(shoppingListEntryBulk, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AccessToken} [accessToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createAccessToken(accessToken?: AccessToken, options?: any) {
        return ApiApiFp(this.configuration).createAccessToken(accessToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {any} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createAutoPlanViewSet(body?: any, options?: any) {
        return ApiApiFp(this.configuration).createAutoPlanViewSet(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Automation} [automation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createAutomation(automation?: Automation, options?: any) {
        return ApiApiFp(this.configuration).createAutomation(automation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {BookmarkletImport} [bookmarkletImport] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createBookmarkletImport(bookmarkletImport?: BookmarkletImport, options?: any) {
        return ApiApiFp(this.configuration).createBookmarkletImport(bookmarkletImport, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CookLog} [cookLog] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createCookLog(cookLog?: CookLog, options?: any) {
        return ApiApiFp(this.configuration).createCookLog(cookLog, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CustomFilter} [customFilter] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createCustomFilter(customFilter?: CustomFilter, options?: any) {
        return ApiApiFp(this.configuration).createCustomFilter(customFilter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ExportLog} [exportLog] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createExportLog(exportLog?: ExportLog, options?: any) {
        return ApiApiFp(this.configuration).createExportLog(exportLog, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Food} [food] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createFood(food?: Food, options?: any) {
        return ApiApiFp(this.configuration).createFood(food, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ImportLog} [importLog] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createImportLog(importLog?: ImportLog, options?: any) {
        return ApiApiFp(this.configuration).createImportLog(importLog, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Ingredient} [ingredient] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createIngredient(ingredient?: Ingredient, options?: any) {
        return ApiApiFp(this.configuration).createIngredient(ingredient, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {InviteLink} [inviteLink] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createInviteLink(inviteLink?: InviteLink, options?: any) {
        return ApiApiFp(this.configuration).createInviteLink(inviteLink, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Keyword} [keyword] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createKeyword(keyword?: Keyword, options?: any) {
        return ApiApiFp(this.configuration).createKeyword(keyword, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {MealPlan} [mealPlan] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createMealPlan(mealPlan?: MealPlan, options?: any) {
        return ApiApiFp(this.configuration).createMealPlan(mealPlan, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * returns list of meal types created by the requesting user ordered by the order field.
     * @param {MealType} [mealType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createMealType(mealType?: MealType, options?: any) {
        return ApiApiFp(this.configuration).createMealType(mealType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Property} [property] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createProperty(property?: Property, options?: any) {
        return ApiApiFp(this.configuration).createProperty(property, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PropertyType} [propertyType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createPropertyType(propertyType?: PropertyType, options?: any) {
        return ApiApiFp(this.configuration).createPropertyType(propertyType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Recipe} [recipe] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createRecipe(recipe?: Recipe, options?: any) {
        return ApiApiFp(this.configuration).createRecipe(recipe, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RecipeBook} [recipeBook] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createRecipeBook(recipeBook?: RecipeBook, options?: any) {
        return ApiApiFp(this.configuration).createRecipeBook(recipeBook, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RecipeBookEntry} [recipeBookEntry] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createRecipeBookEntry(recipeBookEntry?: RecipeBookEntry, options?: any) {
        return ApiApiFp(this.configuration).createRecipeBookEntry(recipeBookEntry, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * function to retrieve a recipe from a given url or source string :param request: standard request with additional post parameters         - url: url to use for importing recipe         - data: if no url is given recipe is imported from provided source data         - (optional) bookmarklet: id of bookmarklet import to use, overrides URL and data attributes :return: JsonResponse containing the parsed json and images
     * @param {any} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createRecipeUrlImport(body?: any, options?: any) {
        return ApiApiFp(this.configuration).createRecipeUrlImport(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ShoppingList} [shoppingList] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createShoppingList(shoppingList?: ShoppingList, options?: any) {
        return ApiApiFp(this.configuration).createShoppingList(shoppingList, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ShoppingListEntry} [shoppingListEntry] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createShoppingListEntry(shoppingListEntry?: ShoppingListEntry, options?: any) {
        return ApiApiFp(this.configuration).createShoppingListEntry(shoppingListEntry, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ShoppingListRecipe} [shoppingListRecipe] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createShoppingListRecipe(shoppingListRecipe?: ShoppingListRecipe, options?: any) {
        return ApiApiFp(this.configuration).createShoppingListRecipe(shoppingListRecipe, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Step} [step] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createStep(step?: Step, options?: any) {
        return ApiApiFp(this.configuration).createStep(step, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Storage} [storage] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createStorage(storage?: Storage, options?: any) {
        return ApiApiFp(this.configuration).createStorage(storage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Supermarket} [supermarket] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createSupermarket(supermarket?: Supermarket, options?: any) {
        return ApiApiFp(this.configuration).createSupermarket(supermarket, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SupermarketCategory} [supermarketCategory] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createSupermarketCategory(supermarketCategory?: SupermarketCategory, options?: any) {
        return ApiApiFp(this.configuration).createSupermarketCategory(supermarketCategory, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SupermarketCategoryRelation} [supermarketCategoryRelation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createSupermarketCategoryRelation(supermarketCategoryRelation?: SupermarketCategoryRelation, options?: any) {
        return ApiApiFp(this.configuration).createSupermarketCategoryRelation(supermarketCategoryRelation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Sync} [sync] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createSync(sync?: Sync, options?: any) {
        return ApiApiFp(this.configuration).createSync(sync, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Unit} [unit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createUnit(unit?: Unit, options?: any) {
        return ApiApiFp(this.configuration).createUnit(unit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UnitConversion} [unitConversion] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createUnitConversion(unitConversion?: UnitConversion, options?: any) {
        return ApiApiFp(this.configuration).createUnitConversion(unitConversion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} name 
     * @param {any} file 
     * @param {number} [id] 
     * @param {string} [fileDownload] 
     * @param {string} [preview] 
     * @param {number} [fileSizeKb] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createUserFile(name: string, file: any, id?: number, fileDownload?: string, preview?: string, fileSizeKb?: number, options?: any) {
        return ApiApiFp(this.configuration).createUserFile(name, file, id, fileDownload, preview, fileSizeKb, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ViewLog} [viewLog] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createViewLog(viewLog?: ViewLog, options?: any) {
        return ApiApiFp(this.configuration).createViewLog(viewLog, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * function to handle files passed by application importer
     * @param {any} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createimportFiles(body?: any, options?: any) {
        return ApiApiFp(this.configuration).createimportFiles(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this access token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyAccessToken(id: string, options?: any) {
        return ApiApiFp(this.configuration).destroyAccessToken(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this automation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyAutomation(id: string, options?: any) {
        return ApiApiFp(this.configuration).destroyAutomation(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this bookmarklet import.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyBookmarkletImport(id: string, options?: any) {
        return ApiApiFp(this.configuration).destroyBookmarkletImport(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this cook log.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyCookLog(id: string, options?: any) {
        return ApiApiFp(this.configuration).destroyCookLog(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this custom filter.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyCustomFilter(id: string, options?: any) {
        return ApiApiFp(this.configuration).destroyCustomFilter(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this export log.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyExportLog(id: string, options?: any) {
        return ApiApiFp(this.configuration).destroyExportLog(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this food.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyFood(id: string, options?: any) {
        return ApiApiFp(this.configuration).destroyFood(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this import log.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyImportLog(id: string, options?: any) {
        return ApiApiFp(this.configuration).destroyImportLog(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this ingredient.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyIngredient(id: string, options?: any) {
        return ApiApiFp(this.configuration).destroyIngredient(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this invite link.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyInviteLink(id: string, options?: any) {
        return ApiApiFp(this.configuration).destroyInviteLink(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this keyword.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyKeyword(id: string, options?: any) {
        return ApiApiFp(this.configuration).destroyKeyword(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this meal plan.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyMealPlan(id: string, options?: any) {
        return ApiApiFp(this.configuration).destroyMealPlan(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * returns list of meal types created by the requesting user ordered by the order field.
     * @param {string} id A unique integer value identifying this meal type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyMealType(id: string, options?: any) {
        return ApiApiFp(this.configuration).destroyMealType(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this property.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyProperty(id: string, options?: any) {
        return ApiApiFp(this.configuration).destroyProperty(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this property type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyPropertyType(id: string, options?: any) {
        return ApiApiFp(this.configuration).destroyPropertyType(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this recipe.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyRecipe(id: string, options?: any) {
        return ApiApiFp(this.configuration).destroyRecipe(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this recipe book.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyRecipeBook(id: string, options?: any) {
        return ApiApiFp(this.configuration).destroyRecipeBook(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this recipe book entry.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyRecipeBookEntry(id: string, options?: any) {
        return ApiApiFp(this.configuration).destroyRecipeBookEntry(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this shopping list.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyShoppingList(id: string, options?: any) {
        return ApiApiFp(this.configuration).destroyShoppingList(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this shopping list entry.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyShoppingListEntry(id: string, options?: any) {
        return ApiApiFp(this.configuration).destroyShoppingListEntry(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this shopping list recipe.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyShoppingListRecipe(id: string, options?: any) {
        return ApiApiFp(this.configuration).destroyShoppingListRecipe(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this step.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyStep(id: string, options?: any) {
        return ApiApiFp(this.configuration).destroyStep(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this storage.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyStorage(id: string, options?: any) {
        return ApiApiFp(this.configuration).destroyStorage(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this supermarket.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroySupermarket(id: string, options?: any) {
        return ApiApiFp(this.configuration).destroySupermarket(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this supermarket category.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroySupermarketCategory(id: string, options?: any) {
        return ApiApiFp(this.configuration).destroySupermarketCategory(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this supermarket category relation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroySupermarketCategoryRelation(id: string, options?: any) {
        return ApiApiFp(this.configuration).destroySupermarketCategoryRelation(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this sync.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroySync(id: string, options?: any) {
        return ApiApiFp(this.configuration).destroySync(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this unit.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyUnit(id: string, options?: any) {
        return ApiApiFp(this.configuration).destroyUnit(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this unit conversion.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyUnitConversion(id: string, options?: any) {
        return ApiApiFp(this.configuration).destroyUnitConversion(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this user file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyUserFile(id: string, options?: any) {
        return ApiApiFp(this.configuration).destroyUserFile(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this user space.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyUserSpace(id: string, options?: any) {
        return ApiApiFp(this.configuration).destroyUserSpace(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this view log.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyViewLog(id: string, options?: any) {
        return ApiApiFp(this.configuration).destroyViewLog(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * updates the food with all possible data from the FDC Api if properties with a fdc_id already exist they will be overridden, if existing properties don\'t have a fdc_id they won\'t be changed
     * @param {string} id A unique integer value identifying this food.
     * @param {Food} [food] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public fdcFood(id: string, food?: Food, options?: any) {
        return ApiApiFp(this.configuration).fdcFood(id, food, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this recipe.
     * @param {any} [image] 
     * @param {string} [imageUrl] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public imageRecipe(id: string, image?: any, imageUrl?: string, options?: any) {
        return ApiApiFp(this.configuration).imageRecipe(id, image, imageUrl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listAccessTokens(options?: any) {
        return ApiApiFp(this.configuration).listAccessTokens(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * optional parameters  - **automation_type**: Return the Automations matching the automation type.  Multiple values allowed.  *Automation Types:* - FS: Food Alias - UA: Unit Alias - KA: Keyword Alias - DR: Description Replace - IR: Instruction Replace - NU: Never Unit - TW: Transpose Words - FR: Food Replace - UR: Unit Replace - NR: Name Replace
     * @param {string} [automationType] Return the Automations matching the automation type.  Multiple values allowed.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listAutomations(automationType?: string, page?: number, pageSize?: number, options?: any) {
        return ApiApiFp(this.configuration).listAutomations(automationType, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listBookmarkletImports(options?: any) {
        return ApiApiFp(this.configuration).listBookmarkletImports(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listCookLogs(page?: number, pageSize?: number, options?: any) {
        return ApiApiFp(this.configuration).listCookLogs(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listCustomFilters(page?: number, pageSize?: number, options?: any) {
        return ApiApiFp(this.configuration).listCustomFilters(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listExportLogs(page?: number, pageSize?: number, options?: any) {
        return ApiApiFp(this.configuration).listExportLogs(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listFoodInheritFields(options?: any) {
        return ApiApiFp(this.configuration).listFoodInheritFields(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [query] Query string matched against food name.
     * @param {number} [root] Return first level children of food with ID [int].  Integer 0 will return root foods.
     * @param {number} [tree] Return all self and children of food with ID [int].
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listFoods(query?: string, root?: number, tree?: number, page?: number, pageSize?: number, options?: any) {
        return ApiApiFp(this.configuration).listFoods(query, root, tree, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listGroups(options?: any) {
        return ApiApiFp(this.configuration).listGroups(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listImportLogs(page?: number, pageSize?: number, options?: any) {
        return ApiApiFp(this.configuration).listImportLogs(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listIngredients(page?: number, pageSize?: number, options?: any) {
        return ApiApiFp(this.configuration).listIngredients(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listInviteLinks(options?: any) {
        return ApiApiFp(this.configuration).listInviteLinks(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [query] Query string matched against keyword name.
     * @param {number} [root] Return first level children of keyword with ID [int].  Integer 0 will return root keywords.
     * @param {number} [tree] Return all self and children of keyword with ID [int].
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listKeywords(query?: string, root?: number, tree?: number, page?: number, pageSize?: number, options?: any) {
        return ApiApiFp(this.configuration).listKeywords(query, root, tree, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * optional parameters  - **from_date**: filter from (inclusive) a certain date onward - **to_date**: filter upward to (inclusive) certain date - **meal_type**: filter meal plans based on meal_type ID
     * @param {string} [fromDate] Filter meal plans from date (inclusive) in the format of YYYY-MM-DD.
     * @param {string} [toDate] Filter meal plans to date (inclusive) in the format of YYYY-MM-DD.
     * @param {number} [mealType] Filter meal plans with MealType ID. For multiple repeat parameter.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listMealPlans(fromDate?: string, toDate?: string, mealType?: number, options?: any) {
        return ApiApiFp(this.configuration).listMealPlans(fromDate, toDate, mealType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * returns list of meal types created by the requesting user ordered by the order field.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listMealTypes(options?: any) {
        return ApiApiFp(this.configuration).listMealTypes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listPropertyTypes(options?: any) {
        return ApiApiFp(this.configuration).listPropertyTypes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listPropertys(options?: any) {
        return ApiApiFp(this.configuration).listPropertys(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * optional parameters  - **recipe**: id of recipe - only return books for that recipe - **book**: id of book - only return recipes in that book
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listRecipeBookEntrys(options?: any) {
        return ApiApiFp(this.configuration).listRecipeBookEntrys(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listRecipeBooks(options?: any) {
        return ApiApiFp(this.configuration).listRecipeBooks(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [query] Query string matched (fuzzy) against recipe name. In the future also fulltext search.
     * @param {number} [keywords] ID of keyword a recipe should have. For multiple repeat parameter. Equivalent to keywords_or
     * @param {number} [keywordsOr] Keyword IDs, repeat for multiple. Return recipes with any of the keywords
     * @param {number} [keywordsAnd] Keyword IDs, repeat for multiple. Return recipes with all of the keywords.
     * @param {number} [keywordsOrNot] Keyword IDs, repeat for multiple. Exclude recipes with any of the keywords.
     * @param {number} [keywordsAndNot] Keyword IDs, repeat for multiple. Exclude recipes with all of the keywords.
     * @param {number} [foods] ID of food a recipe should have. For multiple repeat parameter.
     * @param {number} [foodsOr] Food IDs, repeat for multiple. Return recipes with any of the foods
     * @param {number} [foodsAnd] Food IDs, repeat for multiple. Return recipes with all of the foods.
     * @param {number} [foodsOrNot] Food IDs, repeat for multiple. Exclude recipes with any of the foods.
     * @param {number} [foodsAndNot] Food IDs, repeat for multiple. Exclude recipes with all of the foods.
     * @param {number} [units] ID of unit a recipe should have.
     * @param {number} [rating] Rating a recipe should have or greater. [0 - 5] Negative value filters rating less than.
     * @param {string} [books] ID of book a recipe should be in. For multiple repeat parameter.
     * @param {number} [booksOr] Book IDs, repeat for multiple. Return recipes with any of the books
     * @param {number} [booksAnd] Book IDs, repeat for multiple. Return recipes with all of the books.
     * @param {number} [booksOrNot] Book IDs, repeat for multiple. Exclude recipes with any of the books.
     * @param {number} [booksAndNot] Book IDs, repeat for multiple. Exclude recipes with all of the books.
     * @param {string} [internal] If only internal recipes should be returned. [true/&lt;b&gt;false&lt;/b&gt;]
     * @param {string} [random] Returns the results in randomized order. [true/&lt;b&gt;false&lt;/b&gt;]
     * @param {string} [_new] Returns new results first in search results. [true/&lt;b&gt;false&lt;/b&gt;]
     * @param {number} [timescooked] Filter recipes cooked X times or more.  Negative values returns cooked less than X times
     * @param {string} [cookedon] Filter recipes last cooked on or after YYYY-MM-DD. Prepending - filters on or before date.
     * @param {string} [createdon] Filter recipes created on or after YYYY-MM-DD. Prepending - filters on or before date.
     * @param {string} [updatedon] Filter recipes updated on or after YYYY-MM-DD. Prepending - filters on or before date.
     * @param {string} [viewedon] Filter recipes lasts viewed on or after YYYY-MM-DD. Prepending - filters on or before date.
     * @param {string} [makenow] Filter recipes that can be made with OnHand food. [true/&lt;b&gt;false&lt;/b&gt;]
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listRecipes(query?: string, keywords?: number, keywordsOr?: number, keywordsAnd?: number, keywordsOrNot?: number, keywordsAndNot?: number, foods?: number, foodsOr?: number, foodsAnd?: number, foodsOrNot?: number, foodsAndNot?: number, units?: number, rating?: number, books?: string, booksOr?: number, booksAnd?: number, booksOrNot?: number, booksAndNot?: number, internal?: string, random?: string, _new?: string, timescooked?: number, cookedon?: string, createdon?: string, updatedon?: string, viewedon?: string, makenow?: string, page?: number, pageSize?: number, options?: any) {
        return ApiApiFp(this.configuration).listRecipes(query, keywords, keywordsOr, keywordsAnd, keywordsOrNot, keywordsAndNot, foods, foodsOr, foodsAnd, foodsOrNot, foodsAndNot, units, rating, books, booksOr, booksAnd, booksOrNot, booksAndNot, internal, random, _new, timescooked, cookedon, createdon, updatedon, viewedon, makenow, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [id] Returns the shopping list entry with a primary key of id.  Multiple values allowed.
     * @param {string} [checked] Filter shopping list entries on checked.  [true, false, both, &lt;b&gt;recent&lt;/b&gt;]&lt;br&gt;                  - recent includes unchecked items and recently completed items.
     * @param {number} [supermarket] Returns the shopping list entries sorted by supermarket category order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listShoppingListEntrys(id?: number, checked?: string, supermarket?: number, options?: any) {
        return ApiApiFp(this.configuration).listShoppingListEntrys(id, checked, supermarket, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listShoppingListRecipes(options?: any) {
        return ApiApiFp(this.configuration).listShoppingListRecipes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listShoppingLists(options?: any) {
        return ApiApiFp(this.configuration).listShoppingLists(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listSpaces(options?: any) {
        return ApiApiFp(this.configuration).listSpaces(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [recipe] ID of recipe a step is part of. For multiple repeat parameter.
     * @param {string} [query] Query string matched (fuzzy) against object name.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listSteps(recipe?: number, query?: string, page?: number, pageSize?: number, options?: any) {
        return ApiApiFp(this.configuration).listSteps(recipe, query, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listStorages(options?: any) {
        return ApiApiFp(this.configuration).listStorages(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listSupermarketCategoryRelations(page?: number, pageSize?: number, options?: any) {
        return ApiApiFp(this.configuration).listSupermarketCategoryRelations(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [query] Query string matched against supermarket-category name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listSupermarketCategorys(query?: string, options?: any) {
        return ApiApiFp(this.configuration).listSupermarketCategorys(query, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [query] Query string matched against supermarket name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listSupermarkets(query?: string, options?: any) {
        return ApiApiFp(this.configuration).listSupermarkets(query, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listSyncLogs(page?: number, pageSize?: number, options?: any) {
        return ApiApiFp(this.configuration).listSyncLogs(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listSyncs(options?: any) {
        return ApiApiFp(this.configuration).listSyncs(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [foodId] ID of food to filter for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listUnitConversions(foodId?: number, options?: any) {
        return ApiApiFp(this.configuration).listUnitConversions(foodId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [query] Query string matched against unit name.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listUnits(query?: string, page?: number, pageSize?: number, options?: any) {
        return ApiApiFp(this.configuration).listUnits(query, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [query] Query string matched against user-file name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listUserFiles(query?: string, options?: any) {
        return ApiApiFp(this.configuration).listUserFiles(query, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listUserPreferences(options?: any) {
        return ApiApiFp(this.configuration).listUserPreferences(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listUserSpaces(page?: number, pageSize?: number, options?: any) {
        return ApiApiFp(this.configuration).listUserSpaces(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * optional parameters  - **filter_list**: array of user id\'s to get names for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listUsers(options?: any) {
        return ApiApiFp(this.configuration).listUsers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listViewLogs(page?: number, pageSize?: number, options?: any) {
        return ApiApiFp(this.configuration).listViewLogs(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * function to reset inheritance from api, see food method for docs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listresetFoodInheritances(options?: any) {
        return ApiApiFp(this.configuration).listresetFoodInheritances(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this food.
     * @param {string} target 
     * @param {Food} [food] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public mergeFood(id: string, target: string, food?: Food, options?: any) {
        return ApiApiFp(this.configuration).mergeFood(id, target, food, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this keyword.
     * @param {string} target 
     * @param {Keyword} [keyword] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public mergeKeyword(id: string, target: string, keyword?: Keyword, options?: any) {
        return ApiApiFp(this.configuration).mergeKeyword(id, target, keyword, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this supermarket category.
     * @param {string} target 
     * @param {SupermarketCategory} [supermarketCategory] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public mergeSupermarketCategory(id: string, target: string, supermarketCategory?: SupermarketCategory, options?: any) {
        return ApiApiFp(this.configuration).mergeSupermarketCategory(id, target, supermarketCategory, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this unit.
     * @param {string} target 
     * @param {Unit} [unit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public mergeUnit(id: string, target: string, unit?: Unit, options?: any) {
        return ApiApiFp(this.configuration).mergeUnit(id, target, unit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this food.
     * @param {string} parent 
     * @param {Food} [food] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public moveFood(id: string, parent: string, food?: Food, options?: any) {
        return ApiApiFp(this.configuration).moveFood(id, parent, food, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this keyword.
     * @param {string} parent 
     * @param {Keyword} [keyword] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public moveKeyword(id: string, parent: string, keyword?: Keyword, options?: any) {
        return ApiApiFp(this.configuration).moveKeyword(id, parent, keyword, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this access token.
     * @param {AccessToken} [accessToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateAccessToken(id: string, accessToken?: AccessToken, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateAccessToken(id, accessToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this automation.
     * @param {Automation} [automation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateAutomation(id: string, automation?: Automation, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateAutomation(id, automation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this bookmarklet import.
     * @param {BookmarkletImport} [bookmarkletImport] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateBookmarkletImport(id: string, bookmarkletImport?: BookmarkletImport, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateBookmarkletImport(id, bookmarkletImport, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this cook log.
     * @param {CookLog} [cookLog] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateCookLog(id: string, cookLog?: CookLog, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateCookLog(id, cookLog, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this custom filter.
     * @param {CustomFilter} [customFilter] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateCustomFilter(id: string, customFilter?: CustomFilter, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateCustomFilter(id, customFilter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this export log.
     * @param {ExportLog} [exportLog] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateExportLog(id: string, exportLog?: ExportLog, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateExportLog(id, exportLog, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this food.
     * @param {Food} [food] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateFood(id: string, food?: Food, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateFood(id, food, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this import log.
     * @param {ImportLog} [importLog] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateImportLog(id: string, importLog?: ImportLog, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateImportLog(id, importLog, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this ingredient.
     * @param {Ingredient} [ingredient] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateIngredient(id: string, ingredient?: Ingredient, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateIngredient(id, ingredient, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this invite link.
     * @param {InviteLink} [inviteLink] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateInviteLink(id: string, inviteLink?: InviteLink, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateInviteLink(id, inviteLink, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this keyword.
     * @param {Keyword} [keyword] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateKeyword(id: string, keyword?: Keyword, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateKeyword(id, keyword, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this meal plan.
     * @param {MealPlan} [mealPlan] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateMealPlan(id: string, mealPlan?: MealPlan, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateMealPlan(id, mealPlan, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * returns list of meal types created by the requesting user ordered by the order field.
     * @param {string} id A unique integer value identifying this meal type.
     * @param {MealType} [mealType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateMealType(id: string, mealType?: MealType, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateMealType(id, mealType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this property.
     * @param {Property} [property] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateProperty(id: string, property?: Property, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateProperty(id, property, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this property type.
     * @param {PropertyType} [propertyType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdatePropertyType(id: string, propertyType?: PropertyType, options?: any) {
        return ApiApiFp(this.configuration).partialUpdatePropertyType(id, propertyType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this recipe.
     * @param {Recipe} [recipe] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateRecipe(id: string, recipe?: Recipe, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateRecipe(id, recipe, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this recipe book.
     * @param {RecipeBook} [recipeBook] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateRecipeBook(id: string, recipeBook?: RecipeBook, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateRecipeBook(id, recipeBook, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this recipe book entry.
     * @param {RecipeBookEntry} [recipeBookEntry] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateRecipeBookEntry(id: string, recipeBookEntry?: RecipeBookEntry, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateRecipeBookEntry(id, recipeBookEntry, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this shopping list.
     * @param {ShoppingList} [shoppingList] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateShoppingList(id: string, shoppingList?: ShoppingList, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateShoppingList(id, shoppingList, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this shopping list entry.
     * @param {ShoppingListEntry} [shoppingListEntry] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateShoppingListEntry(id: string, shoppingListEntry?: ShoppingListEntry, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateShoppingListEntry(id, shoppingListEntry, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this shopping list recipe.
     * @param {ShoppingListRecipe} [shoppingListRecipe] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateShoppingListRecipe(id: string, shoppingListRecipe?: ShoppingListRecipe, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateShoppingListRecipe(id, shoppingListRecipe, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this space.
     * @param {Space} [space] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateSpace(id: string, space?: Space, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateSpace(id, space, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this step.
     * @param {Step} [step] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateStep(id: string, step?: Step, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateStep(id, step, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this storage.
     * @param {Storage} [storage] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateStorage(id: string, storage?: Storage, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateStorage(id, storage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this supermarket.
     * @param {Supermarket} [supermarket] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateSupermarket(id: string, supermarket?: Supermarket, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateSupermarket(id, supermarket, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this supermarket category.
     * @param {SupermarketCategory} [supermarketCategory] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateSupermarketCategory(id: string, supermarketCategory?: SupermarketCategory, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateSupermarketCategory(id, supermarketCategory, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this supermarket category relation.
     * @param {SupermarketCategoryRelation} [supermarketCategoryRelation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateSupermarketCategoryRelation(id: string, supermarketCategoryRelation?: SupermarketCategoryRelation, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateSupermarketCategoryRelation(id, supermarketCategoryRelation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this sync.
     * @param {Sync} [sync] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateSync(id: string, sync?: Sync, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateSync(id, sync, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this unit.
     * @param {Unit} [unit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateUnit(id: string, unit?: Unit, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateUnit(id, unit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this unit conversion.
     * @param {UnitConversion} [unitConversion] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateUnitConversion(id: string, unitConversion?: UnitConversion, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateUnitConversion(id, unitConversion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this user.
     * @param {User} [user] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateUser(id: string, user?: User, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateUser(id, user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this user file.
     * @param {string} name 
     * @param {any} file 
     * @param {number} [id2] 
     * @param {string} [fileDownload] 
     * @param {string} [preview] 
     * @param {number} [fileSizeKb] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateUserFile(id: string, name: string, file: any, id2?: number, fileDownload?: string, preview?: string, fileSizeKb?: number, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateUserFile(id, name, file, id2, fileDownload, preview, fileSizeKb, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} user A unique value identifying this user preference.
     * @param {UserPreference} [userPreference] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateUserPreference(user: string, userPreference?: UserPreference, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateUserPreference(user, userPreference, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this user space.
     * @param {UserSpace} [userSpace] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateUserSpace(id: string, userSpace?: UserSpace, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateUserSpace(id, userSpace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this view log.
     * @param {ViewLog} [viewLog] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateViewLog(id: string, viewLog?: ViewLog, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateViewLog(id, viewLog, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this recipe.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public relatedRecipe(id: string, options?: any) {
        return ApiApiFp(this.configuration).relatedRecipe(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this access token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveAccessToken(id: string, options?: any) {
        return ApiApiFp(this.configuration).retrieveAccessToken(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this automation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveAutomation(id: string, options?: any) {
        return ApiApiFp(this.configuration).retrieveAutomation(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this bookmarklet import.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveBookmarkletImport(id: string, options?: any) {
        return ApiApiFp(this.configuration).retrieveBookmarkletImport(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this cook log.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveCookLog(id: string, options?: any) {
        return ApiApiFp(this.configuration).retrieveCookLog(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this custom filter.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveCustomFilter(id: string, options?: any) {
        return ApiApiFp(this.configuration).retrieveCustomFilter(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this export log.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveExportLog(id: string, options?: any) {
        return ApiApiFp(this.configuration).retrieveExportLog(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this food.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveFood(id: string, options?: any) {
        return ApiApiFp(this.configuration).retrieveFood(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this food inherit field.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveFoodInheritField(id: string, options?: any) {
        return ApiApiFp(this.configuration).retrieveFoodInheritField(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this group.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveGroup(id: string, options?: any) {
        return ApiApiFp(this.configuration).retrieveGroup(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this import log.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveImportLog(id: string, options?: any) {
        return ApiApiFp(this.configuration).retrieveImportLog(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this ingredient.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveIngredient(id: string, options?: any) {
        return ApiApiFp(this.configuration).retrieveIngredient(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this invite link.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveInviteLink(id: string, options?: any) {
        return ApiApiFp(this.configuration).retrieveInviteLink(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this keyword.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveKeyword(id: string, options?: any) {
        return ApiApiFp(this.configuration).retrieveKeyword(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this meal plan.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveMealPlan(id: string, options?: any) {
        return ApiApiFp(this.configuration).retrieveMealPlan(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * returns list of meal types created by the requesting user ordered by the order field.
     * @param {string} id A unique integer value identifying this meal type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveMealType(id: string, options?: any) {
        return ApiApiFp(this.configuration).retrieveMealType(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this property.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveProperty(id: string, options?: any) {
        return ApiApiFp(this.configuration).retrieveProperty(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this property type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrievePropertyType(id: string, options?: any) {
        return ApiApiFp(this.configuration).retrievePropertyType(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this recipe.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveRecipe(id: string, options?: any) {
        return ApiApiFp(this.configuration).retrieveRecipe(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this recipe book.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveRecipeBook(id: string, options?: any) {
        return ApiApiFp(this.configuration).retrieveRecipeBook(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this recipe book entry.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveRecipeBookEntry(id: string, options?: any) {
        return ApiApiFp(this.configuration).retrieveRecipeBookEntry(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this shopping list.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveShoppingList(id: string, options?: any) {
        return ApiApiFp(this.configuration).retrieveShoppingList(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this shopping list entry.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveShoppingListEntry(id: string, options?: any) {
        return ApiApiFp(this.configuration).retrieveShoppingListEntry(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this shopping list recipe.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveShoppingListRecipe(id: string, options?: any) {
        return ApiApiFp(this.configuration).retrieveShoppingListRecipe(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this space.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveSpace(id: string, options?: any) {
        return ApiApiFp(this.configuration).retrieveSpace(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this step.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveStep(id: string, options?: any) {
        return ApiApiFp(this.configuration).retrieveStep(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this storage.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveStorage(id: string, options?: any) {
        return ApiApiFp(this.configuration).retrieveStorage(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this supermarket.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveSupermarket(id: string, options?: any) {
        return ApiApiFp(this.configuration).retrieveSupermarket(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this supermarket category.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveSupermarketCategory(id: string, options?: any) {
        return ApiApiFp(this.configuration).retrieveSupermarketCategory(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this supermarket category relation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveSupermarketCategoryRelation(id: string, options?: any) {
        return ApiApiFp(this.configuration).retrieveSupermarketCategoryRelation(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this sync.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveSync(id: string, options?: any) {
        return ApiApiFp(this.configuration).retrieveSync(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this sync log.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveSyncLog(id: string, options?: any) {
        return ApiApiFp(this.configuration).retrieveSyncLog(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this unit.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveUnit(id: string, options?: any) {
        return ApiApiFp(this.configuration).retrieveUnit(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this unit conversion.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveUnitConversion(id: string, options?: any) {
        return ApiApiFp(this.configuration).retrieveUnitConversion(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveUser(id: string, options?: any) {
        return ApiApiFp(this.configuration).retrieveUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this user file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveUserFile(id: string, options?: any) {
        return ApiApiFp(this.configuration).retrieveUserFile(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} user A unique value identifying this user preference.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveUserPreference(user: string, options?: any) {
        return ApiApiFp(this.configuration).retrieveUserPreference(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this user space.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveUserSpace(id: string, options?: any) {
        return ApiApiFp(this.configuration).retrieveUserSpace(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this view log.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveViewLog(id: string, options?: any) {
        return ApiApiFp(this.configuration).retrieveViewLog(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * function to download a user file securely (wrapping as zip to prevent any context based XSS problems) temporary solution until a real file manager is implemented
     * @param {string} fileId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrievedownloadFile(fileId: string, options?: any) {
        return ApiApiFp(this.configuration).retrievedownloadFile(fileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveshareLink(id: string, options?: any) {
        return ApiApiFp(this.configuration).retrieveshareLink(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * api endpoint to switch space function
     * @param {string} spaceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveswitchActiveSpace(spaceId: string, options?: any) {
        return ApiApiFp(this.configuration).retrieveswitchActiveSpace(spaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this food.
     * @param {FoodShoppingUpdate} [foodShoppingUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public shoppingFood(id: string, foodShoppingUpdate?: FoodShoppingUpdate, options?: any) {
        return ApiApiFp(this.configuration).shoppingFood(id, foodShoppingUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this recipe.
     * @param {RecipeShoppingUpdate} [recipeShoppingUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public shoppingRecipe(id: string, recipeShoppingUpdate?: RecipeShoppingUpdate, options?: any) {
        return ApiApiFp(this.configuration).shoppingRecipe(id, recipeShoppingUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this access token.
     * @param {AccessToken} [accessToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateAccessToken(id: string, accessToken?: AccessToken, options?: any) {
        return ApiApiFp(this.configuration).updateAccessToken(id, accessToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this automation.
     * @param {Automation} [automation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateAutomation(id: string, automation?: Automation, options?: any) {
        return ApiApiFp(this.configuration).updateAutomation(id, automation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this bookmarklet import.
     * @param {BookmarkletImport} [bookmarkletImport] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateBookmarkletImport(id: string, bookmarkletImport?: BookmarkletImport, options?: any) {
        return ApiApiFp(this.configuration).updateBookmarkletImport(id, bookmarkletImport, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this cook log.
     * @param {CookLog} [cookLog] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateCookLog(id: string, cookLog?: CookLog, options?: any) {
        return ApiApiFp(this.configuration).updateCookLog(id, cookLog, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this custom filter.
     * @param {CustomFilter} [customFilter] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateCustomFilter(id: string, customFilter?: CustomFilter, options?: any) {
        return ApiApiFp(this.configuration).updateCustomFilter(id, customFilter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this export log.
     * @param {ExportLog} [exportLog] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateExportLog(id: string, exportLog?: ExportLog, options?: any) {
        return ApiApiFp(this.configuration).updateExportLog(id, exportLog, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this food.
     * @param {Food} [food] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateFood(id: string, food?: Food, options?: any) {
        return ApiApiFp(this.configuration).updateFood(id, food, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this import log.
     * @param {ImportLog} [importLog] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateImportLog(id: string, importLog?: ImportLog, options?: any) {
        return ApiApiFp(this.configuration).updateImportLog(id, importLog, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this ingredient.
     * @param {Ingredient} [ingredient] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateIngredient(id: string, ingredient?: Ingredient, options?: any) {
        return ApiApiFp(this.configuration).updateIngredient(id, ingredient, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this invite link.
     * @param {InviteLink} [inviteLink] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateInviteLink(id: string, inviteLink?: InviteLink, options?: any) {
        return ApiApiFp(this.configuration).updateInviteLink(id, inviteLink, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this keyword.
     * @param {Keyword} [keyword] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateKeyword(id: string, keyword?: Keyword, options?: any) {
        return ApiApiFp(this.configuration).updateKeyword(id, keyword, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this meal plan.
     * @param {MealPlan} [mealPlan] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateMealPlan(id: string, mealPlan?: MealPlan, options?: any) {
        return ApiApiFp(this.configuration).updateMealPlan(id, mealPlan, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * returns list of meal types created by the requesting user ordered by the order field.
     * @param {string} id A unique integer value identifying this meal type.
     * @param {MealType} [mealType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateMealType(id: string, mealType?: MealType, options?: any) {
        return ApiApiFp(this.configuration).updateMealType(id, mealType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this property.
     * @param {Property} [property] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateProperty(id: string, property?: Property, options?: any) {
        return ApiApiFp(this.configuration).updateProperty(id, property, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this property type.
     * @param {PropertyType} [propertyType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updatePropertyType(id: string, propertyType?: PropertyType, options?: any) {
        return ApiApiFp(this.configuration).updatePropertyType(id, propertyType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this recipe.
     * @param {Recipe} [recipe] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateRecipe(id: string, recipe?: Recipe, options?: any) {
        return ApiApiFp(this.configuration).updateRecipe(id, recipe, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this recipe book.
     * @param {RecipeBook} [recipeBook] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateRecipeBook(id: string, recipeBook?: RecipeBook, options?: any) {
        return ApiApiFp(this.configuration).updateRecipeBook(id, recipeBook, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this recipe book entry.
     * @param {RecipeBookEntry} [recipeBookEntry] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateRecipeBookEntry(id: string, recipeBookEntry?: RecipeBookEntry, options?: any) {
        return ApiApiFp(this.configuration).updateRecipeBookEntry(id, recipeBookEntry, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this shopping list.
     * @param {ShoppingList} [shoppingList] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateShoppingList(id: string, shoppingList?: ShoppingList, options?: any) {
        return ApiApiFp(this.configuration).updateShoppingList(id, shoppingList, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this shopping list entry.
     * @param {ShoppingListEntry} [shoppingListEntry] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateShoppingListEntry(id: string, shoppingListEntry?: ShoppingListEntry, options?: any) {
        return ApiApiFp(this.configuration).updateShoppingListEntry(id, shoppingListEntry, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this shopping list recipe.
     * @param {ShoppingListRecipe} [shoppingListRecipe] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateShoppingListRecipe(id: string, shoppingListRecipe?: ShoppingListRecipe, options?: any) {
        return ApiApiFp(this.configuration).updateShoppingListRecipe(id, shoppingListRecipe, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this step.
     * @param {Step} [step] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateStep(id: string, step?: Step, options?: any) {
        return ApiApiFp(this.configuration).updateStep(id, step, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this storage.
     * @param {Storage} [storage] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateStorage(id: string, storage?: Storage, options?: any) {
        return ApiApiFp(this.configuration).updateStorage(id, storage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this supermarket.
     * @param {Supermarket} [supermarket] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateSupermarket(id: string, supermarket?: Supermarket, options?: any) {
        return ApiApiFp(this.configuration).updateSupermarket(id, supermarket, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this supermarket category.
     * @param {SupermarketCategory} [supermarketCategory] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateSupermarketCategory(id: string, supermarketCategory?: SupermarketCategory, options?: any) {
        return ApiApiFp(this.configuration).updateSupermarketCategory(id, supermarketCategory, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this supermarket category relation.
     * @param {SupermarketCategoryRelation} [supermarketCategoryRelation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateSupermarketCategoryRelation(id: string, supermarketCategoryRelation?: SupermarketCategoryRelation, options?: any) {
        return ApiApiFp(this.configuration).updateSupermarketCategoryRelation(id, supermarketCategoryRelation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this sync.
     * @param {Sync} [sync] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateSync(id: string, sync?: Sync, options?: any) {
        return ApiApiFp(this.configuration).updateSync(id, sync, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this unit.
     * @param {Unit} [unit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateUnit(id: string, unit?: Unit, options?: any) {
        return ApiApiFp(this.configuration).updateUnit(id, unit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this unit conversion.
     * @param {UnitConversion} [unitConversion] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateUnitConversion(id: string, unitConversion?: UnitConversion, options?: any) {
        return ApiApiFp(this.configuration).updateUnitConversion(id, unitConversion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this user file.
     * @param {string} name 
     * @param {any} file 
     * @param {number} [id2] 
     * @param {string} [fileDownload] 
     * @param {string} [preview] 
     * @param {number} [fileSizeKb] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateUserFile(id: string, name: string, file: any, id2?: number, fileDownload?: string, preview?: string, fileSizeKb?: number, options?: any) {
        return ApiApiFp(this.configuration).updateUserFile(id, name, file, id2, fileDownload, preview, fileSizeKb, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id A unique integer value identifying this view log.
     * @param {ViewLog} [viewLog] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateViewLog(id: string, viewLog?: ViewLog, options?: any) {
        return ApiApiFp(this.configuration).updateViewLog(id, viewLog, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ApiImportOpenDataApi - axios parameter creator
 * @export
 */
export const ApiImportOpenDataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createImportOpenData: async (body?: any, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api-import-open-data/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listImportOpenDatas: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api-import-open-data/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApiImportOpenDataApi - functional programming interface
 * @export
 */
export const ApiImportOpenDataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApiImportOpenDataApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createImportOpenData(body?: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createImportOpenData(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listImportOpenDatas(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<any>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listImportOpenDatas(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApiImportOpenDataApi - factory interface
 * @export
 */
export const ApiImportOpenDataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApiImportOpenDataApiFp(configuration)
    return {
        /**
         * 
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createImportOpenData(body?: any, options?: any): AxiosPromise<any> {
            return localVarFp.createImportOpenData(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listImportOpenDatas(options?: any): AxiosPromise<Array<any>> {
            return localVarFp.listImportOpenDatas(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApiImportOpenDataApi - object-oriented interface
 * @export
 * @class ApiImportOpenDataApi
 * @extends {BaseAPI}
 */
export class ApiImportOpenDataApi extends BaseAPI {
    /**
     * 
     * @param {any} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiImportOpenDataApi
     */
    public createImportOpenData(body?: any, options?: any) {
        return ApiImportOpenDataApiFp(this.configuration).createImportOpenData(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiImportOpenDataApi
     */
    public listImportOpenDatas(options?: any) {
        return ApiImportOpenDataApiFp(this.configuration).listImportOpenDatas(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ApiTokenAuthApi - axios parameter creator
 * @export
 */
export const ApiTokenAuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} username 
         * @param {string} password 
         * @param {string} [token] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAuthToken: async (username: string, password: string, token?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('createAuthToken', 'username', username)
            // verify required parameter 'password' is not null or undefined
            assertParamExists('createAuthToken', 'password', password)
            const localVarPath = `/api-token-auth/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (username !== undefined) { 
                localVarFormParams.append('username', username as any);
            }
    
            if (password !== undefined) { 
                localVarFormParams.append('password', password as any);
            }
    
            if (token !== undefined) { 
                localVarFormParams.append('token', token as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApiTokenAuthApi - functional programming interface
 * @export
 */
export const ApiTokenAuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApiTokenAuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} username 
         * @param {string} password 
         * @param {string} [token] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAuthToken(username: string, password: string, token?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAuthToken(username, password, token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApiTokenAuthApi - factory interface
 * @export
 */
export const ApiTokenAuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApiTokenAuthApiFp(configuration)
    return {
        /**
         * 
         * @param {string} username 
         * @param {string} password 
         * @param {string} [token] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAuthToken(username: string, password: string, token?: string, options?: any): AxiosPromise<AuthToken> {
            return localVarFp.createAuthToken(username, password, token, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApiTokenAuthApi - object-oriented interface
 * @export
 * @class ApiTokenAuthApi
 * @extends {BaseAPI}
 */
export class ApiTokenAuthApi extends BaseAPI {
    /**
     * 
     * @param {string} username 
     * @param {string} password 
     * @param {string} [token] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiTokenAuthApi
     */
    public createAuthToken(username: string, password: string, token?: string, options?: any) {
        return ApiTokenAuthApiFp(this.configuration).createAuthToken(username, password, token, options).then((request) => request(this.axios, this.basePath));
    }
}


